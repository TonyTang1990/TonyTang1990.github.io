<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Sort Algorithm | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="排序算法概念
时间复杂度 — 指执行算法所需要的计算工作量 

平均时间复杂度 — 理论上一般情况的时间复杂度
最坏时间复杂度 — 特殊情况下（导致时间耗费最多的数据输入）
最优时间复杂度 — 特殊情况下（导致时间耗费最少的数据输入）


空间复杂度 — 指执行算法所需要的内存空间


排序算法
冒泡排序(Sort Algorithm)基本思想：

比较相邻的元素。如果第一个比第二个大，就交换他们">
<meta property="og:type" content="article">
<meta property="og:title" content="Sort Algorithm">
<meta property="og:url" content="http://yoursite.com/2015/07/11/Sort-Algorithm/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="排序算法概念
时间复杂度 — 指执行算法所需要的计算工作量 

平均时间复杂度 — 理论上一般情况的时间复杂度
最坏时间复杂度 — 特殊情况下（导致时间耗费最多的数据输入）
最优时间复杂度 — 特殊情况下（导致时间耗费最少的数据输入）


空间复杂度 — 指执行算法所需要的内存空间


排序算法
冒泡排序(Sort Algorithm)基本思想：

比较相邻的元素。如果第一个比第二个大，就交换他们">
<meta property="og:image" content="http://yoursite.com/img/Algorithem/Sort-Algorithem.PNG">
<meta property="og:updated_time" content="2015-08-26T16:47:21.066Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sort Algorithm">
<meta name="twitter:description" content="排序算法概念
时间复杂度 — 指执行算法所需要的计算工作量 

平均时间复杂度 — 理论上一般情况的时间复杂度
最坏时间复杂度 — 特殊情况下（导致时间耗费最多的数据输入）
最优时间复杂度 — 特殊情况下（导致时间耗费最少的数据输入）


空间复杂度 — 指执行算法所需要的内存空间


排序算法
冒泡排序(Sort Algorithm)基本思想：

比较相邻的元素。如果第一个比第二个大，就交换他们">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Sort-Algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/11/Sort-Algorithm/" class="article-date">
  <time datetime="2015-07-11T07:38:16.000Z" itemprop="datePublished">2015-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Sort Algorithm
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法概念">排序算法概念</h1><ol>
<li><p><strong>时间复杂度</strong> — 指执行算法所需要的计算工作量 </p>
<ol>
<li><em>平均时间复杂度</em> — 理论上一般情况的时间复杂度</li>
<li><em>最坏时间复杂度</em> — 特殊情况下（导致时间耗费最多的数据输入）</li>
<li><em>最优时间复杂度</em> — 特殊情况下（导致时间耗费最少的数据输入）</li>
</ol>
</li>
<li><p><strong>空间复杂度</strong> — 指执行算法所需要的内存空间</p>
</li>
</ol>
<h1 id="排序算法">排序算法</h1><hr>
<h2 id="冒泡排序(Sort_Algorithm)">冒泡排序(Sort Algorithm)</h2><p><em>基本思想：</em></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><em>Code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* sortarray)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//双重循环都跟数据大小有关</span></span><br><span class="line">    <span class="comment">//所以冒泡排序平均时间复杂度是O(square(n))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intArraySize(sortarray); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; intArraySize(sortarray); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( sortarray[i] &gt; sortarray[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">swap_t</span>ime++;</span><br><span class="line">                swap(sortarray[i], sortarray[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>冒泡排序时间复杂度</em><br>平均时间复杂度：O(square(n))<br>最坏时间复杂度：O(square(n)) （每一次比较都需要交换）<br>最优时间复杂度：O(n) （第一次循环就完成所有排序而无需进行后面的，需要判断结束条件）</p>
<h2 id="堆排序(Heap_Sort)">堆排序(Heap Sort)</h2><p><em>相关概念</em></p>
<ol>
<li>完全二叉树<br>除最后一层外，每一层的节点数均达到最大值；在最后一层上只缺右边的若干结点</li>
<li>堆<br>ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点 </li>
</ol>
<p><em>基本思想</em><br>利用最大堆最小堆的特性，我们可以很容易的拿到最大或最小值，通过构建最大最小堆我们可以得到排序后的值</p>
<ol>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ol>
<p><em>Code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整堆确保堆是最大堆，这里花O(log(n))，跟堆的深度有关</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>* sortarray, <span class="keyword">int</span> parentindex, <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max_index = parentindex;</span><br><span class="line">	<span class="keyword">int</span> left_child_index = parentindex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> right_child_index = parentindex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Chose biggest one between parent and left&amp;right child</span></span><br><span class="line">	<span class="keyword">if</span>( left_child_index &lt; length &amp;&amp; sortarray[left_child_index] &gt; sortarray[max_index] )</span><br><span class="line">	&#123;</span><br><span class="line">		max_index = left_child_index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( right_child_index &lt; length &amp;&amp; sortarray[right_child_index] &gt; sortarray[max_index] )</span><br><span class="line">	&#123;</span><br><span class="line">		max_index = right_child_index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//If any child is bigger than parent, </span></span><br><span class="line">	<span class="comment">//then we swap it and do adjust for child again to make sure meet max heap definition</span></span><br><span class="line">	<span class="keyword">if</span>( max_index != parentindex )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">swap_t</span>ime++;</span><br><span class="line">		swap(sortarray[max_index], sortarray[parentindex]);</span><br><span class="line">		heapAdjust(sortarray, max_index, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过初试数据构建最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildingHeap</span><span class="params">(<span class="keyword">int</span>* sortarray)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="keyword">int</span>(intArraySize(sortarray)/<span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.2 Adjust heap</span></span><br><span class="line">		<span class="comment">//Make sure meet max heap definition</span></span><br><span class="line">		<span class="comment">//Max Heap definition:</span></span><br><span class="line">		<span class="comment">// (k(i) &gt;= k(2i) &amp;&amp; k(i) &gt;= k(2i+1))   (1 &lt;= i &lt;= n/2)</span></span><br><span class="line">		heapAdjust(sortarray, i, intArraySize(sortarray));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>* sortarray)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Steps:</span></span><br><span class="line">	<span class="comment">// 1. Build heap</span></span><br><span class="line">	<span class="comment">// 1.1 Init heap</span></span><br><span class="line">	<span class="comment">// 1.2 Adjust heap</span></span><br><span class="line">	<span class="comment">// 2. Sort heap</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. Build max heap</span></span><br><span class="line">	<span class="comment">// 1.1 Init heap</span></span><br><span class="line">	<span class="comment">//Assume we construct max heap</span></span><br><span class="line">	buildingHeap(sortarray);</span><br><span class="line">	<span class="comment">//2. Sort heap</span></span><br><span class="line">	<span class="comment">//这里花O(n)，跟数据数量有关</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = intArraySize(sortarray) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//swap first element and last element</span></span><br><span class="line">		<span class="comment">//do adjust heap process again to make sure the new array are still max heap</span></span><br><span class="line">		swap(sortarray[i],sortarray[<span class="number">0</span>]);</span><br><span class="line">		<span class="comment">//Due to we already building max heap before,</span></span><br><span class="line">		<span class="comment">//so  we just need to adjust for index 0 after we swap first and last element</span></span><br><span class="line">		heapAdjust(sortarray, <span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>堆排序时间复杂度</em><br>平均时间复杂度：O(n <em> log(n))<br>最坏时间复杂度：O(n </em> log(n))<br>最优时间复杂度：O(n <em> log(n)) (时间复杂度都跟堆的深度和数据长度相关，无可避免的需要去做堆调整和堆排序<br>所以最坏时间复杂度和最优时间复杂度都是O(n</em>log(n)</p>
<h2 id="快速排序(Quick_Sort)">快速排序(Quick Sort)</h2><p><em>基本思想</em></p>
<ol>
<li>选择一个值作为基准后，通过比较把小于基准值的值放到基准值左边，大于基准值的放到基准值右边，这样一来就有一个数据放在了正确位置。</li>
<li>通过分治的思想，将数据组不断细分成小数据组进行基准值的排序直到细分到只剩一个数据为止</li>
</ol>
<p><em>Code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* sortarray, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//choose pivot</span></span><br><span class="line">	<span class="keyword">int</span> pivot = sortarray[r];</span><br><span class="line">	<span class="keyword">int</span> i = l;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> j = l; j &lt; r; j++ )</span><br><span class="line">	&#123;</span><br><span class="line">		time_complexity++;</span><br><span class="line">		<span class="keyword">if</span>( sortarray[j] &lt;= pivot )</span><br><span class="line">		&#123;</span><br><span class="line">			swap(sortarray[i],sortarray[j]);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(sortarray[i], sortarray[r]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>* sortarray, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">bool</span> benableoptimize)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//partition</span></span><br><span class="line">	<span class="comment">//Here we use last element of array as pivot</span></span><br><span class="line">	<span class="comment">//recursion</span></span><br><span class="line">	<span class="comment">//Pivot chosen to optimize quicksort</span></span><br><span class="line">	<span class="comment">// median-of-three</span></span><br><span class="line">	<span class="keyword">int</span> pivotpos; </span><br><span class="line">	<span class="keyword">int</span> middlepos = (high + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>( benableoptimize )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( sortarray[low] &gt; sortarray[middlepos] )</span><br><span class="line">		&#123;</span><br><span class="line">			swap(sortarray[low],sortarray[middlepos]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( sortarray[middlepos] &gt; sortarray[high] )</span><br><span class="line">		&#123;</span><br><span class="line">			swap(sortarray[middlepos],sortarray[high]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( sortarray[low] &gt; sortarray[middlepos] )</span><br><span class="line">		&#123;</span><br><span class="line">			swap(sortarray[low], sortarray[middlepos]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pivotpos = middlepos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pivotpos = high;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	pivotpos=partition(sortarray,low,pivotpos);</span><br><span class="line">	quicksort(sortarray,low,pivotpos-<span class="number">1</span>,benableoptimize);</span><br><span class="line">	quicksort(sortarray,pivotpos+<span class="number">1</span>,high,benableoptimize);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>时间复杂度</em><br>平均时间复杂度：O(n <em> log(n)) (细分的时候每一次都对半分)<br>最坏时间复杂度：O(n </em> square(n)) （细分的时候每一次都分成一个和其他所有,所以在比较有序数据组面前快排效率不高）</p>
<p>最优时间复杂度：<br>快速排序可以通过选择更有效的基准值来提高效率<br>基准值会影响数据组的细分也就是影响后半部分分治的效率，所以最优时间复杂度取决于如何取基准值（上面提到median-of-three方式选基准值就是通过把第一和中间和最后元素排序后选取中间元素作为基准值来确保在细分的时候尽可能满足对半分从而提高效率）</p>
<h2 id="归并排序(Merge_Sort)">归并排序(Merge Sort)</h2><p><em>基本思想</em></p>
<ol>
<li>通过分治思想，把数据组的排列细分成排序多个的小数据组后合并</li>
<li>通过比较两两有序的小数据组完成合并后的数据排序，然后和其他有序数据组再次进行比较合并，最终完成所有数据的排列和合并</li>
</ol>
<p><em>Code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&amp; sortarray, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left_size = middle - start + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> right_size = end - middle;</span><br><span class="line">	<span class="built_in">vector</span> left;</span><br><span class="line">	<span class="built_in">vector</span> right;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left_size; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		left.push_back(sortarray[start + i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; right_size; j++ )</span><br><span class="line">	&#123;</span><br><span class="line">		right.push_back(sortarray[j + middle + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = start;</span><br><span class="line">	<span class="comment">//The worst condition is compare n * log(n) - n + 1</span></span><br><span class="line">	<span class="comment">//The best condition is compare n * log(n) / 2</span></span><br><span class="line">	<span class="keyword">while</span>( k &lt; left_size &amp;&amp; l &lt; right_size )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( left[k] &lt; right[l] )</span><br><span class="line">		&#123;</span><br><span class="line">			sortarray[index] = left[k];</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sortarray[index] = right[l];</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( k &lt; left_size )</span><br><span class="line">	&#123;</span><br><span class="line">		sortarray[index] = left[k];</span><br><span class="line">		k++;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>( l &lt; right_size )</span><br><span class="line">	&#123;</span><br><span class="line">		sortarray[index] = right[l];</span><br><span class="line">		l++;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&amp; sortarray, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sort first (subdivide array)</span></span><br><span class="line">	<span class="comment">//then merge (finally merge to together recursively)</span></span><br><span class="line">	<span class="keyword">if</span>( start &lt; end )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">		mergesort(sortarray, start, middle);</span><br><span class="line">		mergesort(sortarray, middle + <span class="number">1</span>, end);</span><br><span class="line">		merge(sortarray, start, middle, end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>时间复杂度</em><br>平均时间复杂度：O( n <em> log(n) )<br>最优时间复杂度：O( n )（数据组已经有序，只需要把细分数据合并）<br>最坏时间复杂度：O( n </em> log(n) )</p>
<p><em>Note</em><br>因为归并排序需要存储细分后的数据组，所以归并排序比较占内存<br>归并比较次数 n介于 n <em> log(n) - n + 1 和 n </em> log(n) / 2<br>归并赋值次数2n <em> log(n)<br>归并平均时间复杂度和最坏时间复杂度都是n </em> log(n)<br>相比快速排序归并排序更稳定(最坏情况下)，而且更适合局部数据有序的情况</p>
<h2 id="插入排序(Insert_Sort)">插入排序(Insert Sort)</h2><p><em>基本思想</em><br>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p><em>Code</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>* sortarray)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="comment">//从第二个数开始取，依次插入，O(n)</span></span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; intArraySize(sortarray); i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		temp = sortarray[i];</span><br><span class="line">		<span class="comment">//依次跟之前已经排序好的数组元素比较O(n)</span></span><br><span class="line">		<span class="keyword">for</span>( j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; sortarray[j] &gt; temp; j-- )</span><br><span class="line">		&#123;</span><br><span class="line">			sortarray[j+<span class="number">1</span>] = sortarray[j];</span><br><span class="line">		&#125;</span><br><span class="line">		sortarray[j+<span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>时间复杂度</em><br>平均时间复杂度：O(square(n))<br>最坏时间复杂度：O(square(n))<br>最优时间复杂度：O(n)（数据已经是有序的情况下，不需要比较，直接插入）</p>
<h1 id="总结">总结</h1><p>各排序算法有各自的优势，适合不同的情况。<br>相对稳定且时间复杂度低的排序算法：<br>堆排序，快速排序，归并排序</p>
<p>而归并排序相比快速排序更稳定（最坏情况下），更适合局部数据有序的情况，但归并的内存占用比较多</p>
<p>插入排序虽然时间复杂度比较高，但在已经排好序的数据面前，时间复杂度是O(n)<br>插入排序适合有序数据组且经常需要插入数据的情况</p>
<p>各排序算法时间复杂度总结：<br>来源：<a href="http://bost.ocks.org/mike/algorithms/" target="_blank" rel="external">Visualizing Algorithms</a><br><img src="/img/Algorithem/Sort-Algorithem.PNG" alt="Sort-Algorithem"></p>
<p>参考：<br><a href="http://www.cricode.com/3212.html" target="_blank" rel="external">8大排序算法图文讲解</a></p>
<p>推荐网站：<br><a href="http://bost.ocks.org/mike/algorithms/" target="_blank" rel="external">Visualizing Algorithms</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/11/Sort-Algorithm/" data-id="cif9i0uru000dgco0o845oncs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sort/">Sort</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/15/Unity-Study/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Unity Study
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Engine/">Game_Engine</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-Language/">Programming Language</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rendering/">Rendering</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming/">Programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OpenGL/" style="font-size: 20px;">OpenGL</a> <a href="/tags/Programming/" style="font-size: 10px;">Programming</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/02/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/08/29/Computer-Graphic-Study/">Computer_Graphic_Study</a>
          </li>
        
          <li>
            <a href="/2015/08/26/OpenGL-Study/">OpenGL_Study</a>
          </li>
        
          <li>
            <a href="/2015/08/15/CSharp-Study/">C# Study</a>
          </li>
        
          <li>
            <a href="/2015/07/15/Unity-Study/">Unity Study</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>