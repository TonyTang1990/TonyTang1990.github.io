<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>OpenGL_Study | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL_Study">
<meta property="og:url" content="http://yoursite.com/2015/08/26/OpenGL-Study/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:image" content="http://yoursite.com/img/OpenGL/OpenGL_Render_Pipeline.PNG">
<meta property="og:updated_time" content="2015-09-20T18:36:11.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenGL_Study">
<meta name="twitter:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-OpenGL-Study" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/26/OpenGL-Study/" class="article-date">
  <time datetime="2015-08-26T15:57:05.000Z" itemprop="datePublished">2015-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Rendering/">Rendering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OpenGL_Study
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好</strong>  — 游戏梦</p>
<p>参考书籍：<br>《OpenGL Programming Guide 8th Edition》 — Addison Wesley<br>《Fundamentals of Computer Graphics (3rd Edition)》 — Peter Shirley, Steve Marschnner<br>《Real-Time Rendering, Third Edition》 — Tomas Akenine-Moller, Eric Haines, Naty Hoffman</p>
<p><a href="http://blog.sina.com.cn/tonytang1990" target="_blank" rel="external">旧博客地址</a></p>
<p><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/" target="_blank" rel="external">渲染相关概念学习</a></p>
<h1 id="OpenGL">OpenGL</h1><h2 id="Introdction_to_OpenGL">Introdction to OpenGL</h2><h3 id="What_is_OpenGL?">What is OpenGL?</h3><ol>
<li>OpenGL is an application programming interface – “API” for short – which is merely a software library for accessing features in graphics hardware.(访问图形硬件设备功能的API)</li>
<li>OpenGL is a “C” language library(OpenGL是一个C语言库)</li>
</ol>
<h3 id="History">History</h3><p>It was first developed at Silicon Graphics Computer Systems with Version 1,0 released in July of 1994(<a href="https://zh.wikipedia.org/zh/OpenGL" target="_blank" rel="external">wiki</a>)</p>
<h2 id="OpenGL_relative_knowledge">OpenGL relative knowledge</h2><ol>
<li>Install the appropriate graphic driver which enables usage of the functionality provided.<br> check the graphic drive update.(更新显卡驱动获得最新的OpenGL版本支持)</li>
<li>Using OpenGL extensions viewer to check which OpenGL version is supported(查看当前硬件所支持的OpenGL版本)<br> <a href="http://www.realtech-vr.com/glview/download.php" target="_blank" rel="external">download website</a></li>
<li><p>Extention tools  — help us to quick start to learn OpenGL</p>
<ol>
<li><p><a href="http://zh.wikipedia.org/wiki/GLUT" target="_blank" rel="external">Glut (OpenGL Utility Toolkit)</a><br> GLUT（英文全写：OpenGL Utility Toolkit）是一个处理OpenGL程式的工具库，负责处理和底层操作系统的呼叫以及I/O，并包括了以下常见的功能：</p>
<ol>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘及鼠标的事件</li>
<li>以一个函数呼叫绘制某些常用的立体图形，例如长方体、球、以及犹他茶壶（实心或只有骨架，如glutWireTeapot()）</li>
<li><p>提供了简单选单列的实现</p>
<p>GLUT是由Mark J. Kilgard在Silicon Graphics工作时所写，此人同时也是OpenGL Programming for the X Window System以及The Cg Tutorial: The Definitive Guide to Programmable Real-Time Graphics两书的作者。</p>
<p>GLUT的两个主要目的是建立一个跨平台的函式库（事实上GLUT就是跨平台的），以及简化学习OpenGL的条件。透过GLUT编写OpenGL通常只需要增加几行额外GLUT的程式码，而且不需要知道每个不同操作系统处理视窗的API。</p>
<p>所有的GLUT函数都以glut作为开头，例如glutPostRedisplay()。</p>
</li>
</ol>
</li>
<li><a href="http://en.wikipedia.org/wiki/OpenGL_Extension_Wrangler_Library" target="_blank" rel="external">Glew ( OpenGL Extension Wrangler Library)</a><br> The OpenGL Extension Wrangler Library (GLEW) is a cross-platform C/C++ library that helps in querying and loading OpenGL extensions. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.(Glew是一个支持跨平台的C/C++库，用于运行时鉴别OpenGL扩展所支持的版本)<br> <a href="http://www.opengl.org/sdk/tools/" target="_blank" rel="external">more info for extention tools</a></li>
</ol>
</li>
<li><p>Using extention tools — Glu &amp; Glew</p>
<ol>
<li>add glu.lib &amp; glew.lib into additional dependencies</li>
<li>add the directory that includes glu.h &amp; glew.h into include dirctory</li>
</ol>
</li>
<li><p>Understand OpenGL render pipeline<br><img src="/img/OpenGL/OpenGL_Render_Pipeline.PNG" alt="OpenGL Render Pipeline"></p>
<ol>
<li><p>Vertex Data<br> Sending Data to OpenGL</p>
</li>
<li><p>Vertex Shader<br> Process the data associated with that vertex</p>
</li>
<li><p>Tessellation Shader<br> Tessellation uses patchs to describe an object’s shape, and allows relatively simple collections of patch geometry to be tessellated to increase the number of geometric primitives providing better-looking models (eg: LOD) </p>
</li>
<li><p>Geometry Shader<br> Allows additional processing of individual geometric primitives, including creating new ones, before rasterization</p>
</li>
<li><p>Primitive Assembly<br>Organizes the vertices into their associated geometric primitives in preparation for clipping and rasterization </p>
</li>
<li><p>Clipping<br> Clip the vertex and pixels are outside of the viewport – this operation is handled automatically by OpenGL</p>
</li>
<li><p>Rasterization<br> Fragment generation. Pixels have a home in the framebuffer, while a fragment still can be rejected and never update its associated pixel location. </p>
</li>
<li><p>Fragment Shading<br> Use a fragment shading to determine the fragment’s final color, and potentially its depth value</p>
</li>
<li><p>Per-Fragment Operations<br> If a fragment successfully makes it through all of the enabled tests (eg: depth testing, stencil testing), it may be written directly to the framebuffer, updating the color of its pixel, or if blending is enabled, the fragment’s color will be combined with the pixel’s current color to generate a new color that is written into the framebuffer</p>
</li>
</ol>
<p>Note:<br>Fragment’s visibility is determined using depth testing and stencil testing<br>Pixel data is usually stored in texture map for use with texture mapping, which allows any texture stage to look up data values from one or more texture maps.</p>
</li>
<li><p><a href="http://zh.wikipedia.org/wiki/GLSL" target="_blank" rel="external">Understand OpenGL Shader Language (GLSL)</a><br> GLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。</p>
<p> 编译和执行<br> GLSL 着色器不是独立的应用程式；其需要使用 OpenGL API 的应用程式。C、C++、C#、Delphi 和 Java 皆支援 OpenGL API，且支援 OpenGL 着色语言。<br> GLSL 着色器本身只是简单的字串集，这些字串集会传送到硬件厂商的驱动程式，并从程式内部的 OpenGL API 进入点编译。着色器可从程式内部或读入纯文字档来即时建立，但必须以字串形式传送到驱动程式。</p>
<p> 工具<br> GLSL 着色器可以事先建立和测试，现有以下 GLSL 开发工具：<br> RenderMonkey - 这个软件是由 ATI 制作的，提供界面用以建立、编译和除错 GLSL 着色器，和 DirectX 着色器一样。仅能在 Windows 平台上执行。<br> GLSLEditorSample - 在 Mac OS X 上，它是目前唯一可用的程式，其提供着色器的建立和编译，但不能除错。它是 cocoa 应用程式，仅能在 Mac OS X 上执行。<br> Lumina - Lumina 是新的 GLSL 开发工具。其使用 QT 界面，可以跨平台。</p>
</li>
<li><p>OpenGL Shader Fundamentals</p>
</li>
<li><p>The color space that is used by OpenGL<br> In OpenGL, colors are represented in what’s called the RGB color space</p>
</li>
</ol>
<h2 id="OpenGL_learning_journal">OpenGL learning journal</h2><h3 id="API">API</h3><ol>
<li>查看哪些错误标志位被设置<br>了解：<br>  OpenGL在内部保留了一组错误标志位(共4个),其中每一个标志位代表一种不同类型的错误。当错误一个发生时，与这个错误对应的标志就会被设置。如果被设置的标志不止一个，glGetError仍然只返回一个唯一的值。当glGetError函数被调用时，这个值随后被清除，然后在glGetError再次被调用时将返回一个错误标志或GL_NO_ERROR为止</li>
</ol>
<p>函数：<br>Glenum glGetError(void); </p>
<ol>
<li><p>查询OpenGL的渲染引擎（OpenGL驱动程序）的生产商和版本号<br>了解：<br> OpenGL允许提供商通过它的扩展机制进行创新。为了使用特定供应商所提供的一些特定扩展功能，我们希望限制这个特定供应商所提供驱动程序的最低版本号。<br>函数：<br>const Glubyte *glGetString(GLenum name);</p>
</li>
<li><p>设置和查询管线的状态<br>了解：<br>  OpenGL使用状态模型来跟踪所有的OpenGL状态变量来实现对OpenGL渲染状态的控制<br>函数：<br>void glEnable(GLenum capability);<br>void glDisable(GLenum capability);<br>void glGet<em>(Type)v(GLenum pname, GLboolean </em>params);</p>
</li>
<li><p>查询program的一些相关信息和一些错误信息<br>了解：<br> OpenGL的pragram链接可能由于GLSL里面的一些错误导致出错，我们需要知道关于program object的一些相关错误信息，同时我们也想知道我们现有的program相关的一些信息<br>函数：<br>void glGetProgramiv(GLuint program, GLenum pname, GLint *params);</p>
</li>
<li><p>得到shader链接出错的log信息<br>了解：<br> OpenGL的shader object可能链接失败，我们需要知道shader里面出错的信息<br>函数：<br>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei <em>length, GLchar </em>infoLog);</p>
</li>
</ol>
<p>注意:<br>可以通过glGetProgramiv()去得到program的一些log相关信息，比如GL_INFO_LOG_LENGTH</p>
<h3 id="OpenGL_Knowledge:">OpenGL Knowledge:</h3><pre><code>1. "OpenGL <span class="operator"><span class="keyword">Execute</span> Model: 
    The model <span class="keyword">for</span> interpretation <span class="keyword">of</span> OpenGL commands <span class="keyword">is</span> client-<span class="keyword">server</span>. An application (the client) issues commands, which <span class="keyword">are</span> interpreted <span class="keyword">and</span> processed <span class="keyword">by</span> OpenGL (the <span class="keyword">server</span>). The <span class="keyword">server</span> may <span class="keyword">or</span> may <span class="keyword">not</span> operate <span class="keyword">on</span> the same computer <span class="keyword">as</span> the client. <span class="keyword">In</span> this sense, OpenGL <span class="keyword">is</span> network-transparent. <span class="string">"

2. "</span>client-<span class="keyword">server</span> 模式:
    OpenGL 是一种 client-<span class="keyword">server</span> 模式，当你的应用程序调用 OpenGL 函数时， 它将告诉OpenGL client， 然后 client 将渲染命令传送给 <span class="keyword">server</span>. 这里client 和 <span class="keyword">server</span>可能是不同的计算机，或是同一台计算机上的不同进程。一般来说 <span class="keyword">server</span> 是在 GPU上处理的， 而 client 是在 CPU 上处理的，这样分担了 CPU 的负担， 同时高效利用了GPU.<span class="string">"</span></span>
</code></pre><p>但如果Client和Server没在同一个机器上，我们就需要一种一种网络传输协议框架来实现他们之间的交流：<br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a></p>
<p>但X Window System里的client和server与传统的C/S模式相反，client是负责运算的，server是负责显示的。<br>但OpenGL的client和server的交流原理是与X Window System相似的</p>
<h1 id="Reference_Website:">Reference Website:</h1><p><a href="http://www.opengl.org/sdk/docs/man4/" target="_blank" rel="external">OpenGL 4 reference page</a><br><a href="http://blog.csdn.net/guolihui112/article/details/5702915" target="_blank" rel="external">client-server 模式</a><br><a href="http://www.glprogramming.com/blue/ch01.html" target="_blank" rel="external">OpenGL Execute Model</a><br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a></p>
<p>Note:<br><strong>OpenGL uses right-handed coordinate system (OpenGL使用右手坐标系)</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/26/OpenGL-Study/" data-id="cif9i0ury000igco0pmo6cjiw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/">OpenGL</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/29/Computer-Graphic-Study/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Computer_Graphic_Study
        
      </div>
    </a>
  
  
    <a href="/2015/08/15/CSharp-Study/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C# Study</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Game-Engine/">Game_Engine</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-Language/">Programming Language</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rendering/">Rendering</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/">OpenGL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming/">Programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/">Unity</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OpenGL/" style="font-size: 20px;">OpenGL</a> <a href="/tags/Programming/" style="font-size: 10px;">Programming</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/10/02/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/08/29/Computer-Graphic-Study/">Computer_Graphic_Study</a>
          </li>
        
          <li>
            <a href="/2015/08/26/OpenGL-Study/">OpenGL_Study</a>
          </li>
        
          <li>
            <a href="/2015/08/15/CSharp-Study/">C# Study</a>
          </li>
        
          <li>
            <a href="/2015/07/15/Unity-Study/">Unity Study</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>