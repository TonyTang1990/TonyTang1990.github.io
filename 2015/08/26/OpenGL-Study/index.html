
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>OpenGL_Study | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL_Study">
<meta property="og:url" content="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGL_Render_Pipeline.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GLViewer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGLWindow.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingOpenGL.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingShader.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UniformVariable.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Interpolation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinateTranslation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinate2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject1.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject3.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject4.PNG">
<meta property="og:updated_time" content="2016-06-01T10:16:35.200Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenGL_Study">
<meta name="twitter:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">有时候不是习惯了一个人，而是在没有认可自己之前选择了一个人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/26/OpenGL-Study/" title="OpenGL_Study" itemprop="url">OpenGL_Study</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2015-08-26T15:57:05.000Z" itemprop="datePublished"> 發表於 2015-08-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
		
		</div>
		
		<p><strong>时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好</strong>  — 游戏梦</p>
<p>参考书籍：<br>《OpenGL Programming Guide 8th Edition》 — Addison Wesley<br>《Fundamentals of Computer Graphics (3rd Edition)》 — Peter Shirley, Steve Marschnner<br>《Real-Time Rendering, Third Edition》 — Tomas Akenine-Moller, Eric Haines, Naty Hoffman</p>
<p><a href="http://blog.sina.com.cn/tonytang1990" target="_blank" rel="external">旧博客地址</a></p>
<p><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/">渲染相关概念学习</a></p>
<h1 id="OpenGL">OpenGL</h1><h2 id="Introdction_to_OpenGL">Introdction to OpenGL</h2><h3 id="What_is_OpenGL?">What is OpenGL?</h3><ol>
<li>OpenGL is an application programming interface – “API” for short – which is merely a software library for accessing features in graphics hardware.(访问图形硬件设备功能的API)</li>
<li>OpenGL is a “C” language library(OpenGL是一个C语言库)</li>
</ol>
<h3 id="History">History</h3><p>It was first developed at Silicon Graphics Computer Systems with Version 1,0 released in July of 1994(<a href="https://zh.wikipedia.org/zh/OpenGL" target="_blank" rel="external">wiki</a>)</p>
<h3 id="Next_Generation_OpenGL">Next Generation OpenGL</h3><p><a href="https://en.wikipedia.org/wiki/Vulkan_%28API%29" target="_blank" rel="external">Vulkan</a></p>
<h2 id="OpenGL_relative_knowledge">OpenGL relative knowledge</h2><ol>
<li><p>Understand OpenGL render pipeline<br><img src="/img/OpenGL/OpenGL_Render_Pipeline.PNG" alt="OpenGL Render Pipeline"></p>
<ol>
<li><p>Vertex Data<br> Sending Data to OpenGL</p>
</li>
<li><p>Vertex Shader<br> Process the data associated with that vertex</p>
</li>
<li><p>Tessellation Shader<br> Tessellation uses patchs to describe an object’s shape, and allows relatively simple collections of patch geometry to be tessellated to increase the number of geometric primitives providing better-looking models (eg: LOD) </p>
</li>
<li><p>Geometry Shader<br> Allows additional processing of individual geometric primitives, including creating new ones, before rasterization</p>
</li>
<li><p>Primitive Assembly<br>Organizes the vertices into their associated geometric primitives in preparation for clipping and rasterization </p>
</li>
<li><p>Clipping<br> Clip the vertex and pixels are outside of the viewport – this operation is handled automatically by OpenGL</p>
</li>
<li><p>Rasterization<br> Fragment generation. Pixels have a home in the framebuffer, while a fragment still can be rejected and never update its associated pixel location. </p>
</li>
<li><p>Fragment Shading<br> Use a fragment shading to determine the fragment’s final color, and potentially its depth value</p>
</li>
<li><p>Per-Fragment Operations<br> If a fragment successfully makes it through all of the enabled tests (eg: depth testing, stencil testing), it may be written directly to the framebuffer, updating the color of its pixel, or if blending is enabled, the fragment’s color will be combined with the pixel’s current color to generate a new color that is written into the framebuffer</p>
</li>
</ol>
<p>Note:<br>Fragment’s visibility is determined using depth testing and stencil testing<br>Pixel data is usually stored in texture map for use with texture mapping, which allows any texture stage to look up data values from one or more texture maps.</p>
</li>
<li><p><a href="http://zh.wikipedia.org/wiki/GLSL" target="_blank" rel="external">Understand OpenGL Shader Language (GLSL)</a><br> GLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。</p>
<p> 编译和执行<br> GLSL 着色器不是独立的应用程式；其需要使用 OpenGL API 的应用程式。C、C++、C#、Delphi 和 Java 皆支援 OpenGL API，且支援 OpenGL 着色语言。<br> GLSL 着色器本身只是简单的字串集，这些字串集会传送到硬件厂商的驱动程式，并从程式内部的 OpenGL API 进入点编译。着色器可从程式内部或读入纯文字档来即时建立，但必须以字串形式传送到驱动程式。</p>
<p> 工具<br> GLSL 着色器可以事先建立和测试，现有以下 GLSL 开发工具：<br> RenderMonkey - 这个软件是由 ATI 制作的，提供界面用以建立、编译和除错 GLSL 着色器，和 DirectX 着色器一样。仅能在 Windows 平台上执行。<br> GLSLEditorSample - 在 Mac OS X 上，它是目前唯一可用的程式，其提供着色器的建立和编译，但不能除错。它是 cocoa 应用程式，仅能在 Mac OS X 上执行。<br> Lumina - Lumina 是新的 GLSL 开发工具。其使用 QT 界面，可以跨平台。</p>
</li>
<li><p>OpenGL Shader Fundamentals</p>
</li>
<li><p>The color space that is used by OpenGL<br> In OpenGL, colors are represented in what’s called the RGB color space</p>
</li>
</ol>
<h2 id="OpenGL_learning_journal">OpenGL learning journal</h2><h3 id="API">API</h3><ol>
<li>查看哪些错误标志位被设置<br>了解：<br>  OpenGL在内部保留了一组错误标志位(共4个),其中每一个标志位代表一种不同类型的错误。当错误一个发生时，与这个错误对应的标志就会被设置。如果被设置的标志不止一个，glGetError仍然只返回一个唯一的值。当glGetError函数被调用时，这个值随后被清除，然后在glGetError再次被调用时将返回一个错误标志或GL_NO_ERROR为止</li>
</ol>
<p>函数：<br>Glenum glGetError(void); </p>
<ol>
<li><p>查询OpenGL的渲染引擎（OpenGL驱动程序）的生产商和版本号<br>了解：<br> OpenGL允许提供商通过它的扩展机制进行创新。为了使用特定供应商所提供的一些特定扩展功能，我们希望限制这个特定供应商所提供驱动程序的最低版本号。<br>函数：<br>const Glubyte *glGetString(GLenum name);</p>
</li>
<li><p>设置和查询管线的状态<br>了解：<br>  OpenGL使用状态模型来跟踪所有的OpenGL状态变量来实现对OpenGL渲染状态的控制<br>函数：<br>void glEnable(GLenum capability);<br>void glDisable(GLenum capability);<br>void glGet<em>(Type)v(GLenum pname, GLboolean </em>params);</p>
</li>
<li><p>查询program的一些相关信息和一些错误信息<br>了解：<br> OpenGL的pragram链接可能由于GLSL里面的一些错误导致出错，我们需要知道关于program object的一些相关错误信息，同时我们也想知道我们现有的program相关的一些信息<br>函数：<br>void glGetProgramiv(GLuint program, GLenum pname, GLint *params);</p>
</li>
<li><p>得到shader链接出错的log信息<br>了解：<br> OpenGL的shader object可能链接失败，我们需要知道shader里面出错的信息<br>函数：<br>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei <em>length, GLchar </em>infoLog);</p>
</li>
</ol>
<p>注意:<br>可以通过glGetProgramiv()去得到program的一些log相关信息，比如GL_INFO_LOG_LENGTH</p>
<h3 id="OpenGL_Knowledge:">OpenGL Knowledge:</h3><pre><code>1. "OpenGL <span class="operator"><span class="keyword">Execute</span> Model: 
    The model <span class="keyword">for</span> interpretation <span class="keyword">of</span> OpenGL commands <span class="keyword">is</span> client-<span class="keyword">server</span>. An application (the client) issues commands, which <span class="keyword">are</span> interpreted <span class="keyword">and</span> processed <span class="keyword">by</span> OpenGL (the <span class="keyword">server</span>). The <span class="keyword">server</span> may <span class="keyword">or</span> may <span class="keyword">not</span> operate <span class="keyword">on</span> the same computer <span class="keyword">as</span> the client. <span class="keyword">In</span> this sense, OpenGL <span class="keyword">is</span> network-transparent. <span class="string">"

2. "</span>client-<span class="keyword">server</span> 模式:
    OpenGL 是一种 client-<span class="keyword">server</span> 模式，当你的应用程序调用 OpenGL 函数时， 它将告诉OpenGL client， 然后 client 将渲染命令传送给 <span class="keyword">server</span>. 这里client 和 <span class="keyword">server</span>可能是不同的计算机，或是同一台计算机上的不同进程。一般来说 <span class="keyword">server</span> 是在 GPU上处理的， 而 client 是在 CPU 上处理的，这样分担了 CPU 的负担， 同时高效利用了GPU.<span class="string">"</span></span>
</code></pre><p>但如果Client和Server没在同一个机器上，我们就需要一种一种网络传输协议框架来实现他们之间的交流：<br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a></p>
<p>但X Window System里的client和server与传统的C/S模式相反，client是负责运算的，server是负责显示的。<br>但OpenGL的client和server的交流原理是与X Window System相似的</p>
<h2 id="OpenGL_Practice">OpenGL Practice</h2><h3 id="Check_supported_OpenGL_version">Check supported OpenGL version</h3><ol>
<li>Install the appropriate graphic driver which enables usage of the functionality provided.<br> check the graphic drive update.(更新显卡驱动获得最新的OpenGL版本支持)</li>
<li>Using OpenGL extensions viewer to check which OpenGL version is supported(查看当前硬件所支持的OpenGL版本)<br> <a href="http://www.realtech-vr.com/glview/download.php" target="_blank" rel="external">download website</a></li>
</ol>
<p><img src="/img/OpenGL/GLViewer.PNG" alt="OpenGL_Viewer_Info"><br>从上图可以看出我当前的电脑和显卡驱动支持最高4.4，所以在使用学习OpenGL之前一定要确认好自己电脑所能支持的版本，避免后续不必要的问题。</p>
<p>检查完所支持的OpenGL版本后，下面我们需要介绍两个在学习OpenGL时为了帮助快速学习使用OpenGL的两个重要库（Glut &amp; Glew）</p>
<h3 id="Know_what_Glut_and_Glew_are,_and_how_to_use_them">Know what Glut and Glew are, and how to use them</h3><ol>
<li><p><a href="http://zh.wikipedia.org/wiki/GLUT" target="_blank" rel="external">Glut (OpenGL Utility Toolkit)</a><br> GLUT（英文全写：OpenGL Utility Toolkit）是一个处理OpenGL程式的工具库，负责处理和底层操作系统的呼叫以及I/O，并包括了以下常见的功能：</p>
<ol>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘及鼠标的事件</li>
<li>以一个函数呼叫绘制某些常用的立体图形，例如长方体、球、以及犹他茶壶（实心或只有骨架，如glutWireTeapot()）</li>
<li><p>提供了简单选单列的实现</p>
<p>GLUT是由Mark J. Kilgard在Silicon Graphics工作时所写，此人同时也是OpenGL Programming for the X Window System以及The Cg Tutorial: The Definitive Guide to Programmable Real-Time Graphics两书的作者。</p>
<p>GLUT的两个主要目的是建立一个跨平台的函式库（事实上GLUT就是跨平台的），以及简化学习OpenGL的条件。透过GLUT编写OpenGL通常只需要增加几行额外GLUT的程式码，而且不需要知道每个不同操作系统处理视窗的API。</p>
<p>所有的GLUT函数都以glut作为开头，例如glutPostRedisplay()。</p>
</li>
</ol>
</li>
<li><a href="http://en.wikipedia.org/wiki/OpenGL_Extension_Wrangler_Library" target="_blank" rel="external">Glew ( OpenGL Extension Wrangler Library)</a><br> The OpenGL Extension Wrangler Library (GLEW) is a cross-platform C/C++ library that helps in querying and loading OpenGL extensions. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.(Glew是一个支持跨平台的C/C++库，用于运行时鉴别OpenGL扩展所支持的版本)<br> <a href="http://www.opengl.org/sdk/tools/" target="_blank" rel="external">more info for extention tools</a></li>
</ol>
<p>How to use Glu &amp; Glew?</p>
<ol>
<li>add glu.lib &amp; glew.lib into additional dependencies</li>
<li>add the directory that includes glu.h &amp; glew.h into include dirctory</li>
<li>Include GL/freeglut.h &amp; GL/glew.h in source file<br>Note:<br>if you use static link, #define FREEGLUT_STATIC before you include GL/freeglut.h, otherwise it will look for freeglut.lib. #define GLEW_STATIC for Glew.</li>
</ol>
<p>include GL/glew.h before GL/freeglut.h, otherwise, it will through “fatal error C1189: #error :  gl.h included before glew.h”</p>
<p>Note:<br>后续的学习都是基于<a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">Modern OpenGL Tutorials</a>,后续提到的一些库的源码从该网站下载</p>
<h3 id="Open_a_Window">Open a Window</h3><p>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>OpenGLWindow.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"OpenGLWindow"</span>);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/OpenGLWindow.PNG" alt="OpenGL_Window"></p>
<p>从上面可以看出我们主要是通过调用glut来初始化创建windows窗口<br>通过glut里的API我们可以去设置回调，去实现我们在渲染时期需要设置的OpenGL状态<br>上述主要有四个重要的glut API：</p>
<ol>
<li>glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA) — GLUT_DOULBE开启了双buffer渲染，这样效率更高，一个buffer用于渲染，一个buffer用于填充下一帧数据</li>
<li>glutDisplayFunc — 设置glut里的渲染回调</li>
<li>glutMainLoop — 开启glut里的window event监听</li>
<li>glutCreateWindow — 设定完相关参数后，通过此方法我们能够创建出我们想要的Windows窗口，同时OpenGL Context也在这时候被创建出来</li>
</ol>
<p>Glut还提供了更多的关于Window的功能，后续会学习使用到</p>
<h3 id="Using_OpenGL">Using OpenGL</h3><p>上一章节只是用到了glut去初始化我们最基本的Window窗口，还没真正大量用到OpenGL里API，在使用OpenGL API之前我们需要通过Glew这个工具去检查当前所支持的OpenGL版本，然后才能正确的调用对应的API。</p>
<p>使用Glew的准备工作在How to use Glu &amp; Glew?时已经提到，这里不重述了</p>
<p>因为Glew需要通过context去查找对应所支持的OpenGL版本调用，所以初始化Glew必须在创建OpenGL Context之后。</p>
<p>Note:<br>Call glewInit after glutCreateWindow call successfully</p>
<p>那这里就不得不先了解一下什么是OpenGL Context了？<br>“”OpenGL Context””<br><a href="https://open.gl/context" target="_blank" rel="external">OpenGL context, which is essentially a state machine that stores all data related to the rendering of your application. When your application closes, the OpenGL context is destroyed and everything is cleaned up.</a></p>
<p>结合wiki<a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a>的介绍，这里我理解的不是很清晰，大概是OpenGL的Context相当于Device Context(DC)相对于Windows的概念一样。Context会设定很多跟渲染相关的状态(比如是否使用双buffer，depthbuffer占多少字节，颜色模式，窗口大小等渲染需要的信息)</p>
<p>这里我们只需要知道初始化Glut和调用glutCreateWindow创建窗口后，我们的OpenGL Context就生成了.</p>
<p>这也就是为什么在初始化glew之前必须先初始化Glut和创建Windows窗口的原因。</p>
<p>进一步了解参考：<br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a></p>
<p>“”Using Glew””<br>接下来回到Glew的使用去绘制我们的第一个OpenGL圆点<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>UsingOpenGL.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_POINTS, <span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">1</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，我们初始化glew只是调用了glewInit()方法，但主要一定要在OpenGL context创建完成后调用(即glutCreateWindow窗口创建之后)</p>
<p>我们创建并使用vertext buffer主要由5个步骤：</p>
<ol>
<li>glGenBuffers() — 创建一个可用的buffer obejct</li>
<li>glBindBuffer() — 绑定buffer object到指定的target类型，target类型代表我们的buffer object包含什么样的数据用于什么样的用途</li>
<li>glBufferData() — 填充buffer数据</li>
<li>glVertexAttribPointer() — 指明如何去解析buffer里的数据，同时这里也指明了如何在shader里面访问这些数据(至于如何编写，编译，链接和使用Shader，后续会讲到。)</li>
<li>glDrawArrays() — 调用draw指明如何使用并绘制buffer里面的数据</li>
</ol>
<p>Note：<br>这里需要注意的一点，要想在Shader里访问buffer里面的attribute数据，我们需要在调用draw之前调用glEnableVertexAttribArray()来激活特定的attribute</p>
<p>final result:<br><img src="/img/OpenGL/UsingOpenGL.PNG" alt="OpenGL_Window"></p>
<h3 id="Using_Shader">Using Shader</h3><p><a href="https://en.wikipedia.org/wiki/Shader" target="_blank" rel="external">In the field of computer graphics, a shader is a computer program that is used to do shading: the production of appropriate levels of color within an image, or, in the modern era, also to produce special effects or do video post-processing.</a></p>
<p>上述是Wiki上Shader的定义。Shader是在可编程管线出现后，以程序的形式对渲染的各个阶段进行图形图像上的处理，使渲染变得更加灵活，主要作用于GPU上。</p>
<p>Shader作用于渲染的各个阶段：<br>之前在“Understand OpenGL render pipeline”有讲到各个渲染管线，这里就不再重述。可见Shader作用于大部分管线，比如：Vertex Shader（负责vertex数据处理），Tessellation Shader（负责以图形patch为单位的处理，用于描述物体形状数据，LOD就是在这个阶段实现的），Geometry Shader（以整个图形原件数据作为输入做处理，好比batch rendering可在这个阶段实现），Fragment Shading（以fragment(片元)数据作为输入做处理）</p>
<p>Shader Language在前面的“Understand OpenGL Shader Language”有讲到，这里就不重述了。</p>
<p>从上可见Shader在可编程管线的今天有着多么重要的作用。<br>接下来让我们看看在OpenGL中如何使用Shader吧。</p>
<p>使用Shader主要有下列几个步骤：</p>
<ol>
<li>Create a shader object – glCreateShader(GLenum type)（创建shader对象）</li>
<li>Compile your shader source into the object – glShaderSource(<strong>**</strong>)  glCompileShader(<em>*</em>)（编译shader文件，存储到shader对象中）</li>
<li>Verify that your shader compiled successfully – glGetShaderInfoLog(<em>*</em>)（检查shader编译是否成功并获取错误信息）</li>
<li>Create a shader program – glCreateProgram(void)（创建shader程序）</li>
<li>Attach the appropriate shader objects to the shader program – glAttachShader(GLuint program, Gluint shader)（附加多个shader对象到shader程序中）</li>
<li>Link the shader program – glLinkProgram(GLuint program)（链接shader程序）</li>
<li>Verify that the shader link phase completed successfully – glGetProgramiv() &amp; glGetProgramInfoLog(<em>**</em>)（检查shader程序链接是否成功并获取错误信息）</li>
<li>Use the shader for vertex or fragment processing – glUseProgram(GLuint program)（使用shader程序做顶点处理或片元处理）</li>
</ol>
<p>Shader出错后因为我们快速退出了程序，所以很难看到console的错误信息，所以最好的方式是把错误信息写入文本文件以供后续查看。Utils.h是关于编译和使用Shader并打印错误信息到文本的实现。<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_util.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>Utils.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serializationShaderCompileLog</span><span class="params">(GLuint prog, GLuint shader, GLenum type, <span class="keyword">char</span> *<span class="built_in">log</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *stage_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">switch</span>(type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_VERTEX_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_GEOMETRY_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_GEOMETRY_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_FRAGMENT_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_FRAGMENT_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"program:"</span>&lt;&lt;prog&lt;&lt;<span class="string">"-shader:"</span>&lt;&lt;shader&lt;&lt;<span class="string">"-stage:"</span>&lt;&lt;stage_name&lt;&lt;<span class="string">" compile log:"</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">log</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *file_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(file_name,stage_name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(file_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(file_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;stage_name;</span><br><span class="line">	write_to_file&lt;&lt;<span class="string">" compiled log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;<span class="built_in">log</span>;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []stage_name;</span><br><span class="line">	<span class="keyword">delete</span> []file_name;</span><br><span class="line"></span><br><span class="line">	stage_name = <span class="literal">nullptr</span>;</span><br><span class="line">	file_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">program_log_serialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> program,<span class="keyword">char</span> <span class="keyword">const</span> *program_name,<span class="keyword">bool</span> is_console_print)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLchar *program_linked_log = <span class="literal">NULL</span>;</span><br><span class="line">	GLint log_length = <span class="number">0</span>;</span><br><span class="line">	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;log_length);</span><br><span class="line">	program_linked_log = <span class="keyword">new</span> <span class="keyword">char</span>[log_length];</span><br><span class="line"></span><br><span class="line">	GLsizei program_linked_log_real_length;</span><br><span class="line">	glGetProgramInfoLog(program, log_length, &amp;program_linked_log_real_length, program_linked_log);</span><br><span class="line">	<span class="keyword">if</span>(is_console_print)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_name&lt;&lt;<span class="string">" linked log info:"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_linked_log&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> file_name_length = <span class="built_in">strlen</span>(program_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *log_file_whole_name = <span class="keyword">new</span> <span class="keyword">char</span>[file_name_length + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(log_file_whole_name,<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(program_name));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(log_file_whole_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(log_file_whole_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;*program_name + <span class="string">" linked log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;program_linked_log;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []program_linked_log;</span><br><span class="line">	<span class="keyword">delete</span> []log_file_whole_name;</span><br><span class="line"></span><br><span class="line">	program_linked_log = <span class="literal">nullptr</span>;</span><br><span class="line">	log_file_whole_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* pshadertext, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLuint shaderobj = glCreateShader(shadertype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(shaderobj == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error create shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> GLchar *p[<span class="number">1</span>];</span><br><span class="line">	p[<span class="number">0</span>] = pshadertext;</span><br><span class="line">	GLint lengths[<span class="number">1</span>];</span><br><span class="line">	lengths[<span class="number">0</span>] = <span class="built_in">strlen</span>(pshadertext);</span><br><span class="line"></span><br><span class="line">	glShaderSource(shaderobj, <span class="number">1</span>, p, lengths);</span><br><span class="line">	glCompileShader(shaderobj);</span><br><span class="line"></span><br><span class="line">	GLint success;</span><br><span class="line">	glGetShaderiv(shaderobj, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		GLchar infolog[<span class="number">1024</span>];</span><br><span class="line">		glGetShaderInfoLog(shaderobj, <span class="number">1024</span>, <span class="literal">NULL</span>, infolog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error compiling shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">		serializationShaderCompileLog(shaderprogram, shaderobj, shadertype, infolog);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glAttachShader(shaderprogram, shaderobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CompileShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* psfilename, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shaderprogram == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error creating shader program"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!ReadFile(psfilename, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;psfilename&lt;&lt;<span class="string">" is not exit"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(shadertype)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_VERTEX_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_GEOMETRY_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_FRAGMENT_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkAndUseShaderProgram</span><span class="params">(GLuint shaderprogram)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLint success = <span class="number">0</span>;</span><br><span class="line">	GLchar errorlog[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	glLinkProgram(shaderprogram);</span><br><span class="line"></span><br><span class="line">	glGetProgramiv(shaderprogram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(success == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error linking shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		program_log_serialization(shaderprogram, <span class="string">"LinkStatus"</span>, <span class="literal">true</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glValidateProgram(shaderprogram);</span><br><span class="line">	glGetProgramiv(shaderprogram, GL_VALIDATE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Invalid shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glUseProgram(shaderprogram);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UsingShader.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Utils.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line">GLuint ShaderProgram;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pVSFileName = <span class="string">"vsshader.vs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pFSFileName = <span class="string">"fsshader.fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">3</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(-<span class="number">1.0f</span>,-<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">1</span>] = Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">2</span>] = Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	ShaderProgram = glCreateProgram();</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pVSFileName, GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pFSFileName, GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">	LinkAndUseShaderProgram(ShaderProgram);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(Position.x,Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final effect:<br><img src="/img/OpenGL/UsingShader.PNG" alt="UsingShader"></p>
<p>上述只使用到了Vertex Shader和Framgment Shader, 后续还会讲到其他Shader的使用。</p>
<h3 id="Uniform_Variables">Uniform Variables</h3><p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are used to communicate with your vertex or fragment shader from “outside”.</a></p>
<p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are read-only and have the same value among all processed vertices. You can only change them within your C++ program.</a></p>
<p>从上面可以看出Uniform变量主要用于Vertex和Fragment Shader,并且对于所有传入的顶点值都不变，只能通过C++一侧去改变Uniform Variable的值。</p>
<p>接下来我们看看Uniform Variable是如何应用在Shader中的：<br>使用Uniform Variable主要有以下几个步骤：</p>
<ol>
<li><p>Obtain uniform variable location after Link Shader Program</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScaleLocation = glGetUniformLocation(ShaderProgram, <span class="string">"gScale"</span>);</span><br><span class="line"></span><br><span class="line">assert(gScaleLocation != <span class="number">0xFFFFFFFF</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set uniform variable value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScale += <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">glUniform1f(gScaleLocation, sinf(gScale));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Define uniform variable in Shader</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final result:<br><img src="/img/OpenGL/UniformVariable.PNG" alt="UniformVariable"></p>
<h3 id="Interpolation">Interpolation</h3><p><a href="http://ogldev.atspace.co.uk/www/tutorial09/tutorial09.html" target="_blank" rel="external">the interpolation that the rasterizer performs on variables that come out of the vertex shader. </a></p>
<p>在OpenGL的渲染管线里，在Fragment Shader执行之前会进行rasterizer，rasterizer会计算出各个三角形顶点之间的像素颜色数据，然后我们可以通过Fragment Shader对于光栅化的后颜色数据做进一步的处理。</p>
<p>这一章节主要看看我们是如何在Vertex Shader和Fragment Shader中如何对顶点数据和各像素信息做处理和数据传递的。(这里我们直接在VS中算出颜色信息直接传递到FS中去做处理)<br>要想从VS传递数据到FS，我们需要在Vertex Shader中定义关键词out的变量，并在Fragment Shader定义对应的关键词in的变量。</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">out vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">	</span><br><span class="line">	Color = <span class="built_in">abs</span>(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/Interpolation.PNG" alt="Interpolation"></p>
<p>从上面可以看出在VS中算出颜色信息后，经过光栅化，三角形顶点之间的颜色信息被计算出来，最终传到FS中并作为最终颜色信息输出到屏幕上。</p>
<h3 id="Coordinate_Transformations_&amp;_Perspective_Projection">Coordinate Transformations &amp; Perspective Projection</h3><p>这一章主要是学习矩阵在3D图形中的使用和了解物体时怎样被显示到正确的屏幕位置的。</p>
<p>在解释如何使用矩阵去进行向量变换之前，我们先来看看为什么矩阵可以实现向量变换？<br>下列学习参考《3D 数学基础：图形与游戏开发》<br>一个3维向量可以解释成3个基向量上平移后的组合(p,q,r为三个基向量)：<br>V = x × p + y × q + z × r;</p>
<p>当一个向量乘以矩阵的时候：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    [ p ]   [px  py  pz]</span><br><span class="line">M = [ q ] = [qx  qy  qz]</span><br><span class="line">    [ r ]   [rx  ry  rz]</span><br><span class="line"></span><br><span class="line">V = [x y z]</span><br><span class="line"></span><br><span class="line">                [px  py  pz]</span><br><span class="line">V * M = [x y z] [qx  qy  qz] = [x*px + y*qx + z*rx   x*py + y*qy + z*ry  x*pz + y*qz + z*rz] = x*p + y*q + z*r</span><br><span class="line">                [rx  ry  rz]</span><br></pre></td></tr></table></figure></p>
<p>“如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”</p>
<p>从上面我们可以看出矩阵是如何做到对于向量的坐标系转换的。</p>
<p>那么为什么我们后面用到的矩阵都是4×4而不是3×3的了？<br>4<em>4的矩阵我们叫做齐次矩阵。齐次矩阵出现的原因主要是除了记法方便，更重要的是因为3</em>3的变换矩阵只能表示线性变换，而4*4齐次矩阵能够表示线性变换和非线性变换。</p>
<p>那么这里我们来了解下什么是线性变换？<br>线性变换的满足下列公式：<br>F(a+b) = F(a) + F(b)<br>F(ka) = k × F(a)</p>
<p>因为线性变换不包含平移，所以这也是4×4齐次矩阵的出现的原因。</p>
<p>了解了使用矩阵的原因和为什么使用4×4齐次矩阵的原因后，让我们来看看，我们是如何通过矩阵来实现3D图形里的实现物体的坐标系变换的。<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)</p>
<p>因为矩阵乘法满足结合律<br>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × (M(m-w) × M(w-v) × M(v-p)) = V * N<br>所以我们只需要求出所有坐标系变换矩阵的乘积后再对V进行操作即可。</p>
<p>因为单个矩阵存储着一系列的变换，而这些变换可以通过多个单个变换组合而成，所以下列式子是成立的<br>M = S(scale) × R(rotation) × T(translation)</p>
<p>但这里有个比较关键的点，S,R,T直接的乘法顺序，矩阵是不满足交换律的，我们必须按S <em> R </em> T的顺序，原因参考下面：<br><a href="https://msdn.microsoft.com/en-us/library/eews39w7%28v=vs.110%29.aspx" target="_blank" rel="external">One reason order is significant is that transformations like rotation and scaling are done with respect to the origin of the coordinate system. Scaling an object that is centered at the origin produces a different result than scaling an object that has been moved away from the origin. Similarly, rotating an object that is centered at the origin produces a different result than rotating an object that has been moved away from the origin.</a></p>
<p>从上面可以看出，之所必须按S <em> R </em> T的顺序是因为S和R都是针对坐标系原点进行的，一旦先执行T，那么相对于坐标系原点的位置就会有所变化，这之后再做S和R就会出现不一样的表现。</p>
<p>因为OpenGL是列向量是左乘，所以在OpenGL中顺序如下：<br>V’ = T × R × S × V</p>
<p>DX中顺序如下：<br>V’ = V × S × R × T</p>
<p>获取最终的M(m-w)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetWorldTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f ScaleTrans, RotateTrans, TranslationTrans;</span><br><span class="line"></span><br><span class="line">    ScaleTrans.InitScaleTransform(m_scale.x, m_scale.y, m_scale.z);</span><br><span class="line">    RotateTrans.InitRotateTransform(m_rotateInfo.x, m_rotateInfo.y, m_rotateInfo.z);</span><br><span class="line">    TranslationTrans.InitTranslationTransform(m_worldPos.x, m_worldPos.y, m_worldPos.z);</span><br><span class="line"></span><br><span class="line">    m_Wtransformation = TranslationTrans * RotateTrans * ScaleTrans;</span><br><span class="line">    <span class="keyword">return</span> m_Wtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)<br>我们知道了M(m-w)是如何计算出来的了，接下来我们要了解M(w-v) — 世界坐标系到观察坐标系<br>在了解如何从世界坐标系转换到观察坐标系之前我们先来看看摄像机的定义：<br>位置 — (x,y,z)<br>N — The vector from the camera to its target.（look at 朝向）<br>V — When standing upright this is the vector from your head to the sky.(垂直于N向上的向量)<br>U — This vector points from the camera to its “right” side”.(在N和V定了之后可以算出Camera的向右的向量)</p>
<p>摄像机坐标系和世界坐标系：<br><img src="/img/OpenGL/CameraCoordinateTranslation.PNG" alt="CameraCoordinateTranslation"></p>
<p>要想得到物体从世界坐标系转换到摄像机坐标系，其实就是个坐标系转换的问题。<br>我们首先把摄像机移动到世界坐标原点(移动摄像机位置即可)：<br>[ 1 0 0 -x ]<br>[ 0 1 0 -y ]<br>[ 0 0 1 -z ]<br>[ 0 0 0  1 ]</p>
<p>这样一来考虑如何变化坐标系即可：<br><img src="/img/OpenGL/CameraCoordinate2.PNG" alt="CameraCoordinate2"><br>通过N,V,U，我们已经能够得出X(camera),Y(camera),Z(camera)3个基向量了。<br>还记得我们之前说的 — “如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”<br>所以：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ Ux Uy Uz <span class="number">0</span> ]    [X(world)]    [X(camera)]</span><br><span class="line">[ Vx Vy Vz <span class="number">0</span> ]    [Y(world)]    [Y(camera)]</span><br><span class="line">[ Nx Ny Nz <span class="number">0</span> ] *  [Z(world)] =  [Z(camera)]</span><br><span class="line">[ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]    [    <span class="number">1</span>   ]    [     <span class="number">1</span>   ]</span><br></pre></td></tr></table></figure></p>
<p>结合前面提到的先把摄像机移动到世界原点，得出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         [ Ux Uy Uz <span class="number">0</span> ]   [ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> -x ]</span><br><span class="line">M(w-v) = [ Vx Vy Vz <span class="number">0</span> ] * [ <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> -y ]</span><br><span class="line">         [ Nx Ny Nz <span class="number">0</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> -z ]</span><br><span class="line">         [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span> ]</span><br></pre></td></tr></table></figure></p>
<p>M(w-v)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitTranslationTransform(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">&#123;</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>; m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">3</span>] = x;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">3</span>] = y;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>; m[<span class="number">2</span>][<span class="number">3</span>] = z;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4f::InitCameraTransform(<span class="keyword">const</span> Vector3f&amp; Target, <span class="keyword">const</span> Vector3f&amp; Up)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f N = Target;</span><br><span class="line">    N.Normalize();</span><br><span class="line">    Vector3f U = Up;</span><br><span class="line">    U.Normalize();</span><br><span class="line">    U = U.Cross(N);</span><br><span class="line">    Vector3f V = N.Cross(U);</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = U.x;   m[<span class="number">0</span>][<span class="number">1</span>] = U.y;   m[<span class="number">0</span>][<span class="number">2</span>] = U.z;   m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = V.x;   m[<span class="number">1</span>][<span class="number">1</span>] = V.y;   m[<span class="number">1</span>][<span class="number">2</span>] = V.z;   m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = N.x;   m[<span class="number">2</span>][<span class="number">1</span>] = N.y;   m[<span class="number">2</span>][<span class="number">2</span>] = N.z;   m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetViewTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f CameraTranslationTrans, CameraRotateTrans;</span><br><span class="line"></span><br><span class="line">    CameraTranslationTrans.InitTranslationTransform(-m_camera.Pos.x, -m_camera.Pos.y, -m_camera.Pos.z);</span><br><span class="line">    CameraRotateTrans.InitCameraTransform(m_camera.Target, m_camera.Up);</span><br><span class="line">    </span><br><span class="line">    m_Vtransformation = CameraRotateTrans * CameraTranslationTrans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Vtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来M(w-v)也就实现了，接下来让我们看看M(v-p)是如何计算出来的吧。<br>M(v-p)这的p有多种投影方式，这里我只以Perspective Projection为例。<br>在转换到Camera坐标系后，我们还需要通过透视投影才能将3D物体映射到2D平面上。<br>Perspective Projection主要由下列四部分决定：</p>
<ol>
<li>The aspect ratio - the ratio between the width and the height of the rectangular area which will be the target of projection.</li>
<li>The vertical field of view.</li>
<li>The location of the near Z plane.</li>
<li>The location of the far Z plane.</li>
</ol>
<p>这一章的推导可以参考<a href="http://www.cnblogs.com/graphics/archive/2012/07/25/2582119.html" target="_blank" rel="external">透视投影详解</a><br>一开始推导过程中不明白的一点是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           1</span><br><span class="line">Z'' = a * --- + b</span><br><span class="line">           Pz</span><br></pre></td></tr></table></figure></p>
<p>后来看了《Mathematics for 3D Game Programming and Computer Grahpics 3rd section》的5.4.1 Depth Interpolation后明白了，光栅化的时候对于深度的运算证明了是对Z的倒数进行插值来得到Z的值的。<br>所以上述公式是成立的。</p>
<p>经过一系列推导后，我们得出了：<br><img src="/img/OpenGL/PerspectiveProject1.PNG" alt="PerspectiveProject1"><br><img src="/img/OpenGL/PerspectiveProject2.PNG" alt="PerspectiveProject2"><br><img src="/img/OpenGL/PerspectiveProject3.PNG" alt="PerspectiveProject3"><br><img src="/img/OpenGL/PerspectiveProject4.PNG" alt="PerspectiveProject4"></p>
<p>M(v-p)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitPersProjTransform(<span class="keyword">const</span> PersProjInfo&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ar         = p.Width / p.Height;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> zRange     = p.zNear - p.zFar;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFOV = tanf(ToRadian(p.FOV / <span class="number">2.0f</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>/(tanHalfFOV * ar); m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>/tanHalfFOV; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">2</span>][<span class="number">2</span>] = (-p.zNear - p.zFar)/zRange ; m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2.0f</span>*p.zFar*p.zNear/zRange;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;            m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0.0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Reference_Website:">Reference Website:</h1><p><a href="http://www.opengl.org/sdk/docs/man4/" target="_blank" rel="external">OpenGL 4 reference page</a><br><a href="http://blog.csdn.net/guolihui112/article/details/5702915" target="_blank" rel="external">client-server 模式</a><br><a href="http://www.glprogramming.com/blue/ch01.html" target="_blank" rel="external">OpenGL Execute Model</a><br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a><br><a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">OpenGL Tutorial</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGL Windows &amp; Context</a><br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a><br><a href="https://www.opengl.org/wiki/OpenGL_Context" target="_blank" rel="external">OpenGL Context</a><br><a href="https://open.gl/context" target="_blank" rel="external">Window and OpenGL context</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGLBook.com Getting Started</a></p>
<p>Note:<br><strong>OpenGL uses right-handed coordinate system (OpenGL使用右手坐标系)</strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Rendering/">Rendering</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OpenGL/">OpenGL</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/" data-title="OpenGL_Study | 走停人生路" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/29/Computer-Graphic-Study/" title="Computer_Graphic_Study">
  <strong>上一篇：</strong><br/>
  <span>
  Computer_Graphic_Study</span>
</a>
</div>


<div class="next">
<a href="/2015/08/15/CSharp-Study/"  title="C# Study">
 <strong>下一篇：</strong><br/> 
 <span>C# Study
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/26/OpenGL-Study/" data-title="OpenGL_Study" data-url="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game-Engine/" title="Game_Engine">Game_Engine<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sort/" title="Sort">Sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Tony Tang. <br/>
			This is my new blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"TonyTang1990"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
