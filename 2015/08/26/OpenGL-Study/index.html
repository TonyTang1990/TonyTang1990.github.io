
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>OpenGL_Study | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL_Study">
<meta property="og:url" content="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGL_Render_Pipeline.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GLViewer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGLWindow.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingOpenGL.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingShader.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UniformVariable.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Interpolation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinateTranslation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinate2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject1.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject3.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject4.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MouseAndKeyboardStudy.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TextureConcepts.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TextureCoordinate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/BasicTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/texture1.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/texture2.jpg">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MultipleTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Ambient.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Diffuse.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularModle.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularModle2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularCalculation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PointLightFormulation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpotLight.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpotLightCutoffMapping.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShaowMapFirstPass.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShaowMapFirstPassCreate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MyTextureList.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DemoTextureList.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShadowMapFirstPassSuccessful.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShadowMapFinal.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Open3mod.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/gDEBuggerCapture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/gDEBuggerShaderInfo.PNG">
<meta property="og:updated_time" content="2016-06-29T13:36:23.919Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenGL_Study">
<meta name="twitter:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">有时候不是习惯了一个人，而是在没有认可自己之前选择了一个人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/26/OpenGL-Study/" title="OpenGL_Study" itemprop="url">OpenGL_Study</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2015-08-26T15:57:05.000Z" itemprop="datePublished"> 發表於 2015-08-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard_&&_Mouse_Control"><span class="toc-number">1.4.9.</span> <span class="toc-text">Keyboard && Mouse Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture_Mapping"><span class="toc-number">1.4.10.</span> <span class="toc-text">Texture Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light_and_Shadow"><span class="toc-number">1.4.11.</span> <span class="toc-text">Light and Shadow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Utility"><span class="toc-number">1.5.</span> <span class="toc-text">OpenGL Utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_Asset_Import_Library"><span class="toc-number">1.5.1.</span> <span class="toc-text">Open Asset Import Library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assimp"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">assimp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open3mod"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">open3mod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL_Debuger"><span class="toc-number">1.5.2.</span> <span class="toc-text">GLSL Debuger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nsight"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">Nsight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_proiler,_debugger"><span class="toc-number">1.5.3.</span> <span class="toc-text">OpenGL proiler, debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gDEBugger"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">gDEBugger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
		
		</div>
		
		<p><strong>时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好</strong>  — 游戏梦</p>
<p>参考书籍：<br>《OpenGL Programming Guide 8th Edition》 — Addison Wesley<br>《Fundamentals of Computer Graphics (3rd Edition)》 — Peter Shirley, Steve Marschnner<br>《Real-Time Rendering, Third Edition》 — Tomas Akenine-Moller, Eric Haines, Naty Hoffman</p>
<p><a href="http://blog.sina.com.cn/tonytang1990" target="_blank" rel="external">旧博客地址</a></p>
<p><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/">渲染相关概念学习</a></p>
<h1 id="OpenGL">OpenGL</h1><h2 id="Introdction_to_OpenGL">Introdction to OpenGL</h2><h3 id="What_is_OpenGL?">What is OpenGL?</h3><ol>
<li>OpenGL is an application programming interface – “API” for short – which is merely a software library for accessing features in graphics hardware.(访问图形硬件设备功能的API)</li>
<li>OpenGL is a “C” language library(OpenGL是一个C语言库)</li>
</ol>
<h3 id="History">History</h3><p>It was first developed at Silicon Graphics Computer Systems with Version 1,0 released in July of 1994(<a href="https://zh.wikipedia.org/zh/OpenGL" target="_blank" rel="external">wiki</a>)</p>
<h3 id="Next_Generation_OpenGL">Next Generation OpenGL</h3><p><a href="https://en.wikipedia.org/wiki/Vulkan_%28API%29" target="_blank" rel="external">Vulkan</a></p>
<h2 id="OpenGL_relative_knowledge">OpenGL relative knowledge</h2><ol>
<li><p>Understand OpenGL render pipeline<br><img src="/img/OpenGL/OpenGL_Render_Pipeline.PNG" alt="OpenGL Render Pipeline"></p>
<ol>
<li><p>Vertex Data<br> Sending Data to OpenGL</p>
</li>
<li><p>Vertex Shader<br> Process the data associated with that vertex</p>
</li>
<li><p>Tessellation Shader<br> Tessellation uses patchs to describe an object’s shape, and allows relatively simple collections of patch geometry to be tessellated to increase the number of geometric primitives providing better-looking models (eg: LOD) </p>
</li>
<li><p>Geometry Shader<br> Allows additional processing of individual geometric primitives, including creating new ones, before rasterization</p>
</li>
<li><p>Primitive Assembly<br>Organizes the vertices into their associated geometric primitives in preparation for clipping and rasterization </p>
</li>
<li><p>Clipping<br> Clip the vertex and pixels are outside of the viewport – this operation is handled automatically by OpenGL</p>
</li>
<li><p>Rasterization<br> Fragment generation. Pixels have a home in the framebuffer, while a fragment still can be rejected and never update its associated pixel location. </p>
</li>
<li><p>Fragment Shading<br> Use a fragment shading to determine the fragment’s final color, and potentially its depth value</p>
</li>
<li><p>Per-Fragment Operations<br> If a fragment successfully makes it through all of the enabled tests (eg: depth testing, stencil testing), it may be written directly to the framebuffer, updating the color of its pixel, or if blending is enabled, the fragment’s color will be combined with the pixel’s current color to generate a new color that is written into the framebuffer</p>
</li>
</ol>
<p>Note:<br>Fragment’s visibility is determined using depth testing and stencil testing<br>Pixel data is usually stored in texture map for use with texture mapping, which allows any texture stage to look up data values from one or more texture maps.</p>
</li>
<li><p><a href="http://zh.wikipedia.org/wiki/GLSL" target="_blank" rel="external">Understand OpenGL Shader Language (GLSL)</a><br> GLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。</p>
<p> 编译和执行<br> GLSL 着色器不是独立的应用程式；其需要使用 OpenGL API 的应用程式。C、C++、C#、Delphi 和 Java 皆支援 OpenGL API，且支援 OpenGL 着色语言。<br> GLSL 着色器本身只是简单的字串集，这些字串集会传送到硬件厂商的驱动程式，并从程式内部的 OpenGL API 进入点编译。着色器可从程式内部或读入纯文字档来即时建立，但必须以字串形式传送到驱动程式。</p>
<p> 工具<br> GLSL 着色器可以事先建立和测试，现有以下 GLSL 开发工具：<br> RenderMonkey - 这个软件是由 ATI 制作的，提供界面用以建立、编译和除错 GLSL 着色器，和 DirectX 着色器一样。仅能在 Windows 平台上执行。<br> GLSLEditorSample - 在 Mac OS X 上，它是目前唯一可用的程式，其提供着色器的建立和编译，但不能除错。它是 cocoa 应用程式，仅能在 Mac OS X 上执行。<br> Lumina - Lumina 是新的 GLSL 开发工具。其使用 QT 界面，可以跨平台。</p>
</li>
<li><p>OpenGL Shader Fundamentals</p>
</li>
<li><p>The color space that is used by OpenGL<br> In OpenGL, colors are represented in what’s called the RGB color space</p>
</li>
</ol>
<h2 id="OpenGL_learning_journal">OpenGL learning journal</h2><h3 id="API">API</h3><ol>
<li>查看哪些错误标志位被设置<br>了解：<br>  OpenGL在内部保留了一组错误标志位(共4个),其中每一个标志位代表一种不同类型的错误。当错误一个发生时，与这个错误对应的标志就会被设置。如果被设置的标志不止一个，glGetError仍然只返回一个唯一的值。当glGetError函数被调用时，这个值随后被清除，然后在glGetError再次被调用时将返回一个错误标志或GL_NO_ERROR为止</li>
</ol>
<p>函数：<br>Glenum glGetError(void); </p>
<ol>
<li><p>查询OpenGL的渲染引擎（OpenGL驱动程序）的生产商和版本号<br>了解：<br> OpenGL允许提供商通过它的扩展机制进行创新。为了使用特定供应商所提供的一些特定扩展功能，我们希望限制这个特定供应商所提供驱动程序的最低版本号。<br>函数：<br>const Glubyte *glGetString(GLenum name);</p>
</li>
<li><p>设置和查询管线的状态<br>了解：<br>  OpenGL使用状态模型来跟踪所有的OpenGL状态变量来实现对OpenGL渲染状态的控制<br>函数：<br>void glEnable(GLenum capability);<br>void glDisable(GLenum capability);<br>void glGet<em>(Type)v(GLenum pname, GLboolean </em>params);</p>
</li>
<li><p>查询program的一些相关信息和一些错误信息<br>了解：<br> OpenGL的pragram链接可能由于GLSL里面的一些错误导致出错，我们需要知道关于program object的一些相关错误信息，同时我们也想知道我们现有的program相关的一些信息<br>函数：<br>void glGetProgramiv(GLuint program, GLenum pname, GLint *params);</p>
</li>
<li><p>得到shader链接出错的log信息<br>了解：<br> OpenGL的shader object可能链接失败，我们需要知道shader里面出错的信息<br>函数：<br>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei <em>length, GLchar </em>infoLog);</p>
</li>
</ol>
<p>注意:<br>可以通过glGetProgramiv()去得到program的一些log相关信息，比如GL_INFO_LOG_LENGTH</p>
<h3 id="OpenGL_Knowledge:">OpenGL Knowledge:</h3><pre><code>1. "OpenGL <span class="operator"><span class="keyword">Execute</span> Model: 
    The model <span class="keyword">for</span> interpretation <span class="keyword">of</span> OpenGL commands <span class="keyword">is</span> client-<span class="keyword">server</span>. An application (the client) issues commands, which <span class="keyword">are</span> interpreted <span class="keyword">and</span> processed <span class="keyword">by</span> OpenGL (the <span class="keyword">server</span>). The <span class="keyword">server</span> may <span class="keyword">or</span> may <span class="keyword">not</span> operate <span class="keyword">on</span> the same computer <span class="keyword">as</span> the client. <span class="keyword">In</span> this sense, OpenGL <span class="keyword">is</span> network-transparent. <span class="string">"

2. "</span>client-<span class="keyword">server</span> 模式:
    OpenGL 是一种 client-<span class="keyword">server</span> 模式，当你的应用程序调用 OpenGL 函数时， 它将告诉OpenGL client， 然后 client 将渲染命令传送给 <span class="keyword">server</span>. 这里client 和 <span class="keyword">server</span>可能是不同的计算机，或是同一台计算机上的不同进程。一般来说 <span class="keyword">server</span> 是在 GPU上处理的， 而 client 是在 CPU 上处理的，这样分担了 CPU 的负担， 同时高效利用了GPU.<span class="string">"</span></span>
</code></pre><p>但如果Client和Server没在同一个机器上，我们就需要一种一种网络传输协议框架来实现他们之间的交流：<br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a></p>
<p>但X Window System里的client和server与传统的C/S模式相反，client是负责运算的，server是负责显示的。<br>但OpenGL的client和server的交流原理是与X Window System相似的</p>
<h2 id="OpenGL_Practice">OpenGL Practice</h2><h3 id="Check_supported_OpenGL_version">Check supported OpenGL version</h3><ol>
<li>Install the appropriate graphic driver which enables usage of the functionality provided.<br> check the graphic drive update.(更新显卡驱动获得最新的OpenGL版本支持)</li>
<li>Using OpenGL extensions viewer to check which OpenGL version is supported(查看当前硬件所支持的OpenGL版本)<br> <a href="http://www.realtech-vr.com/glview/download.php" target="_blank" rel="external">download website</a></li>
</ol>
<p><img src="/img/OpenGL/GLViewer.PNG" alt="OpenGL_Viewer_Info"><br>从上图可以看出我当前的电脑和显卡驱动支持最高4.4，所以在使用学习OpenGL之前一定要确认好自己电脑所能支持的版本，避免后续不必要的问题。</p>
<p>检查完所支持的OpenGL版本后，下面我们需要介绍两个在学习OpenGL时为了帮助快速学习使用OpenGL的两个重要库（Glut &amp; Glew）</p>
<h3 id="Know_what_Glut_and_Glew_are,_and_how_to_use_them">Know what Glut and Glew are, and how to use them</h3><ol>
<li><p><a href="http://zh.wikipedia.org/wiki/GLUT" target="_blank" rel="external">Glut (OpenGL Utility Toolkit)</a><br> GLUT（英文全写：OpenGL Utility Toolkit）是一个处理OpenGL程式的工具库，负责处理和底层操作系统的呼叫以及I/O，并包括了以下常见的功能：</p>
<ol>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘及鼠标的事件</li>
<li>以一个函数呼叫绘制某些常用的立体图形，例如长方体、球、以及犹他茶壶（实心或只有骨架，如glutWireTeapot()）</li>
<li><p>提供了简单选单列的实现</p>
<p>GLUT是由Mark J. Kilgard在Silicon Graphics工作时所写，此人同时也是OpenGL Programming for the X Window System以及The Cg Tutorial: The Definitive Guide to Programmable Real-Time Graphics两书的作者。</p>
<p>GLUT的两个主要目的是建立一个跨平台的函式库（事实上GLUT就是跨平台的），以及简化学习OpenGL的条件。透过GLUT编写OpenGL通常只需要增加几行额外GLUT的程式码，而且不需要知道每个不同操作系统处理视窗的API。</p>
<p>所有的GLUT函数都以glut作为开头，例如glutPostRedisplay()。</p>
</li>
</ol>
</li>
<li><a href="http://en.wikipedia.org/wiki/OpenGL_Extension_Wrangler_Library" target="_blank" rel="external">Glew ( OpenGL Extension Wrangler Library)</a><br> The OpenGL Extension Wrangler Library (GLEW) is a cross-platform C/C++ library that helps in querying and loading OpenGL extensions. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.(Glew是一个支持跨平台的C/C++库，用于运行时鉴别OpenGL扩展所支持的版本)<br> <a href="http://www.opengl.org/sdk/tools/" target="_blank" rel="external">more info for extention tools</a></li>
</ol>
<p>How to use Glu &amp; Glew?</p>
<ol>
<li>add glu.lib &amp; glew.lib into additional dependencies</li>
<li>add the directory that includes glu.h &amp; glew.h into include dirctory</li>
<li>Include GL/freeglut.h &amp; GL/glew.h in source file<br>Note:<br>if you use static link, #define FREEGLUT_STATIC before you include GL/freeglut.h, otherwise it will look for freeglut.lib. #define GLEW_STATIC for Glew.</li>
</ol>
<p>include GL/glew.h before GL/freeglut.h, otherwise, it will through “fatal error C1189: #error :  gl.h included before glew.h”</p>
<p>Note:<br>后续的学习都是基于<a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">Modern OpenGL Tutorials</a>,后续提到的一些库的源码从该网站下载</p>
<h3 id="Open_a_Window">Open a Window</h3><p>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>OpenGLWindow.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"OpenGLWindow"</span>);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/OpenGLWindow.PNG" alt="OpenGL_Window"></p>
<p>从上面可以看出我们主要是通过调用glut来初始化创建windows窗口<br>通过glut里的API我们可以去设置回调，去实现我们在渲染时期需要设置的OpenGL状态<br>上述主要有四个重要的glut API：</p>
<ol>
<li>glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA) — GLUT_DOULBE开启了双buffer渲染，这样效率更高，一个buffer用于渲染，一个buffer用于填充下一帧数据</li>
<li>glutDisplayFunc — 设置glut里的渲染回调</li>
<li>glutMainLoop — 开启glut里的window event监听</li>
<li>glutCreateWindow — 设定完相关参数后，通过此方法我们能够创建出我们想要的Windows窗口，同时OpenGL Context也在这时候被创建出来</li>
</ol>
<p>Glut还提供了更多的关于Window的功能，后续会学习使用到</p>
<h3 id="Using_OpenGL">Using OpenGL</h3><p>上一章节只是用到了glut去初始化我们最基本的Window窗口，还没真正大量用到OpenGL里API，在使用OpenGL API之前我们需要通过Glew这个工具去检查当前所支持的OpenGL版本，然后才能正确的调用对应的API。</p>
<p>使用Glew的准备工作在How to use Glu &amp; Glew?时已经提到，这里不重述了</p>
<p>因为Glew需要通过context去查找对应所支持的OpenGL版本调用，所以初始化Glew必须在创建OpenGL Context之后。</p>
<p>Note:<br>Call glewInit after glutCreateWindow call successfully</p>
<p>那这里就不得不先了解一下什么是OpenGL Context了？<br>“”OpenGL Context””<br><a href="https://open.gl/context" target="_blank" rel="external">OpenGL context, which is essentially a state machine that stores all data related to the rendering of your application. When your application closes, the OpenGL context is destroyed and everything is cleaned up.</a></p>
<p>结合wiki<a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a>的介绍，这里我理解的不是很清晰，大概是OpenGL的Context相当于Device Context(DC)相对于Windows的概念一样。Context会设定很多跟渲染相关的状态(比如是否使用双buffer，depthbuffer占多少字节，颜色模式，窗口大小等渲染需要的信息)</p>
<p>这里我们只需要知道初始化Glut和调用glutCreateWindow创建窗口后，我们的OpenGL Context就生成了.</p>
<p>这也就是为什么在初始化glew之前必须先初始化Glut和创建Windows窗口的原因。</p>
<p>进一步了解参考：<br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a></p>
<p>“”Using Glew””<br>接下来回到Glew的使用去绘制我们的第一个OpenGL圆点<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>UsingOpenGL.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_POINTS, <span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">1</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，我们初始化glew只是调用了glewInit()方法，但主要一定要在OpenGL context创建完成后调用(即glutCreateWindow窗口创建之后)</p>
<p>我们创建并使用vertext buffer主要由5个步骤：</p>
<ol>
<li>glGenBuffers() — 创建一个可用的buffer obejct</li>
<li>glBindBuffer() — 绑定buffer object到指定的target类型，target类型代表我们的buffer object包含什么样的数据用于什么样的用途</li>
<li>glBufferData() — 填充buffer数据</li>
<li>glVertexAttribPointer() — 指明如何去解析buffer里的数据，同时这里也指明了如何在shader里面访问这些数据(至于如何编写，编译，链接和使用Shader，后续会讲到。)</li>
<li>glDrawArrays() — 调用draw指明如何使用并绘制buffer里面的数据</li>
</ol>
<p>Note：<br>这里需要注意的一点，要想在Shader里访问buffer里面的attribute数据，我们需要在调用draw之前调用glEnableVertexAttribArray()来激活特定的attribute</p>
<p>final result:<br><img src="/img/OpenGL/UsingOpenGL.PNG" alt="OpenGL_Window"></p>
<h3 id="Using_Shader">Using Shader</h3><p><a href="https://en.wikipedia.org/wiki/Shader" target="_blank" rel="external">In the field of computer graphics, a shader is a computer program that is used to do shading: the production of appropriate levels of color within an image, or, in the modern era, also to produce special effects or do video post-processing.</a></p>
<p>上述是Wiki上Shader的定义。Shader是在可编程管线出现后，以程序的形式对渲染的各个阶段进行图形图像上的处理，使渲染变得更加灵活，主要作用于GPU上。</p>
<p>Shader作用于渲染的各个阶段：<br>之前在“Understand OpenGL render pipeline”有讲到各个渲染管线，这里就不再重述。可见Shader作用于大部分管线，比如：Vertex Shader（负责vertex数据处理），Tessellation Shader（负责以图形patch为单位的处理，用于描述物体形状数据，LOD就是在这个阶段实现的），Geometry Shader（以整个图形原件数据作为输入做处理，好比batch rendering可在这个阶段实现），Fragment Shading（以fragment(片元)数据作为输入做处理）</p>
<p>Shader Language在前面的“Understand OpenGL Shader Language”有讲到，这里就不重述了。</p>
<p>从上可见Shader在可编程管线的今天有着多么重要的作用。<br>接下来让我们看看在OpenGL中如何使用Shader吧。</p>
<p>使用Shader主要有下列几个步骤：</p>
<ol>
<li>Create a shader object – glCreateShader(GLenum type)（创建shader对象）</li>
<li>Compile your shader source into the object – glShaderSource(<strong>**</strong>)  glCompileShader(<em>*</em>)（编译shader文件，存储到shader对象中）</li>
<li>Verify that your shader compiled successfully – glGetShaderInfoLog(<em>*</em>)（检查shader编译是否成功并获取错误信息）</li>
<li>Create a shader program – glCreateProgram(void)（创建shader程序）</li>
<li>Attach the appropriate shader objects to the shader program – glAttachShader(GLuint program, Gluint shader)（附加多个shader对象到shader程序中）</li>
<li>Link the shader program – glLinkProgram(GLuint program)（链接shader程序）</li>
<li>Verify that the shader link phase completed successfully – glGetProgramiv() &amp; glGetProgramInfoLog(<em>**</em>)（检查shader程序链接是否成功并获取错误信息）</li>
<li>Use the shader for vertex or fragment processing – glUseProgram(GLuint program)（使用shader程序做顶点处理或片元处理）</li>
</ol>
<p>Shader出错后因为我们快速退出了程序，所以很难看到console的错误信息，所以最好的方式是把错误信息写入文本文件以供后续查看。Utils.h是关于编译和使用Shader并打印错误信息到文本的实现。<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_util.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>Utils.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serializationShaderCompileLog</span><span class="params">(GLuint prog, GLuint shader, GLenum type, <span class="keyword">char</span> *<span class="built_in">log</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *stage_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">switch</span>(type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_VERTEX_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_GEOMETRY_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_GEOMETRY_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_FRAGMENT_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_FRAGMENT_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"program:"</span>&lt;&lt;prog&lt;&lt;<span class="string">"-shader:"</span>&lt;&lt;shader&lt;&lt;<span class="string">"-stage:"</span>&lt;&lt;stage_name&lt;&lt;<span class="string">" compile log:"</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">log</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *file_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(file_name,stage_name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(file_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(file_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;stage_name;</span><br><span class="line">	write_to_file&lt;&lt;<span class="string">" compiled log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;<span class="built_in">log</span>;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []stage_name;</span><br><span class="line">	<span class="keyword">delete</span> []file_name;</span><br><span class="line"></span><br><span class="line">	stage_name = <span class="literal">nullptr</span>;</span><br><span class="line">	file_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">program_log_serialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> program,<span class="keyword">char</span> <span class="keyword">const</span> *program_name,<span class="keyword">bool</span> is_console_print)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLchar *program_linked_log = <span class="literal">NULL</span>;</span><br><span class="line">	GLint log_length = <span class="number">0</span>;</span><br><span class="line">	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;log_length);</span><br><span class="line">	program_linked_log = <span class="keyword">new</span> <span class="keyword">char</span>[log_length];</span><br><span class="line"></span><br><span class="line">	GLsizei program_linked_log_real_length;</span><br><span class="line">	glGetProgramInfoLog(program, log_length, &amp;program_linked_log_real_length, program_linked_log);</span><br><span class="line">	<span class="keyword">if</span>(is_console_print)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_name&lt;&lt;<span class="string">" linked log info:"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_linked_log&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> file_name_length = <span class="built_in">strlen</span>(program_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *log_file_whole_name = <span class="keyword">new</span> <span class="keyword">char</span>[file_name_length + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(log_file_whole_name,<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(program_name));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(log_file_whole_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(log_file_whole_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;*program_name + <span class="string">" linked log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;program_linked_log;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []program_linked_log;</span><br><span class="line">	<span class="keyword">delete</span> []log_file_whole_name;</span><br><span class="line"></span><br><span class="line">	program_linked_log = <span class="literal">nullptr</span>;</span><br><span class="line">	log_file_whole_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* pshadertext, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLuint shaderobj = glCreateShader(shadertype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(shaderobj == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error create shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> GLchar *p[<span class="number">1</span>];</span><br><span class="line">	p[<span class="number">0</span>] = pshadertext;</span><br><span class="line">	GLint lengths[<span class="number">1</span>];</span><br><span class="line">	lengths[<span class="number">0</span>] = <span class="built_in">strlen</span>(pshadertext);</span><br><span class="line"></span><br><span class="line">	glShaderSource(shaderobj, <span class="number">1</span>, p, lengths);</span><br><span class="line">	glCompileShader(shaderobj);</span><br><span class="line"></span><br><span class="line">	GLint success;</span><br><span class="line">	glGetShaderiv(shaderobj, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		GLchar infolog[<span class="number">1024</span>];</span><br><span class="line">		glGetShaderInfoLog(shaderobj, <span class="number">1024</span>, <span class="literal">NULL</span>, infolog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error compiling shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">		serializationShaderCompileLog(shaderprogram, shaderobj, shadertype, infolog);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glAttachShader(shaderprogram, shaderobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CompileShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* psfilename, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shaderprogram == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error creating shader program"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!ReadFile(psfilename, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;psfilename&lt;&lt;<span class="string">" is not exit"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(shadertype)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_VERTEX_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_GEOMETRY_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_FRAGMENT_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkAndUseShaderProgram</span><span class="params">(GLuint shaderprogram)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLint success = <span class="number">0</span>;</span><br><span class="line">	GLchar errorlog[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	glLinkProgram(shaderprogram);</span><br><span class="line"></span><br><span class="line">	glGetProgramiv(shaderprogram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(success == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error linking shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		program_log_serialization(shaderprogram, <span class="string">"LinkStatus"</span>, <span class="literal">true</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glValidateProgram(shaderprogram);</span><br><span class="line">	glGetProgramiv(shaderprogram, GL_VALIDATE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Invalid shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glUseProgram(shaderprogram);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UsingShader.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Utils.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line">GLuint ShaderProgram;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pVSFileName = <span class="string">"vsshader.vs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pFSFileName = <span class="string">"fsshader.fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">3</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(-<span class="number">1.0f</span>,-<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">1</span>] = Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">2</span>] = Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	ShaderProgram = glCreateProgram();</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pVSFileName, GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pFSFileName, GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">	LinkAndUseShaderProgram(ShaderProgram);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(Position.x,Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final effect:<br><img src="/img/OpenGL/UsingShader.PNG" alt="UsingShader"></p>
<p>上述只使用到了Vertex Shader和Framgment Shader, 后续还会讲到其他Shader的使用。</p>
<h3 id="Uniform_Variables">Uniform Variables</h3><p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are used to communicate with your vertex or fragment shader from “outside”.</a></p>
<p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are read-only and have the same value among all processed vertices. You can only change them within your C++ program.</a></p>
<p>从上面可以看出Uniform变量主要用于Vertex和Fragment Shader,并且对于所有传入的顶点值都不变，只能通过C++一侧去改变Uniform Variable的值。</p>
<p>接下来我们看看Uniform Variable是如何应用在Shader中的：<br>使用Uniform Variable主要有以下几个步骤：</p>
<ol>
<li><p>Obtain uniform variable location after Link Shader Program</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScaleLocation = glGetUniformLocation(ShaderProgram, <span class="string">"gScale"</span>);</span><br><span class="line"></span><br><span class="line">assert(gScaleLocation != <span class="number">0xFFFFFFFF</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set uniform variable value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScale += <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">glUniform1f(gScaleLocation, sinf(gScale));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Define uniform variable in Shader</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final result:<br><img src="/img/OpenGL/UniformVariable.PNG" alt="UniformVariable"></p>
<h3 id="Interpolation">Interpolation</h3><p><a href="http://ogldev.atspace.co.uk/www/tutorial09/tutorial09.html" target="_blank" rel="external">the interpolation that the rasterizer performs on variables that come out of the vertex shader. </a></p>
<p>在OpenGL的渲染管线里，在Fragment Shader执行之前会进行rasterizer，rasterizer会计算出各个三角形顶点之间的像素颜色数据，然后我们可以通过Fragment Shader对于光栅化的后颜色数据做进一步的处理。</p>
<p>这一章节主要看看我们是如何在Vertex Shader和Fragment Shader中如何对顶点数据和各像素信息做处理和数据传递的。(这里我们直接在VS中算出颜色信息直接传递到FS中去做处理)<br>要想从VS传递数据到FS，我们需要在Vertex Shader中定义关键词out的变量，并在Fragment Shader定义对应的关键词in的变量。</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">out vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">	</span><br><span class="line">	Color = <span class="built_in">abs</span>(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/Interpolation.PNG" alt="Interpolation"></p>
<p>从上面可以看出在VS中算出颜色信息后，经过光栅化，三角形顶点之间的颜色信息被计算出来，最终传到FS中并作为最终颜色信息输出到屏幕上。</p>
<h3 id="Coordinate_Transformations_&amp;_Perspective_Projection">Coordinate Transformations &amp; Perspective Projection</h3><p>这一章主要是学习矩阵在3D图形中的使用和了解物体时怎样被显示到正确的屏幕位置的。</p>
<p>在解释如何使用矩阵去进行向量变换之前，我们先来看看为什么矩阵可以实现向量变换？<br>下列学习参考《3D 数学基础：图形与游戏开发》<br>一个3维向量可以解释成3个基向量上平移后的组合(p,q,r为三个基向量)：<br>V = x × p + y × q + z × r;</p>
<p>当一个向量乘以矩阵的时候：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    [ p ]   [px  py  pz]</span><br><span class="line">M = [ q ] = [qx  qy  qz]</span><br><span class="line">    [ r ]   [rx  ry  rz]</span><br><span class="line"></span><br><span class="line">V = [x y z]</span><br><span class="line"></span><br><span class="line">                [px  py  pz]</span><br><span class="line">V * M = [x y z] [qx  qy  qz] = [x*px + y*qx + z*rx   x*py + y*qy + z*ry  x*pz + y*qz + z*rz] = x*p + y*q + z*r</span><br><span class="line">                [rx  ry  rz]</span><br></pre></td></tr></table></figure></p>
<p>“如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”</p>
<p>从上面我们可以看出矩阵是如何做到对于向量的坐标系转换的。</p>
<p>那么为什么我们后面用到的矩阵都是4×4而不是3×3的了？<br>4<em>4的矩阵我们叫做齐次矩阵。齐次矩阵出现的原因主要是除了记法方便，更重要的是因为3</em>3的变换矩阵只能表示线性变换，而4*4齐次矩阵能够表示线性变换和非线性变换。</p>
<p>那么这里我们来了解下什么是线性变换？<br>线性变换的满足下列公式：<br>F(a+b) = F(a) + F(b)<br>F(ka) = k × F(a)</p>
<p>因为线性变换不包含平移，所以这也是4×4齐次矩阵的出现的原因。</p>
<p>了解了使用矩阵的原因和为什么使用4×4齐次矩阵的原因后，让我们来看看，我们是如何通过矩阵来实现3D图形里的实现物体的坐标系变换的。<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)</p>
<p>因为矩阵乘法满足结合律<br>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × (M(m-w) × M(w-v) × M(v-p)) = V * N<br>所以我们只需要求出所有坐标系变换矩阵的乘积后再对V进行操作即可。</p>
<p>因为单个矩阵存储着一系列的变换，而这些变换可以通过多个单个变换组合而成，所以下列式子是成立的<br>M = S(scale) × R(rotation) × T(translation)</p>
<p>但这里有个比较关键的点，S,R,T直接的乘法顺序，矩阵是不满足交换律的，我们必须按S <em> R </em> T的顺序，原因参考下面：<br><a href="https://msdn.microsoft.com/en-us/library/eews39w7%28v=vs.110%29.aspx" target="_blank" rel="external">One reason order is significant is that transformations like rotation and scaling are done with respect to the origin of the coordinate system. Scaling an object that is centered at the origin produces a different result than scaling an object that has been moved away from the origin. Similarly, rotating an object that is centered at the origin produces a different result than rotating an object that has been moved away from the origin.</a></p>
<p>从上面可以看出，之所必须按S <em> R </em> T的顺序是因为S和R都是针对坐标系原点进行的，一旦先执行T，那么相对于坐标系原点的位置就会有所变化，这之后再做S和R就会出现不一样的表现。</p>
<p>因为OpenGL是列向量是左乘，所以在OpenGL中顺序如下：<br>V’ = T × R × S × V</p>
<p>DX中顺序如下：<br>V’ = V × S × R × T</p>
<p>获取最终的M(m-w)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetWorldTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f ScaleTrans, RotateTrans, TranslationTrans;</span><br><span class="line"></span><br><span class="line">    ScaleTrans.InitScaleTransform(m_scale.x, m_scale.y, m_scale.z);</span><br><span class="line">    RotateTrans.InitRotateTransform(m_rotateInfo.x, m_rotateInfo.y, m_rotateInfo.z);</span><br><span class="line">    TranslationTrans.InitTranslationTransform(m_worldPos.x, m_worldPos.y, m_worldPos.z);</span><br><span class="line"></span><br><span class="line">    m_Wtransformation = TranslationTrans * RotateTrans * ScaleTrans;</span><br><span class="line">    <span class="keyword">return</span> m_Wtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)<br>我们知道了M(m-w)是如何计算出来的了，接下来我们要了解M(w-v) — 世界坐标系到观察坐标系<br>在了解如何从世界坐标系转换到观察坐标系之前我们先来看看摄像机的定义：<br>位置 — (x,y,z)<br>N — The vector from the camera to its target.（look at 朝向）<br>V — When standing upright this is the vector from your head to the sky.(垂直于N向上的向量)<br>U — This vector points from the camera to its “right” side”.(在N和V定了之后可以算出Camera的向右的向量)</p>
<p>摄像机坐标系和世界坐标系：<br><img src="/img/OpenGL/CameraCoordinateTranslation.PNG" alt="CameraCoordinateTranslation"></p>
<p>要想得到物体从世界坐标系转换到摄像机坐标系，其实就是个坐标系转换的问题。<br>我们首先把摄像机移动到世界坐标原点(移动摄像机位置即可)：<br>[ 1 0 0 -x ]<br>[ 0 1 0 -y ]<br>[ 0 0 1 -z ]<br>[ 0 0 0  1 ]</p>
<p>这样一来考虑如何变化坐标系即可：<br><img src="/img/OpenGL/CameraCoordinate2.PNG" alt="CameraCoordinate2"><br>通过N,V,U，我们已经能够得出X(camera),Y(camera),Z(camera)3个基向量了。<br>还记得我们之前说的 — “如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”<br>所以：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ Ux Uy Uz <span class="number">0</span> ]    [X(world)]    [X(camera)]</span><br><span class="line">[ Vx Vy Vz <span class="number">0</span> ]    [Y(world)]    [Y(camera)]</span><br><span class="line">[ Nx Ny Nz <span class="number">0</span> ] *  [Z(world)] =  [Z(camera)]</span><br><span class="line">[ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]    [    <span class="number">1</span>   ]    [     <span class="number">1</span>   ]</span><br></pre></td></tr></table></figure></p>
<p>结合前面提到的先把摄像机移动到世界原点，得出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         [ Ux Uy Uz <span class="number">0</span> ]   [ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> -x ]</span><br><span class="line">M(w-v) = [ Vx Vy Vz <span class="number">0</span> ] * [ <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> -y ]</span><br><span class="line">         [ Nx Ny Nz <span class="number">0</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> -z ]</span><br><span class="line">         [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span> ]</span><br></pre></td></tr></table></figure></p>
<p>M(w-v)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitTranslationTransform(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">&#123;</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>; m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">3</span>] = x;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">3</span>] = y;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>; m[<span class="number">2</span>][<span class="number">3</span>] = z;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4f::InitCameraTransform(<span class="keyword">const</span> Vector3f&amp; Target, <span class="keyword">const</span> Vector3f&amp; Up)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f N = Target;</span><br><span class="line">    N.Normalize();</span><br><span class="line">    Vector3f U = Up;</span><br><span class="line">    U.Normalize();</span><br><span class="line">    U = U.Cross(N);</span><br><span class="line">    Vector3f V = N.Cross(U);</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = U.x;   m[<span class="number">0</span>][<span class="number">1</span>] = U.y;   m[<span class="number">0</span>][<span class="number">2</span>] = U.z;   m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = V.x;   m[<span class="number">1</span>][<span class="number">1</span>] = V.y;   m[<span class="number">1</span>][<span class="number">2</span>] = V.z;   m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = N.x;   m[<span class="number">2</span>][<span class="number">1</span>] = N.y;   m[<span class="number">2</span>][<span class="number">2</span>] = N.z;   m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetViewTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f CameraTranslationTrans, CameraRotateTrans;</span><br><span class="line"></span><br><span class="line">    CameraTranslationTrans.InitTranslationTransform(-m_camera.Pos.x, -m_camera.Pos.y, -m_camera.Pos.z);</span><br><span class="line">    CameraRotateTrans.InitCameraTransform(m_camera.Target, m_camera.Up);</span><br><span class="line">    </span><br><span class="line">    m_Vtransformation = CameraRotateTrans * CameraTranslationTrans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Vtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来M(w-v)也就实现了，接下来让我们看看M(v-p)是如何计算出来的吧。<br>M(v-p)这的p有多种投影方式，这里我只以Perspective Projection为例。<br>在转换到Camera坐标系后，我们还需要通过透视投影才能将3D物体映射到2D平面上。<br>Perspective Projection主要由下列四部分决定：</p>
<ol>
<li>The aspect ratio - the ratio between the width and the height of the rectangular area which will be the target of projection.</li>
<li>The vertical field of view.</li>
<li>The location of the near Z plane.</li>
<li>The location of the far Z plane.</li>
</ol>
<p>这一章的推导可以参考<a href="http://www.cnblogs.com/graphics/archive/2012/07/25/2582119.html" target="_blank" rel="external">透视投影详解</a><br>一开始推导过程中不明白的一点是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           1</span><br><span class="line">Z'' = a * --- + b</span><br><span class="line">           Pz</span><br></pre></td></tr></table></figure></p>
<p>后来看了《Mathematics for 3D Game Programming and Computer Grahpics 3rd section》的5.4.1 Depth Interpolation后明白了，光栅化的时候对于深度的运算证明了是对Z的倒数进行插值来得到Z的值的。<br>所以上述公式是成立的。</p>
<p>经过一系列推导后，我们得出了：<br><img src="/img/OpenGL/PerspectiveProject1.PNG" alt="PerspectiveProject1"><br><img src="/img/OpenGL/PerspectiveProject2.PNG" alt="PerspectiveProject2"><br><img src="/img/OpenGL/PerspectiveProject3.PNG" alt="PerspectiveProject3"><br><img src="/img/OpenGL/PerspectiveProject4.PNG" alt="PerspectiveProject4"></p>
<p>M(v-p)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitPersProjTransform(<span class="keyword">const</span> PersProjInfo&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ar         = p.Width / p.Height;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> zRange     = p.zNear - p.zFar;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFOV = tanf(ToRadian(p.FOV / <span class="number">2.0f</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>/(tanHalfFOV * ar); m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>/tanHalfFOV; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">2</span>][<span class="number">2</span>] = (-p.zNear - p.zFar)/zRange ; m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2.0f</span>*p.zFar*p.zNear/zRange;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;            m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0.0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Keyboard_&amp;&amp;_Mouse_Control">Keyboard &amp;&amp; Mouse Control</h3><p>这一章节主要是讲通过Glut提供的API如何去响应键盘和鼠标的控制。<br>本章节里面主要用到了两个类：</p>
<ol>
<li>Pipeline</li>
<li>Camera</li>
</ol>
<p>Pipeline主要是针对上一章节我们对于如何通过矩阵变化把物体显示到2D平面上的抽象：<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × M(m-w) × M(w-v) × M(v-p) = V × N</p>
<p>Pipeline只要知道了物体S,R,T信息就可以得出M(m-w)，知道了Camera信息就可以得出M(w-v),知道了透视投影信息就可以得出M(v-p)。</p>
<p>我们通过修改摄像机的相关信息得出在移动摄像机后的N,并作用于物体，这样一来就能使物体显示在正确位置了。</p>
<p>而Camera类是对摄像机的抽象。</p>
<p>Pipeline和Camera的源代码可在<a href="http://ogldev.atspace.co.uk/" target="_blank" rel="external">Modern OpenGL Tutorials</a>下载</p>
<p>这里我只关心针对键盘和鼠标的响应的相关代码：<br>Glut里针对键盘和鼠标的API主要是下列几个：</p>
<ol>
<li>glutSpecialFunc() — 主要是针对特殊按键比如F1</li>
<li>glutKeyboardFunc() — 主要是针对普通按键比如A,B,C……</li>
<li>glutPassiveMotionFunc() — 主要是针对在没有鼠标按键被按下的情况下，鼠标在窗口内移动的情况</li>
<li>glutMotionFunc() — 主要是针对在鼠标按键被按下的情况下，鼠标在窗口内移动的情况</li>
</ol>
<p>相关代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecialKeyboardCB</span><span class="params">(<span class="keyword">int</span> Key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    OGLDEV_KEY OgldevKey = GLUTKeyToOGLDEVKey(Key);</span><br><span class="line">    pGameCamera-&gt;OnKeyboard(OgldevKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">KeyboardCB</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">            glutLeaveMainLoop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PassiveMouseCB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pGameCamera-&gt;OnMouse(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallbacks</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">    glutSpecialFunc(SpecialKeyboardCB);</span><br><span class="line">    glutPassiveMotionFunc(PassiveMouseCB);</span><br><span class="line">    glutKeyboardFunc(KeyboardCB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/MouseAndKeyboardStudy.PNG" alt="MouseAndKeyboardStudy"></p>
<h3 id="Texture_Mapping">Texture Mapping</h3><p>“Textures are composed of texels, which often contain color values.”</p>
<p>“Textures are bound to the OpenGL context via texture units, which are represented as binding points named GL_TEXTURE0 through GL_TEXTUREi where i is one less than the number of texture units supported by the implementation.”</p>
<p>The textures are accessed via sampler variables which were declared with dimensionality that matches the texture in shader</p>
<p>在真正接触Texutre之前，让我们理解下下列几个重要的概念：</p>
<ol>
<li><p>Texture object – contains the data of the texture image itself, i.e. the texels（可以看出Texture object才是含有原始数据信息的对象）</p>
</li>
<li><p>Texture unit – texture object bind to a ‘texture unit’ whose index is passed to the shader. So the shader reaches the texture object by going through the texture unit.（我们访问texture数据信息并不是通过texture object，而是在shader里通过访问特定索引的texture unit去访问texture object里的数据）</p>
</li>
<li><p>Sampler Object – configure it with a sampling state and bind it to the texture unit. When you do that the sampler object will override any sampling state defined in the texture object.（Sampler Object一些sampling的配置信息，当用于texture object时会覆盖texture object里的原始sampler设定）</p>
</li>
<li><p>Sampler uniform – corresponding to handle of texture unit(用于在Shader里访问texture unit，texture unit和texture object绑定，也就间接的访问了texture的原始数据)</p>
</li>
</ol>
<p>Relationship between texture object, texture unit, sampler object and sampler uniform<br><img src="/img/OpenGL/TextureConcepts.png" alt="RelationshipBetweenThem"></p>
<p>因为OpenGL没有提供从图片加载texture的API，所以这里我们需要使用第三方库来完成这项工作，这里教程上使用的是ImageMagick。<br>ImageMagick主要是为了从多种格式的资源文件中读取原始数据，在我们指定glTexImage2D()的原始数据的时候提供所在内存地址。</p>
<p>Steps to use texture mapping:</p>
<ol>
<li><p>Create a texture object and load texel data into it<br>glGenTextures() — gen texture object<br>glBindTexture() — Tells OpenGL the texture object we refer to in all the following texture related calls, until a new texture object is bound.<br>glTexImage2D() — load texel data into texture object</p>
</li>
<li><p>Include texture coordinates with your vertices</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vertex Vertices[<span class="number">4</span>] = &#123; Vertex(Vector3f(-<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.5773f</span>), Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">0.0f</span>, -<span class="number">1.0f</span>, -<span class="number">1.15475f</span>), Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.5773f</span>),  Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),      Vector2f(<span class="number">0.5f</span>, <span class="number">1.0f</span>)) &#125;;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把顶点对应的纹理坐标信息写到vertex数据里</span></span><br><span class="line"><span class="comment">//说道纹理坐标就不得不提一下Texture UV纹理坐标了，Texture的图片被映射到0-1的二维坐标，图见后面：</span></span><br><span class="line"></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), <span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">const</span> GLvoid*)<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后通过指定如何解析顶点数据里面的的数据在Shader里访问vertex的texture纹理坐标信息去sample出texture数据信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Associate a texture sampler with each texture map you intend to use in your shader<br>glTexParameterf() — Texture采样方式的配置<br>还记得我们之前讲到的Sampler object吗？这里的配置就好比我们在sampler object里配置后再作用于特定的texture object<br>这里我就不说关于采样方式配置相关的内容了（采样方式会决定最终像素的计算方式），这里值得一提的是mipmap的概念。<br>mipmap主要是由于物体在场景中因为距离的缘故会在屏幕显示的大小有变化，如果我们在物体很远，只需要显示很小一块的时候还依然采用很大的纹理贴图，最终显示在屏幕上的纹理会很不清晰（失真）。为了解决这个问题，mipmap应运而生，通过事先生成或指定多个级别的同一纹理贴图，然后在程序运作的过程中通过计算算出应该使用哪一个等级的纹理贴图来避免大纹理小色块失真的问题。<br>我们可以手动通过：<br>glTexStorage2D() &amp;&amp; glTexSubImage2D() 去手动指定各级纹理贴图<br>也可以通过：<br>glGenerateMipmap() — 自动去生成对应的mipmap纹理贴图<br>而程序在实际运作过程中如何去计算Mipmap Level这里就不做介绍了，详细参考《OpenGL Programming Guide 8th Edition》的Calculating the Mipmap章节<br>相关函数：<br>textureLod()<br>textureGrad()</p>
</li>
<li><p>Active texture unit and bind texture object to it<br>glActiveTexture() — 激活特定的texture unit然后绑定特定texture object到特定texture unit上<br>glBindTexture() — 绑定特定的texture object到texture unit上</p>
</li>
<li><p>Retrieve the texel values through the texture sampler from your shader<br>首先我们在程序中指定了我们即将访问的Texture unit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gSampler = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler"</span>);</span><br><span class="line">assert(gSampler != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">glUniform1i(gSampler, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Note:<br>“The important thing to note here is that the actual index of the texture unit is used here, and not the OpenGL enum GL_TEXTURE0 (which has a different value).”</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	TexCoord0 = TexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = texture2D(gSampler, TexCoord0.xy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出我们在fragment shader里，通过传入的gSampler确认了使用哪一个texture unit，通过传入的TexCoord0确认了对应的纹理坐标信息去获取对应的texture信息，然后最终通过texture2D从texture里取得了特定的颜色信息作为输出，就这样纹理图片的信息就作用在了三角形上并显示出来。</p>
<p><img src="/img/OpenGL/TextureCoordinate.PNG" alt="TextureCoordinate"></p>
<p>final result:<br><img src="/img/OpenGL/BasicTexture.PNG" alt="BasicTexture"></p>
<p>下面我简单测试了下两个Texture计算出最终纹理信息：<br>TextureStudy.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeTextureInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gSampler = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler"</span>);</span><br><span class="line">	assert(gSampler != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">	gSampler2 = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler2"</span>);</span><br><span class="line">	assert(gSampler2 != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Specify the inder of texture unit we will use in shader</span></span><br><span class="line">	glUniform1i(gSampler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glUniform1i(gSampler2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	pTexture = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/texture1.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pTexture-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pTexture2 = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/texture2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pTexture2-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallbackCB</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	pTexture-&gt;Bind(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	pTexture2-&gt;Bind(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = <span class="number">0.5</span> * texture2D(gSampler, TexCoord0.xy) + <span class="number">0.5</span> * texture2D(gSampler2, TexCoord0.xy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始图片分别为：<br><img src="/img/OpenGL/texture1.png" alt="Texture1"><br><img src="/img/OpenGL/texture2.jpg" alt="Texture2"></p>
<p>final result:<br><img src="/img/OpenGL/MultipleTexture.PNG" alt="MultipleTexture"></p>
<p>Point Sprites:<br>待理解学习……</p>
<p>Rendering to Texture Maps:<br>待理解学习……</p>
<p>Sumary：</p>
<ol>
<li><p>Use immutable texture storage for textures wherever possible – When a texture is marked as immutable, the OpenGL implementation can make certain assumptions about the validity of a texture object （尽量使用不可变的texture storage， 这样OpenGL可以确保texture的有效性）</p>
</li>
<li><p>Create and initialize the mipmap chain for textures unless you have a good reason not to – improve the image quality of your program’s rendering, but also will make more efficient use of the caches in the graphics processor （为了渲染效率，减轻GPU负担，尽可能为texture创建mipmap）</p>
</li>
<li><p>Use an integer sampler in your shader when your texture data is an unnormalized integer and you intend to use the integer values it contains directly in the shader （尽量在shader里使用integer类型的sampler）</p>
</li>
</ol>
<p>Note:<br>“The maximum number of texture units supported by OpenGL<br>can be determined by retrieving the value of the GL<em>MAX_COMBINED</em><br>TEXTURE_IMAGE_UNITS constant, which is guaranteed to be at least 80 as<br>of OpenGL 4.0.”</p>
<p>Proxy texture – used to test the capabilities of the OpenGL implementation when certain limits are used in combination with each other.</p>
<h3 id="Light_and_Shadow">Light and Shadow</h3><p>光源类型：</p>
<ol>
<li>Ambient Light (环境光) — 环境光只影响ambient</li>
<li>Directional Light (方向光) — 方向光会影响diffuse &amp; specular</li>
<li>Point Light (点光源) — 与方向光的区别是有attenuation(衰弱)而且点光源照射物体的表面的方向不一样，同样会影响diffuse &amp; specular</li>
</ol>
<p>传统的光照组成：<br>Ambient (环境光) — 与光照的方向无关<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FragColor = texture2D(gSampler, TexCoord0.xy) *</span><br><span class="line">        vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *</span><br><span class="line">        gDirectionalLight.AmbientIntensity;</span><br></pre></td></tr></table></figure></p>
<p>因为环境光与光照方向无关，只需考虑方向光的颜色和方向光所占比重，所以基本上主要计算归结于上述运算。</p>
<p>final effect:<br><img src="/img/OpenGL/Ambient.PNG" alt="Ambient"></p>
<p>Note:<br>这里源代码里有个错误，在子类重写虚函数的KeyboardCB的时候，由于参数写的不对，没能正确重写该虚函数而没有被调到。<br>错误：<br>virtual void KeyboardCB(OGLDEV_KEY OgldevKey);<br>正确：<br>virtual void KeyboardCB(OGLDEV_KEY OgldevKey, OGLDEV_KEY_STATE OgldevKeyState = OGLDEV_KEY_STATE_PRESS)</p>
<p>Diffuse (漫反射光) — 与光照的方向和顶点normal有关<br>因为满返色光要考虑光照的方向和物体的顶点法线，所以我们需要在shader里进行计算之前要把顶点的发现算出来然后传入Shader进行计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcNormals</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* pIndices, <span class="keyword">unsigned</span> <span class="keyword">int</span> IndexCount, Vertex* pVertices, <span class="keyword">unsigned</span> <span class="keyword">int</span> VertexCount)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; IndexCount ; i += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index0 = pIndices[i];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index1 = pIndices[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index2 = pIndices[i + <span class="number">2</span>];</span><br><span class="line">        Vector3f v1 = pVertices[Index1].m_pos - pVertices[Index0].m_pos;</span><br><span class="line">        Vector3f v2 = pVertices[Index2].m_pos - pVertices[Index0].m_pos;</span><br><span class="line">        Vector3f Normal = v1.Cross(v2);</span><br><span class="line">        Normal.Normalize();</span><br><span class="line"></span><br><span class="line">        pVertices[Index0].m_normal += Normal;</span><br><span class="line">        pVertices[Index1].m_normal += Normal;</span><br><span class="line">        pVertices[Index2].m_normal += Normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; VertexCount ; i++) &#123;</span><br><span class="line">        pVertices[i].m_normal.Normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#version 330</span><br><span class="line"></span><br><span class="line">layout (location = 0) in vec3 Position;</span><br><span class="line">layout (location = 1) in vec2 TexCoord;</span><br><span class="line">layout (location = 2) in vec3 Normal;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line">uniform mat4 gWorld;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line">out vec3 Normal0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = gWVP * vec4(Position, 1.0);</span><br><span class="line">    TexCoord0 = TexCoord;</span><br><span class="line">    Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意“Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;” — 因为我们对于顶点法线的计算是基于物体没有移动变化之前的，所以我们真正计算所用的顶点法线需要通过世界坐标系矩阵的转换。</p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line">in vec3 Normal0;                                                                    </span><br><span class="line">                                                                                    </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">struct</span> DirectionalLight                                                             </span><br><span class="line">&#123;                                                                                   </span><br><span class="line">    vec3 Color;                                                                     </span><br><span class="line">    <span class="keyword">float</span> AmbientIntensity;                                                         </span><br><span class="line">    <span class="keyword">float</span> DiffuseIntensity;                                                         </span><br><span class="line">    vec3 Direction;                                                                 </span><br><span class="line">&#125;;                                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line">uniform DirectionalLight gDirectionalLight;                                         </span><br><span class="line">uniform sampler2D gSampler;                                                         </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    vec4 AmbientColor = vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *                       </span><br><span class="line">                        gDirectionalLight.AmbientIntensity;                         </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">float</span> DiffuseFactor = dot(normalize(Normal0), -gDirectionalLight.Direction);    </span><br><span class="line">                                                                                    </span><br><span class="line">    vec4 DiffuseColor;                                                              </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (DiffuseFactor &gt; <span class="number">0</span>) &#123;                                                        </span><br><span class="line">        DiffuseColor = vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *                        </span><br><span class="line">                       gDirectionalLight.DiffuseIntensity *                         </span><br><span class="line">                       DiffuseFactor;                                               </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                          </span><br><span class="line">        DiffuseColor = vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                                            </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    FragColor = texture2D(gSampler, TexCoord0.xy) *                                 </span><br><span class="line">                (AmbientColor + DiffuseColor);                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从“float DiffuseFactor = dot(normalize(Normal0), -gDirectionalLight.Direction);”可以看出，光照的方向和顶点法线之间的角度直接决定了漫反射光所占的比重。<br>参见<a href="https://en.wikipedia.org/wiki/Lambert&#39;s_cosine_law" target="_blank" rel="external">Lambert’s cosine law</a></p>
<p>final effect:<br><img src="/img/OpenGL/Diffuse.PNG" alt="Diffuse"></p>
<p>Note:<br>这里我按照官网和源代码的方式按自己的方式写了，但不知道为何DiffuseFactor得出的值当我去做if else判断等，无论是&gt;0,&lt;0,==0都不会进去，都只会进入最终的else。<br>我通过gDEBugger查看了uniform的值没有问题，C++那一侧所有的相关计算的值也都正确，这里弄了半天也没有解决，本来准备用Nsight调试GLSL的，发现我的笔记本好像不被支持。<br>个人最终认为是顶点的法线在传递给Shader的时候出问题了，导致dot之后计算DiffuseFactor出问题，虽然在VS一侧下的断点查看normal是正确的，但不确定为什么shader一侧获得的值会有问题。（这一结论主要是因为同样的shader代码在加载现有模型的时候起作用发现的）</p>
<p>Specular (镜面反射光) — 与光照的方向和eye观察还有顶点normal有关<br>Specular在Diffuse的基础上，还要多考虑一个因素（观察者所在位置，如果观察者正好在反光处，那么该观察点就会比在其他位置的观察点观察同一位置的看起来更亮）。但现实中并不是所有物体都有这一特性，所以Specular更针对物体材质而言而非光线本身。</p>
<p>看一下下图：<br><img src="/img/OpenGL/SpecularModle.PNG" alt="SpecularModle"><br>I是光线入射方向<br>N是平面法线<br>R是完美反射后的光线<br>V是观察者观察方向<br>a是观察者方向与完美反射光线的夹角<br>从上图可以看出当观察者所在观察角度V与R越接近时，我们可以理解为观察者观察该点会达到最大量值</p>
<p>我们计算出R主要是通过I和N和-N之间的计算：<br>详情见下图：<br><img src="/img/OpenGL/SpecularModle2.PNG" alt="SpecularModle2"><br>R = I + V<br>V = 2 <em> N </em> dot(-N,I)<br>这里值得一提的是OpenGL里提供了reflect方法，通过光线和平面法线就能直接算出反射R</p>
<p>让我们直接看一下Specular的计算公式：<br><img src="/img/OpenGL/SpecularCalculation.PNG" alt="SpecularCalculation"><br>M — 是跟物体材质有关的，材质决定了specular的反光系数<br>     p<br>(R.V) — 是指观察者所在位置和完美反射光线之间夹角的P次方，P是shininess factor（発光系数之类的）<br>上述换成代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vec3 VertexToEye = normalize(gEyeWorldPos - WorldPos0);                     </span><br><span class="line">vec3 LightReflect = normalize(reflect(gDirectionalLight.Direction, Normal));</span><br><span class="line"><span class="keyword">float</span> SpecularFactor = dot(VertexToEye, LightReflect);                      </span><br><span class="line"><span class="keyword">if</span> (SpecularFactor &gt; <span class="number">0</span>) &#123;                                                   </span><br><span class="line">    SpecularFactor = <span class="built_in">pow</span>(SpecularFactor, gSpecularPower);</span><br><span class="line">    SpecularColor = vec4(gDirectionalLight.Color * gMatSpecularIntensity * SpecularFactor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">FragColor = texture2D(gSampler, TexCoord0.xy) *                                 </span><br><span class="line">            (AmbientColor + DiffuseColor + SpecularColor);</span><br></pre></td></tr></table></figure></p>
<p>Limitations of the Classic Lighting Model: （传统光源的不足之处）<br>Big Missing:</p>
<ol>
<li>Assume no other objects blocking the path of the lights to the surface （假设光不会被物体遮挡）</li>
<li>Accurate ambient lighting （统一固定精确的环境光，现实中是由削弱的（attenuation））</li>
</ol>
<p>了解了光源的三个组成，也了解了传统光源的不足，让我们来看看另一种光照Point Light：<br>Point Light是有伴随距离而削弱（attenuation）的光源<br>公式如下：<br><img src="/img/OpenGL/PointLightFormulation.PNG" alt="PointLightFormulation"></p>
<p>在实现Point Light的计算的时候，我们只需要把光照的方向根据Point Light位置算一下，并在最后除以根据物体位置与Point Light的光源位置算出的attenuation即可、<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">CalcPointLight</span><span class="params">(<span class="keyword">int</span> Index, vec3 Normal)</span>                                                 </span><br><span class="line"></span>&#123;                                                                                           </span><br><span class="line">    vec3 LightDirection = WorldPos0 - gPointLights[Index].Position;                         </span><br><span class="line">    <span class="keyword">float</span> Distance = length(LightDirection);                                                </span><br><span class="line">    LightDirection = normalize(LightDirection);                                             </span><br><span class="line">                                                                                            </span><br><span class="line">    vec4 Color = CalcLightInternal(gPointLights[Index].Base, LightDirection, Normal);       </span><br><span class="line">    <span class="keyword">float</span> Attenuation =  gPointLights[Index].Atten.Constant +                               </span><br><span class="line">                         gPointLights[Index].Atten.Linear * Distance +                      </span><br><span class="line">                         gPointLights[Index].Atten.Exp * Distance * Distance;               </span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="keyword">return</span> Color / Attenuation;                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看一下Spot Light:<br>Spot Light和Point Light的主要区别在于，Spot Light定义了一个可影响的范围Cone和其垂直照射的方向。<br>而这个Cone通过Cutoff来定义：<br>Cutoff — “ The cutoff value represents the maximum angle between the light direction and the light to pixel vector for pixels that are under the influence of the spot light.”<br>见下图：<br><img src="/img/OpenGL/SpotLight.PNG" alt="SpotLight"></p>
<p>通过计算出所在点是否在Spot Light的Cone里去决定是否影响该颜色值。<br>这里需要关注的一点是关于如何映射Cutoff值到[0，1]，因为一般来说Cutoff的值不可能设置到0（即90度），所以我们要想计算边缘化削弱效果，我们需要对Cutoff的值进行线性插值。<br>推导见如下（来源之OpenGL Tutorial 21）：<br><img src="/img/OpenGL/SpotLightCutoffMapping.PNG" alt="SpotLightCutoffMapping"></p>
<p>知道了怎么确认是否影响该点颜色，以及如何插值获取影响值，那么最终归结代码见如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">CalcSpotLight</span><span class="params">(<span class="keyword">struct</span> SpotLight l, vec3 Normal)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec3 LightToPixel = normalize(WorldPos0 - l.Base.Position);</span><br><span class="line">    <span class="keyword">float</span> SpotFactor = dot(LightToPixel, l.Direction);</span><br><span class="line">    <span class="comment">//计算所在点是否在Spot Light的Cone里去决定是否影响该颜色值。</span></span><br><span class="line">    <span class="keyword">if</span> (SpotFactor &gt; l.Cutoff) &#123;</span><br><span class="line">        vec4 Color = CalcPointLight(l.Base, Normal);</span><br><span class="line">        <span class="comment">//插值计算影响值</span></span><br><span class="line">        <span class="keyword">return</span> Color * (<span class="number">1.0</span> - (<span class="number">1.0</span> - SpotFactor) * <span class="number">1.0</span>/(<span class="number">1.0</span> - l.Cutoff));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vec4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>More Advanced Lighting Model:<br>Hemisphere Lighting:<br>The idea behind hemisphere lighting is that we model the illumination as two hemispheres. The upper hemisphere represents the sky and the lower hemisphere represents the ground</p>
<p>Imaged-Based Lighting:<br>“It is often easier and much more efficient to sample the lighting in such environments and store the results in one or more environment maps”</p>
<p>Lighting with Spherical Harmonics:<br>“This method reproduces accurate diffuse reflection, based on the content of a light probe image, without accessing the light probe image at runtime”</p>
<p><a href="www.debevec.org">详情参考</a> </p>
<p>总结:<br>Ambient (环境光) — 与光照的方向无关<br>环境光不会削弱不考虑方向，所以只需考虑光照颜色和平面颜色即可<br>Diffuse (漫反射光) — 与光照的方向和顶点normal有关<br>光照的方向和顶点法线之间的角度直接决定了漫反射光所占的比重。<br>Specular (镜面反射光) — 与光照的方向和eye观察还有顶点normal有关<br>观察者所在位置和光照方向和法线会决定观察者所在位置的Specular反射比例，物体材质会决定Specular反射系数。<br>最终通过计算环境中所有光源对物体的ambient, diffuse, specular影响计算出物体的最终color</p>
<p>接下来我们看一个真实渲染过程中比较重要的技术 — Shadow Mapping<br>Shadow Mapping — Uses a depth texture to determine whether a point is lit or not.</p>
<p>Shadow mapping is a multipass technique that uses depth textures to provide a solution to rendering shadows (核心思想是通过比较通过光源点观察保存的深度信息（depth texture）和从观察点观察的深度信息来判断哪些点是shadowed，哪些是unshadowed — 注意比较的是通过映射到2D depth texture后的信息)<br>A key pass is to view the scene from the shadow-casting light source rather than from the final viewpoint<br>Two passes:</p>
<ul>
<li><em>First Pass</em><br>Shadow map — by rendering the scene’s depth from the point of the light into a depth texture, we can obtain a map of the shadowed and unshadowed points in the scene<br>在第一个pass中，我按照事例代码中写了，但发现最后显示的是纯白色的图像。<br>后来就不断去查问题。<br><img src="/img/OpenGL/ShaowMapFirstPass.PNG" alt="ShaowMapFirstPassFailed"><br>首先，我怀疑depth texture是不是没有生成成功？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the FBO</span></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the depth buffer</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;m_shadowMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_shadowMap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable writes to the color buffer</span></span><br><span class="line">glDrawBuffer(GL_NONE);</span><br><span class="line">glReadBuffer(GL_NONE);</span><br><span class="line"></span><br><span class="line">GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但上述代码没有报任何错误，通过gDebugger查看Texture的时候发现depth texture是生成成功了的。<br><img src="/img/OpenGL/ShaowMapFirstPassCreate.PNG" alt="ShaowMapFirstPassCreate"><br>从上图仔细看，模型的深度信息时被生成到了FBO 1所绑定的Depth Texture中了的。</p>
<p>那么接下来，我就怀疑是不是我激活的Texture unit有错误？<br>以下是将Depth Texture渲染到一个平面上的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ShadowMapFBO::BindForReading(GLenum TextureUnit)</span><br><span class="line">&#123;</span><br><span class="line">    glActiveTexture(TextureUnit);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glUniform1i(gTextureLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	gShadowMapFBO.BindForReading(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">5.0f</span>, <span class="number">5.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">	p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">	p.SetCamera(pGameCamera-&gt;GetPos(), pGameCamera-&gt;GetTarget(), pGameCamera-&gt;GetUp());</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	glUniformMatrix4fv(gWVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)p.GetWVPTrans());</span><br><span class="line"></span><br><span class="line">	gPQuade-&gt;Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/OpenGL/MyTextureList.PNG" alt="MyTextureList"><br><img src="/img/OpenGL/DemoTextureList.PNG" alt="DemoTextureList"><br>通过上图，我发现我自己的代码有三个Texture被生成，但Demo只有两个，并且我自己写的代码Enable的并非FBO 1绑定生成的Texture而是第三个Texture，所以这是我怀疑我在加载Mesh的时候加载了第三个Texture并将其绑定在了Texture unit 0，而我碰巧激活了这一个Texture unit。</p>
<p>由于我的mesh.cpp是沿用上一个tutorial的代码，所以我没有更新到最新教程的mesh代码。<br>下面是我所用的mesh.cpp的一个加载Texture的方法和Texture源代码加载的时候的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Mesh::InitMaterials(<span class="keyword">const</span> aiScene* pScene, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load a white texture in case the model does not include its own texture</span></span><br><span class="line">    <span class="keyword">if</span> (!m_Textures[i]) &#123;</span><br><span class="line">        m_Textures[i] = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/white.png"</span>);</span><br><span class="line"></span><br><span class="line">        Ret = m_Textures[i]-&gt;Load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mesh::Render()</span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MaterialIndex &lt; m_Textures.size() &amp;&amp; m_Textures[MaterialIndex]) &#123;</span><br><span class="line">        m_Textures[MaterialIndex]-&gt;Bind(GL_TEXTURE0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Texture::Load()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m_image.read(m_fileName);</span><br><span class="line">        m_image.write(&amp;m_blob, <span class="string">"RGBA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Magick::Error&amp; Error) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error loading texture '"</span> &lt;&lt; m_fileName &lt;&lt; <span class="string">"': "</span> &lt;&lt; Error.what() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_textureObj);</span><br><span class="line">    glBindTexture(m_textureTarget, m_textureObj);</span><br><span class="line">    glTexImage2D(m_textureTarget, <span class="number">0</span>, GL_RGBA, m_image.columns(), m_image.rows(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_blob.data());</span><br><span class="line">    glTexParameterf(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    </span><br><span class="line">    glBindTexture(m_textureTarget, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Texture::Bind(GLenum TextureUnit)</span><br><span class="line">&#123;</span><br><span class="line">    glActiveTexture(TextureUnit);</span><br><span class="line">    glBindTexture(m_textureTarget, m_textureObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出如果我加载的mesh没有含有贴图的话，我会指定他去默认加载white.png作为贴图，并且渲染的时候激活Texture unit 0并将该纹理绑定到Texture unit 0</p>
<p>这也就是为什么我后来调用下列代码出现了Active错误的texture的原因。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniform1i(gTextureLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">gShadowMapFBO.BindForReading(GL_TEXTURE0);</span><br></pre></td></tr></table></figure></p>
<p>所以在不改Texture和Mesh源代码的情况下，我只需要将生成的Texture unit绑定到GL_TEXTURE2并指定Shader去访问Texture unit 2即可。<br>将上述代码改为如下即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniform1i(gTextureLocation, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">gShadowMapFBO.BindForReading(GL_TEXTURE2);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/OpenGL/ShadowMapFirstPassSuccessful.PNG" alt="ShadowMapFirstPassSuccessful"></p>
<p>在渲染到Depth Texture的时候，主要是通过以下步骤：</p>
<ol>
<li><p>创建新的FBO和Texture object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the FBO</span></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the depth texture</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;m_shadowMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活新的FBO并绑定Texture object到FBO的Depth buffer上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_shadowMap, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭颜色写入到新的FBO。因为我们只需要Depth信息，所以我们不需要写入颜色信息到新的FBO里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawBuffer(GL_NONE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查新的FBO的状态是否完整</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活新的FBO并清除Depth信息后以光线来源的角度draw call写入depth信息到新的FBO和绑定的depth texture里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShadowMapPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gShadowMapFBO.BindForWriting();</span><br><span class="line"></span><br><span class="line">	glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">	p.Rotate(<span class="number">0.0f</span>, gScale, <span class="number">0.0f</span>);</span><br><span class="line">	p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">	p.SetCamera(gSpotLight.Position, gSpotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set uniform variable value</span></span><br><span class="line">	glUniformMatrix4fv(gWVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)p.GetWVPTrans());</span><br><span class="line"></span><br><span class="line">	gPTank-&gt;Render();</span><br><span class="line"></span><br><span class="line">	glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><em>Second Pass</em><br>Rendering the scene from the point of view of the viewer. Project the surface coordinates into the light’s reference frame and compare their depths to the depth recorded into the light’s depth texture. Fragments that are further from the light than the recorded depth value were not visible to the light, and hence in shadow</li>
</ul>
<p>第二个pass的关键有下列几个点：</p>
<ol>
<li><p>正常方式渲染时，通过传递Light的MVP去计算每一个顶点在光源角度观察时的投影位置信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 TexCoord;                                             </span><br><span class="line">layout (location = <span class="number">2</span>) in vec3 Normal;                                               </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gWVP;                                                                  </span><br><span class="line">uniform mat4 gLightWVP;                                                             </span><br><span class="line">uniform mat4 gWorld;                                                                </span><br><span class="line">                                                                                    </span><br><span class="line">out vec4 LightSpacePos;                                                             </span><br><span class="line">out vec2 TexCoord0;                                                                 </span><br><span class="line">out vec3 Normal0;                                                                   </span><br><span class="line">out vec3 WorldPos0;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//这里就是转换到以光源为摄像机角度的透视投影后的坐标信息</span></span><br><span class="line">    LightSpacePos = <span class="function">gLightWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;                                 </span><br><span class="line">	......                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过把光源角度下投影的位置信息转换到NDC space(设备坐标系，光栅化后xyz都映射到[-1,1])，这时就得到了顶点在光源角度下NDC的坐标信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lighting.fs                                                 </span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcShadowFactor</span><span class="params">(vec4 LightSpacePos)</span>                                                 </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="comment">//通过除以w我们可以得到NDC space的信息</span></span><br><span class="line">    vec3 ProjCoords = LightSpacePos.xyz / LightSpacePos.w;                    </span><br><span class="line">	......                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后通过转换纹理坐标映射到[0,1]去查询Depth texture中的深度信息和自身的z深度信息作比较，如果depth texture中值更小说明改点处于被遮挡区域应该是阴影部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcShadowFactor</span><span class="params">(vec4 LightSpacePos)</span>                                                 </span><br><span class="line"></span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    vec2 UVCoords;                                                                         </span><br><span class="line">    UVCoords.x = <span class="number">0.5</span> * ProjCoords.x + <span class="number">0.5</span>;                                                 </span><br><span class="line">    UVCoords.y = <span class="number">0.5</span> * ProjCoords.y + <span class="number">0.5</span>;                                                 </span><br><span class="line">    <span class="keyword">float</span> z = <span class="number">0.5</span> * ProjCoords.z + <span class="number">0.5</span>;                                                    </span><br><span class="line">    <span class="keyword">float</span> Depth = texture(gShadowMap, UVCoords).x;                                         </span><br><span class="line">    <span class="keyword">if</span> (Depth &lt; z + <span class="number">0.00001</span>)                                                               </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>;                                                                        </span><br><span class="line">    <span class="keyword">else</span>                                                                                   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为原本x，y，z在NDC space下是[-1,1]，为了映射到[0,1]，我们只需要按上述方法即可。<br>这样一来就得到NDC space下的纹理坐标信息和深度z信息，然后通过查询depth texture获取光源角度的深度信息和现有顶点在光源角度的深度信息做比较得出是否处于阴影的结论。</p>
<p>这里实现相当复杂就没有自己再去写一遍，具体参考Tutorial 24的源代码。<br>最终效果：<br><img src="/img/OpenGL/ShadowMapFinal.PNG" alt="ShadowMap"></p>
<h2 id="OpenGL_Utility">OpenGL Utility</h2><h3 id="Open_Asset_Import_Library">Open Asset Import Library</h3><p>“Open Asset Import Library is a portable Open Source library to import various well-known 3D model formats in a uniform manne”</p>
<p><a href="http://www.assimp.org/" target="_blank" rel="external">官方网站</a></p>
<h4 id="assimp">assimp</h4><p>“assimp is a library to load and process geometric scenes from various data formats. It is tailored at typical game scenarios by supporting a node hierarchy, static or skinned meshes, materials, bone animations and potential texture data. The library is not designed for speed, it is primarily useful for importing assets from various sources once and storing it in a engine-specific format for easy and fast every-day-loading. “</p>
<p><a href="http://www.assimp.org/lib_html/index.html" target="_blank" rel="external">官方文档</a></p>
<p>Note:<br>个人理解，assimp主要是提供了对多种格式模型的数据解析，并抽象了所有数据到aiScene这个类里。<br>通过aiScene我们可以去访问模型数据里的顶点数据，纹理数据，材质数据等。<br>我们通过这些数据最终去作为我们的顶点数据创建顶点buffer，作为纹理数据创建纹理贴图，最终绘制出我们的模型。</p>
<p>源代码参考OpenGL Tutorial 22</p>
<h4 id="open3mod">open3mod</h4><p>“open3mod is a Windows-based model viewer. It loads all file formats that Assimp supports and is perfectly suited to quickly inspect 3d assets.”</p>
<p>主要用于快速查看各种资源格式的模型。<br><img src="/img/OpenGL/Open3mod.PNG" alt="Open3modUsing"></p>
<h3 id="GLSL_Debuger">GLSL Debuger</h3><h4 id="Nsight">Nsight</h4><p><a href="http://www.nvidia.com/object/nsight.html" target="_blank" rel="external">NVIDIA® Nsight™ is the ultimate development platform for heterogeneous computing. Work with powerful debugging and profiling tools that enable you to fully optimize the performance of the CPU and GPU. - See more at: http://www.nvidia.com/object/nsight.html#sthash.Hc8TfPMs.dpuf</a><br>Nsight是NVIDIA开发的一套协助GPU开发的工具。<br>优点：</p>
<ol>
<li>支持直接调试GLSL和HLSL等着色器语言</li>
<li>和VS完美集成</li>
</ol>
<p>缺点：</p>
<ol>
<li>硬件限制比较多（比如主要针对NVIDIA公司的显卡）<br><a href="https://developer.nvidia.com/nsight-visual-studio-edition-requirements" target="_blank" rel="external">Nsight Visual Studio Edition Requirements</a></li>
</ol>
<h3 id="OpenGL_proiler,_debugger">OpenGL proiler, debugger</h3><h4 id="gDEBugger">gDEBugger</h4><p>gDEBugger是一个针对OpenGL和OpenCL开发的一套调试器，分析器和内存分析器等协助工具。<br>通过gDEBugger我们可以查看在某一贞关于OpenGL相关的大量信息（比如Uniform值，OpenGL的各个状态，Draw call次数等）<br>可以查看到OpenGL的一些状态，比如GL_CULL_FACE:<br><img src="/img/OpenGL/gDEBuggerCapture.PNG" alt="gDEBuggerCapture"></p>
<p>可以查看Shader的一些信息，并且可以编译Shader等：<br><img src="/img/OpenGL/gDEBuggerShaderInfo.PNG" alt="gDEBuggerShaderInfo"></p>
<h1 id="Reference_Website:">Reference Website:</h1><p><a href="http://www.opengl.org/sdk/docs/man4/" target="_blank" rel="external">OpenGL 4 reference page</a><br><a href="http://blog.csdn.net/guolihui112/article/details/5702915" target="_blank" rel="external">client-server 模式</a><br><a href="http://www.glprogramming.com/blue/ch01.html" target="_blank" rel="external">OpenGL Execute Model</a><br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a><br><a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">OpenGL Tutorial</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGL Windows &amp; Context</a><br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a><br><a href="https://www.opengl.org/wiki/OpenGL_Context" target="_blank" rel="external">OpenGL Context</a><br><a href="https://open.gl/context" target="_blank" rel="external">Window and OpenGL context</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGLBook.com Getting Started</a></p>
<p>Note:<br><strong>OpenGL uses right-handed coordinate system (OpenGL使用右手坐标系)</strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Rendering/">Rendering</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OpenGL/">OpenGL</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/" data-title="OpenGL_Study | 走停人生路" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/29/Computer-Graphic-Study/" title="Computer_Graphic_Study">
  <strong>上一篇：</strong><br/>
  <span>
  Computer_Graphic_Study</span>
</a>
</div>


<div class="next">
<a href="/2015/08/15/CSharp-Study/"  title="C# Study">
 <strong>下一篇：</strong><br/> 
 <span>C# Study
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/26/OpenGL-Study/" data-title="OpenGL_Study" data-url="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard_&&_Mouse_Control"><span class="toc-number">1.4.9.</span> <span class="toc-text">Keyboard && Mouse Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture_Mapping"><span class="toc-number">1.4.10.</span> <span class="toc-text">Texture Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light_and_Shadow"><span class="toc-number">1.4.11.</span> <span class="toc-text">Light and Shadow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Utility"><span class="toc-number">1.5.</span> <span class="toc-text">OpenGL Utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_Asset_Import_Library"><span class="toc-number">1.5.1.</span> <span class="toc-text">Open Asset Import Library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assimp"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">assimp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open3mod"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">open3mod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL_Debuger"><span class="toc-number">1.5.2.</span> <span class="toc-text">GLSL Debuger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nsight"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">Nsight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_proiler,_debugger"><span class="toc-number">1.5.3.</span> <span class="toc-text">OpenGL proiler, debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gDEBugger"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">gDEBugger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game-Engine/" title="Game_Engine">Game_Engine<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sort/" title="Sort">Sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Tony Tang. <br/>
			This is my new blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"TonyTang1990"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
