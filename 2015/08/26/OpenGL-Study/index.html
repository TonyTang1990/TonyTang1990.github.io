
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>OpenGL_Study | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL_Study">
<meta property="og:url" content="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGL_Render_Pipeline.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GLViewer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGLWindow.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingOpenGL.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingShader.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UniformVariable.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Interpolation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinateTranslation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinate2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject1.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject3.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject4.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MouseAndKeyboardStudy.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TextureConcepts.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TextureCoordinate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/BasicTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/texture1.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/texture2.jpg">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MultipleTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Ambient.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Diffuse.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularModle.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularModle2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularCalculation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PointLightFormulation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpotLight.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpotLightCutoffMapping.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShaowMapFirstPass.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShaowMapFirstPassCreate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MyTextureList.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DemoTextureList.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShadowMapFirstPassSuccessful.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShadowMapFinal.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SkyboxTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Skybox.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TangentSpaceCaculation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TangentSpaceDeduce.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TangentSpaceDeduce2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/NormalMapTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/NormalMappingAndRegularMapping.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ParallaxMappinge.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ParallaxMappinge2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Geometry_Shader_Fur.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GSBillboard.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Geometry_Transform_Feedback_Buufer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TransformFeedbackFlowchart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TransformFeedbackBufferData.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ParticleSystem.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Open3mod.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/gDEBuggerCapture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/gDEBuggerShaderInfo.PNG">
<meta property="og:updated_time" content="2016-07-08T11:35:29.580Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenGL_Study">
<meta name="twitter:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">有时候不是习惯了一个人，而是在没有认可自己之前选择了一个人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/26/OpenGL-Study/" title="OpenGL_Study" itemprop="url">OpenGL_Study</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2015-08-26T15:57:05.000Z" itemprop="datePublished"> 發表於 2015-08-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard_&&_Mouse_Control"><span class="toc-number">1.4.9.</span> <span class="toc-text">Keyboard && Mouse Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture_Mapping"><span class="toc-number">1.4.10.</span> <span class="toc-text">Texture Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light_and_Shadow"><span class="toc-number">1.4.11.</span> <span class="toc-text">Light and Shadow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Skybox"><span class="toc-number">1.4.12.</span> <span class="toc-text">Skybox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Normal_Mapping"><span class="toc-number">1.4.13.</span> <span class="toc-text">Normal Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BillBoard_And_Geometry_Shader"><span class="toc-number">1.4.14.</span> <span class="toc-text">BillBoard And Geometry Shader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Utility"><span class="toc-number">1.5.</span> <span class="toc-text">OpenGL Utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_Asset_Import_Library"><span class="toc-number">1.5.1.</span> <span class="toc-text">Open Asset Import Library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assimp"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">assimp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open3mod"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">open3mod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIMP"><span class="toc-number">1.5.2.</span> <span class="toc-text">GIMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL_Debuger"><span class="toc-number">1.5.3.</span> <span class="toc-text">GLSL Debuger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nsight"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Nsight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_proiler,_debugger"><span class="toc-number">1.5.4.</span> <span class="toc-text">OpenGL proiler, debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gDEBugger"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">gDEBugger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
		
		</div>
		
		<p><strong>时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好</strong>  — 游戏梦</p>
<p>参考书籍：<br>《OpenGL Programming Guide 8th Edition》 — Addison Wesley<br>《Fundamentals of Computer Graphics (3rd Edition)》 — Peter Shirley, Steve Marschnner<br>《Real-Time Rendering, Third Edition》 — Tomas Akenine-Moller, Eric Haines, Naty Hoffman</p>
<p><a href="http://blog.sina.com.cn/tonytang1990" target="_blank" rel="external">旧博客地址</a></p>
<p><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/">渲染相关概念学习</a></p>
<h1 id="OpenGL">OpenGL</h1><h2 id="Introdction_to_OpenGL">Introdction to OpenGL</h2><h3 id="What_is_OpenGL?">What is OpenGL?</h3><ol>
<li>OpenGL is an application programming interface – “API” for short – which is merely a software library for accessing features in graphics hardware.(访问图形硬件设备功能的API)</li>
<li>OpenGL is a “C” language library(OpenGL是一个C语言库)</li>
</ol>
<h3 id="History">History</h3><p>It was first developed at Silicon Graphics Computer Systems with Version 1,0 released in July of 1994(<a href="https://zh.wikipedia.org/zh/OpenGL" target="_blank" rel="external">wiki</a>)</p>
<h3 id="Next_Generation_OpenGL">Next Generation OpenGL</h3><p><a href="https://en.wikipedia.org/wiki/Vulkan_%28API%29" target="_blank" rel="external">Vulkan</a></p>
<h2 id="OpenGL_relative_knowledge">OpenGL relative knowledge</h2><ol>
<li><p>Understand OpenGL render pipeline<br><img src="/img/OpenGL/OpenGL_Render_Pipeline.PNG" alt="OpenGL Render Pipeline"></p>
<ol>
<li><p>Vertex Data<br> Sending Data to OpenGL</p>
</li>
<li><p>Vertex Shader<br> Process the data associated with that vertex</p>
</li>
<li><p>Tessellation Shader<br> Tessellation uses patchs to describe an object’s shape, and allows relatively simple collections of patch geometry to be tessellated to increase the number of geometric primitives providing better-looking models (eg: LOD) </p>
</li>
<li><p>Geometry Shader<br> Allows additional processing of individual geometric primitives, including creating new ones, before rasterization</p>
</li>
<li><p>Primitive Assembly<br>Organizes the vertices into their associated geometric primitives in preparation for clipping and rasterization </p>
</li>
<li><p>Clipping<br> Clip the vertex and pixels are outside of the viewport – this operation is handled automatically by OpenGL</p>
</li>
<li><p>Rasterization<br> Fragment generation. Pixels have a home in the framebuffer, while a fragment still can be rejected and never update its associated pixel location. </p>
</li>
<li><p>Fragment Shading<br> Use a fragment shading to determine the fragment’s final color, and potentially its depth value</p>
</li>
<li><p>Per-Fragment Operations<br> If a fragment successfully makes it through all of the enabled tests (eg: depth testing, stencil testing), it may be written directly to the framebuffer, updating the color of its pixel, or if blending is enabled, the fragment’s color will be combined with the pixel’s current color to generate a new color that is written into the framebuffer</p>
</li>
</ol>
<p>Note:<br>Fragment’s visibility is determined using depth testing and stencil testing<br>Pixel data is usually stored in texture map for use with texture mapping, which allows any texture stage to look up data values from one or more texture maps.</p>
</li>
<li><p><a href="http://zh.wikipedia.org/wiki/GLSL" target="_blank" rel="external">Understand OpenGL Shader Language (GLSL)</a><br> GLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。</p>
<p> 编译和执行<br> GLSL 着色器不是独立的应用程式；其需要使用 OpenGL API 的应用程式。C、C++、C#、Delphi 和 Java 皆支援 OpenGL API，且支援 OpenGL 着色语言。<br> GLSL 着色器本身只是简单的字串集，这些字串集会传送到硬件厂商的驱动程式，并从程式内部的 OpenGL API 进入点编译。着色器可从程式内部或读入纯文字档来即时建立，但必须以字串形式传送到驱动程式。</p>
<p> 工具<br> GLSL 着色器可以事先建立和测试，现有以下 GLSL 开发工具：<br> RenderMonkey - 这个软件是由 ATI 制作的，提供界面用以建立、编译和除错 GLSL 着色器，和 DirectX 着色器一样。仅能在 Windows 平台上执行。<br> GLSLEditorSample - 在 Mac OS X 上，它是目前唯一可用的程式，其提供着色器的建立和编译，但不能除错。它是 cocoa 应用程式，仅能在 Mac OS X 上执行。<br> Lumina - Lumina 是新的 GLSL 开发工具。其使用 QT 界面，可以跨平台。</p>
</li>
<li><p>OpenGL Shader Fundamentals</p>
</li>
<li><p>The color space that is used by OpenGL<br> In OpenGL, colors are represented in what’s called the RGB color space</p>
</li>
</ol>
<h2 id="OpenGL_learning_journal">OpenGL learning journal</h2><h3 id="API">API</h3><ol>
<li>查看哪些错误标志位被设置<br>了解：<br>  OpenGL在内部保留了一组错误标志位(共4个),其中每一个标志位代表一种不同类型的错误。当错误一个发生时，与这个错误对应的标志就会被设置。如果被设置的标志不止一个，glGetError仍然只返回一个唯一的值。当glGetError函数被调用时，这个值随后被清除，然后在glGetError再次被调用时将返回一个错误标志或GL_NO_ERROR为止</li>
</ol>
<p>函数：<br>Glenum glGetError(void); </p>
<ol>
<li><p>查询OpenGL的渲染引擎（OpenGL驱动程序）的生产商和版本号<br>了解：<br> OpenGL允许提供商通过它的扩展机制进行创新。为了使用特定供应商所提供的一些特定扩展功能，我们希望限制这个特定供应商所提供驱动程序的最低版本号。<br>函数：<br>const Glubyte *glGetString(GLenum name);</p>
</li>
<li><p>设置和查询管线的状态<br>了解：<br>  OpenGL使用状态模型来跟踪所有的OpenGL状态变量来实现对OpenGL渲染状态的控制<br>函数：<br>void glEnable(GLenum capability);<br>void glDisable(GLenum capability);<br>void glGet<em>(Type)v(GLenum pname, GLboolean </em>params);</p>
</li>
<li><p>查询program的一些相关信息和一些错误信息<br>了解：<br> OpenGL的pragram链接可能由于GLSL里面的一些错误导致出错，我们需要知道关于program object的一些相关错误信息，同时我们也想知道我们现有的program相关的一些信息<br>函数：<br>void glGetProgramiv(GLuint program, GLenum pname, GLint *params);</p>
</li>
<li><p>得到shader链接出错的log信息<br>了解：<br> OpenGL的shader object可能链接失败，我们需要知道shader里面出错的信息<br>函数：<br>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei <em>length, GLchar </em>infoLog);</p>
</li>
</ol>
<p>注意:<br>可以通过glGetProgramiv()去得到program的一些log相关信息，比如GL_INFO_LOG_LENGTH</p>
<h3 id="OpenGL_Knowledge:">OpenGL Knowledge:</h3><pre><code>1. "OpenGL <span class="operator"><span class="keyword">Execute</span> Model: 
    The model <span class="keyword">for</span> interpretation <span class="keyword">of</span> OpenGL commands <span class="keyword">is</span> client-<span class="keyword">server</span>. An application (the client) issues commands, which <span class="keyword">are</span> interpreted <span class="keyword">and</span> processed <span class="keyword">by</span> OpenGL (the <span class="keyword">server</span>). The <span class="keyword">server</span> may <span class="keyword">or</span> may <span class="keyword">not</span> operate <span class="keyword">on</span> the same computer <span class="keyword">as</span> the client. <span class="keyword">In</span> this sense, OpenGL <span class="keyword">is</span> network-transparent. <span class="string">"

2. "</span>client-<span class="keyword">server</span> 模式:
    OpenGL 是一种 client-<span class="keyword">server</span> 模式，当你的应用程序调用 OpenGL 函数时， 它将告诉OpenGL client， 然后 client 将渲染命令传送给 <span class="keyword">server</span>. 这里client 和 <span class="keyword">server</span>可能是不同的计算机，或是同一台计算机上的不同进程。一般来说 <span class="keyword">server</span> 是在 GPU上处理的， 而 client 是在 CPU 上处理的，这样分担了 CPU 的负担， 同时高效利用了GPU.<span class="string">"</span></span>
</code></pre><p>但如果Client和Server没在同一个机器上，我们就需要一种一种网络传输协议框架来实现他们之间的交流：<br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a></p>
<p>但X Window System里的client和server与传统的C/S模式相反，client是负责运算的，server是负责显示的。<br>但OpenGL的client和server的交流原理是与X Window System相似的</p>
<h2 id="OpenGL_Practice">OpenGL Practice</h2><h3 id="Check_supported_OpenGL_version">Check supported OpenGL version</h3><ol>
<li>Install the appropriate graphic driver which enables usage of the functionality provided.<br> check the graphic drive update.(更新显卡驱动获得最新的OpenGL版本支持)</li>
<li>Using OpenGL extensions viewer to check which OpenGL version is supported(查看当前硬件所支持的OpenGL版本)<br> <a href="http://www.realtech-vr.com/glview/download.php" target="_blank" rel="external">download website</a></li>
</ol>
<p><img src="/img/OpenGL/GLViewer.PNG" alt="OpenGL_Viewer_Info"><br>从上图可以看出我当前的电脑和显卡驱动支持最高4.4，所以在使用学习OpenGL之前一定要确认好自己电脑所能支持的版本，避免后续不必要的问题。</p>
<p>检查完所支持的OpenGL版本后，下面我们需要介绍两个在学习OpenGL时为了帮助快速学习使用OpenGL的两个重要库（Glut &amp; Glew）</p>
<h3 id="Know_what_Glut_and_Glew_are,_and_how_to_use_them">Know what Glut and Glew are, and how to use them</h3><ol>
<li><p><a href="http://zh.wikipedia.org/wiki/GLUT" target="_blank" rel="external">Glut (OpenGL Utility Toolkit)</a><br> GLUT（英文全写：OpenGL Utility Toolkit）是一个处理OpenGL程式的工具库，负责处理和底层操作系统的呼叫以及I/O，并包括了以下常见的功能：</p>
<ol>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘及鼠标的事件</li>
<li>以一个函数呼叫绘制某些常用的立体图形，例如长方体、球、以及犹他茶壶（实心或只有骨架，如glutWireTeapot()）</li>
<li><p>提供了简单选单列的实现</p>
<p>GLUT是由Mark J. Kilgard在Silicon Graphics工作时所写，此人同时也是OpenGL Programming for the X Window System以及The Cg Tutorial: The Definitive Guide to Programmable Real-Time Graphics两书的作者。</p>
<p>GLUT的两个主要目的是建立一个跨平台的函式库（事实上GLUT就是跨平台的），以及简化学习OpenGL的条件。透过GLUT编写OpenGL通常只需要增加几行额外GLUT的程式码，而且不需要知道每个不同操作系统处理视窗的API。</p>
<p>所有的GLUT函数都以glut作为开头，例如glutPostRedisplay()。</p>
</li>
</ol>
</li>
<li><a href="http://en.wikipedia.org/wiki/OpenGL_Extension_Wrangler_Library" target="_blank" rel="external">Glew ( OpenGL Extension Wrangler Library)</a><br> The OpenGL Extension Wrangler Library (GLEW) is a cross-platform C/C++ library that helps in querying and loading OpenGL extensions. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.(Glew是一个支持跨平台的C/C++库，用于运行时鉴别OpenGL扩展所支持的版本)<br> <a href="http://www.opengl.org/sdk/tools/" target="_blank" rel="external">more info for extention tools</a></li>
</ol>
<p>How to use Glu &amp; Glew?</p>
<ol>
<li>add glu.lib &amp; glew.lib into additional dependencies</li>
<li>add the directory that includes glu.h &amp; glew.h into include dirctory</li>
<li>Include GL/freeglut.h &amp; GL/glew.h in source file<br>Note:<br>if you use static link, #define FREEGLUT_STATIC before you include GL/freeglut.h, otherwise it will look for freeglut.lib. #define GLEW_STATIC for Glew.</li>
</ol>
<p>include GL/glew.h before GL/freeglut.h, otherwise, it will through “fatal error C1189: #error :  gl.h included before glew.h”</p>
<p>Note:<br>后续的学习都是基于<a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">Modern OpenGL Tutorials</a>,后续提到的一些库的源码从该网站下载</p>
<h3 id="Open_a_Window">Open a Window</h3><p>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>OpenGLWindow.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"OpenGLWindow"</span>);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/OpenGLWindow.PNG" alt="OpenGL_Window"></p>
<p>从上面可以看出我们主要是通过调用glut来初始化创建windows窗口<br>通过glut里的API我们可以去设置回调，去实现我们在渲染时期需要设置的OpenGL状态<br>上述主要有四个重要的glut API：</p>
<ol>
<li>glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA) — GLUT_DOULBE开启了双buffer渲染，这样效率更高，一个buffer用于渲染，一个buffer用于填充下一帧数据</li>
<li>glutDisplayFunc — 设置glut里的渲染回调</li>
<li>glutMainLoop — 开启glut里的window event监听</li>
<li>glutCreateWindow — 设定完相关参数后，通过此方法我们能够创建出我们想要的Windows窗口，同时OpenGL Context也在这时候被创建出来</li>
</ol>
<p>Glut还提供了更多的关于Window的功能，后续会学习使用到</p>
<h3 id="Using_OpenGL">Using OpenGL</h3><p>上一章节只是用到了glut去初始化我们最基本的Window窗口，还没真正大量用到OpenGL里API，在使用OpenGL API之前我们需要通过Glew这个工具去检查当前所支持的OpenGL版本，然后才能正确的调用对应的API。</p>
<p>使用Glew的准备工作在How to use Glu &amp; Glew?时已经提到，这里不重述了</p>
<p>因为Glew需要通过context去查找对应所支持的OpenGL版本调用，所以初始化Glew必须在创建OpenGL Context之后。</p>
<p>Note:<br>Call glewInit after glutCreateWindow call successfully</p>
<p>那这里就不得不先了解一下什么是OpenGL Context了？<br>“”OpenGL Context””<br><a href="https://open.gl/context" target="_blank" rel="external">OpenGL context, which is essentially a state machine that stores all data related to the rendering of your application. When your application closes, the OpenGL context is destroyed and everything is cleaned up.</a></p>
<p>结合wiki<a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a>的介绍，这里我理解的不是很清晰，大概是OpenGL的Context相当于Device Context(DC)相对于Windows的概念一样。Context会设定很多跟渲染相关的状态(比如是否使用双buffer，depthbuffer占多少字节，颜色模式，窗口大小等渲染需要的信息)</p>
<p>这里我们只需要知道初始化Glut和调用glutCreateWindow创建窗口后，我们的OpenGL Context就生成了.</p>
<p>这也就是为什么在初始化glew之前必须先初始化Glut和创建Windows窗口的原因。</p>
<p>进一步了解参考：<br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a></p>
<p>“”Using Glew””<br>接下来回到Glew的使用去绘制我们的第一个OpenGL圆点<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>UsingOpenGL.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_POINTS, <span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">1</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，我们初始化glew只是调用了glewInit()方法，但主要一定要在OpenGL context创建完成后调用(即glutCreateWindow窗口创建之后)</p>
<p>我们创建并使用vertext buffer主要由5个步骤：</p>
<ol>
<li>glGenBuffers() — 创建一个可用的buffer obejct</li>
<li>glBindBuffer() — 绑定buffer object到指定的target类型，target类型代表我们的buffer object包含什么样的数据用于什么样的用途</li>
<li>glBufferData() — 填充buffer数据</li>
<li>glVertexAttribPointer() — 指明如何去解析buffer里的数据，同时这里也指明了如何在shader里面访问这些数据(至于如何编写，编译，链接和使用Shader，后续会讲到。)</li>
<li>glDrawArrays() — 调用draw指明如何使用并绘制buffer里面的数据</li>
</ol>
<p>Note：<br>这里需要注意的一点，要想在Shader里访问buffer里面的attribute数据，我们需要在调用draw之前调用glEnableVertexAttribArray()来激活特定的attribute</p>
<p>final result:<br><img src="/img/OpenGL/UsingOpenGL.PNG" alt="OpenGL_Window"></p>
<h3 id="Using_Shader">Using Shader</h3><p><a href="https://en.wikipedia.org/wiki/Shader" target="_blank" rel="external">In the field of computer graphics, a shader is a computer program that is used to do shading: the production of appropriate levels of color within an image, or, in the modern era, also to produce special effects or do video post-processing.</a></p>
<p>上述是Wiki上Shader的定义。Shader是在可编程管线出现后，以程序的形式对渲染的各个阶段进行图形图像上的处理，使渲染变得更加灵活，主要作用于GPU上。</p>
<p>Shader作用于渲染的各个阶段：<br>之前在“Understand OpenGL render pipeline”有讲到各个渲染管线，这里就不再重述。可见Shader作用于大部分管线，比如：Vertex Shader（负责vertex数据处理），Tessellation Shader（负责以图形patch为单位的处理，用于描述物体形状数据，LOD就是在这个阶段实现的），Geometry Shader（以整个图形原件数据作为输入做处理，好比batch rendering可在这个阶段实现），Fragment Shading（以fragment(片元)数据作为输入做处理）</p>
<p>Shader Language在前面的“Understand OpenGL Shader Language”有讲到，这里就不重述了。</p>
<p>从上可见Shader在可编程管线的今天有着多么重要的作用。<br>接下来让我们看看在OpenGL中如何使用Shader吧。</p>
<p>使用Shader主要有下列几个步骤：</p>
<ol>
<li>Create a shader object – glCreateShader(GLenum type)（创建shader对象）</li>
<li>Compile your shader source into the object – glShaderSource(<strong>**</strong>)  glCompileShader(<em>*</em>)（编译shader文件，存储到shader对象中）</li>
<li>Verify that your shader compiled successfully – glGetShaderInfoLog(<em>*</em>)（检查shader编译是否成功并获取错误信息）</li>
<li>Create a shader program – glCreateProgram(void)（创建shader程序）</li>
<li>Attach the appropriate shader objects to the shader program – glAttachShader(GLuint program, Gluint shader)（附加多个shader对象到shader程序中）</li>
<li>Link the shader program – glLinkProgram(GLuint program)（链接shader程序）</li>
<li>Verify that the shader link phase completed successfully – glGetProgramiv() &amp; glGetProgramInfoLog(<em>**</em>)（检查shader程序链接是否成功并获取错误信息）</li>
<li>Use the shader for vertex or fragment processing – glUseProgram(GLuint program)（使用shader程序做顶点处理或片元处理）</li>
</ol>
<p>Shader出错后因为我们快速退出了程序，所以很难看到console的错误信息，所以最好的方式是把错误信息写入文本文件以供后续查看。Utils.h是关于编译和使用Shader并打印错误信息到文本的实现。<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_util.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>Utils.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serializationShaderCompileLog</span><span class="params">(GLuint prog, GLuint shader, GLenum type, <span class="keyword">char</span> *<span class="built_in">log</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *stage_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">switch</span>(type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_VERTEX_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_GEOMETRY_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_GEOMETRY_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_FRAGMENT_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_FRAGMENT_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"program:"</span>&lt;&lt;prog&lt;&lt;<span class="string">"-shader:"</span>&lt;&lt;shader&lt;&lt;<span class="string">"-stage:"</span>&lt;&lt;stage_name&lt;&lt;<span class="string">" compile log:"</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">log</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *file_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(file_name,stage_name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(file_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(file_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;stage_name;</span><br><span class="line">	write_to_file&lt;&lt;<span class="string">" compiled log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;<span class="built_in">log</span>;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []stage_name;</span><br><span class="line">	<span class="keyword">delete</span> []file_name;</span><br><span class="line"></span><br><span class="line">	stage_name = <span class="literal">nullptr</span>;</span><br><span class="line">	file_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">program_log_serialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> program,<span class="keyword">char</span> <span class="keyword">const</span> *program_name,<span class="keyword">bool</span> is_console_print)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLchar *program_linked_log = <span class="literal">NULL</span>;</span><br><span class="line">	GLint log_length = <span class="number">0</span>;</span><br><span class="line">	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;log_length);</span><br><span class="line">	program_linked_log = <span class="keyword">new</span> <span class="keyword">char</span>[log_length];</span><br><span class="line"></span><br><span class="line">	GLsizei program_linked_log_real_length;</span><br><span class="line">	glGetProgramInfoLog(program, log_length, &amp;program_linked_log_real_length, program_linked_log);</span><br><span class="line">	<span class="keyword">if</span>(is_console_print)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_name&lt;&lt;<span class="string">" linked log info:"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_linked_log&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> file_name_length = <span class="built_in">strlen</span>(program_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *log_file_whole_name = <span class="keyword">new</span> <span class="keyword">char</span>[file_name_length + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(log_file_whole_name,<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(program_name));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(log_file_whole_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(log_file_whole_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;*program_name + <span class="string">" linked log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;program_linked_log;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []program_linked_log;</span><br><span class="line">	<span class="keyword">delete</span> []log_file_whole_name;</span><br><span class="line"></span><br><span class="line">	program_linked_log = <span class="literal">nullptr</span>;</span><br><span class="line">	log_file_whole_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* pshadertext, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLuint shaderobj = glCreateShader(shadertype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(shaderobj == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error create shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> GLchar *p[<span class="number">1</span>];</span><br><span class="line">	p[<span class="number">0</span>] = pshadertext;</span><br><span class="line">	GLint lengths[<span class="number">1</span>];</span><br><span class="line">	lengths[<span class="number">0</span>] = <span class="built_in">strlen</span>(pshadertext);</span><br><span class="line"></span><br><span class="line">	glShaderSource(shaderobj, <span class="number">1</span>, p, lengths);</span><br><span class="line">	glCompileShader(shaderobj);</span><br><span class="line"></span><br><span class="line">	GLint success;</span><br><span class="line">	glGetShaderiv(shaderobj, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		GLchar infolog[<span class="number">1024</span>];</span><br><span class="line">		glGetShaderInfoLog(shaderobj, <span class="number">1024</span>, <span class="literal">NULL</span>, infolog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error compiling shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">		serializationShaderCompileLog(shaderprogram, shaderobj, shadertype, infolog);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glAttachShader(shaderprogram, shaderobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CompileShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* psfilename, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shaderprogram == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error creating shader program"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!ReadFile(psfilename, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;psfilename&lt;&lt;<span class="string">" is not exit"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(shadertype)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_VERTEX_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_GEOMETRY_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_FRAGMENT_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkAndUseShaderProgram</span><span class="params">(GLuint shaderprogram)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLint success = <span class="number">0</span>;</span><br><span class="line">	GLchar errorlog[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	glLinkProgram(shaderprogram);</span><br><span class="line"></span><br><span class="line">	glGetProgramiv(shaderprogram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(success == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error linking shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		program_log_serialization(shaderprogram, <span class="string">"LinkStatus"</span>, <span class="literal">true</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glValidateProgram(shaderprogram);</span><br><span class="line">	glGetProgramiv(shaderprogram, GL_VALIDATE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Invalid shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glUseProgram(shaderprogram);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UsingShader.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Utils.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line">GLuint ShaderProgram;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pVSFileName = <span class="string">"vsshader.vs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pFSFileName = <span class="string">"fsshader.fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">3</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(-<span class="number">1.0f</span>,-<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">1</span>] = Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">2</span>] = Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	ShaderProgram = glCreateProgram();</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pVSFileName, GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pFSFileName, GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">	LinkAndUseShaderProgram(ShaderProgram);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(Position.x,Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final effect:<br><img src="/img/OpenGL/UsingShader.PNG" alt="UsingShader"></p>
<p>上述只使用到了Vertex Shader和Framgment Shader, 后续还会讲到其他Shader的使用。</p>
<h3 id="Uniform_Variables">Uniform Variables</h3><p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are used to communicate with your vertex or fragment shader from “outside”.</a></p>
<p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are read-only and have the same value among all processed vertices. You can only change them within your C++ program.</a></p>
<p>从上面可以看出Uniform变量主要用于Vertex和Fragment Shader,并且对于所有传入的顶点值都不变，只能通过C++一侧去改变Uniform Variable的值。</p>
<p>接下来我们看看Uniform Variable是如何应用在Shader中的：<br>使用Uniform Variable主要有以下几个步骤：</p>
<ol>
<li><p>Obtain uniform variable location after Link Shader Program</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScaleLocation = glGetUniformLocation(ShaderProgram, <span class="string">"gScale"</span>);</span><br><span class="line"></span><br><span class="line">assert(gScaleLocation != <span class="number">0xFFFFFFFF</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set uniform variable value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScale += <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">glUniform1f(gScaleLocation, sinf(gScale));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Define uniform variable in Shader</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final result:<br><img src="/img/OpenGL/UniformVariable.PNG" alt="UniformVariable"></p>
<h3 id="Interpolation">Interpolation</h3><p><a href="http://ogldev.atspace.co.uk/www/tutorial09/tutorial09.html" target="_blank" rel="external">the interpolation that the rasterizer performs on variables that come out of the vertex shader. </a></p>
<p>在OpenGL的渲染管线里，在Fragment Shader执行之前会进行rasterizer，rasterizer会计算出各个三角形顶点之间的像素颜色数据，然后我们可以通过Fragment Shader对于光栅化的后颜色数据做进一步的处理。</p>
<p>这一章节主要看看我们是如何在Vertex Shader和Fragment Shader中如何对顶点数据和各像素信息做处理和数据传递的。(这里我们直接在VS中算出颜色信息直接传递到FS中去做处理)<br>要想从VS传递数据到FS，我们需要在Vertex Shader中定义关键词out的变量，并在Fragment Shader定义对应的关键词in的变量。</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">out vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">	</span><br><span class="line">	Color = <span class="built_in">abs</span>(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/Interpolation.PNG" alt="Interpolation"></p>
<p>从上面可以看出在VS中算出颜色信息后，经过光栅化，三角形顶点之间的颜色信息被计算出来，最终传到FS中并作为最终颜色信息输出到屏幕上。</p>
<h3 id="Coordinate_Transformations_&amp;_Perspective_Projection">Coordinate Transformations &amp; Perspective Projection</h3><p>这一章主要是学习矩阵在3D图形中的使用和了解物体时怎样被显示到正确的屏幕位置的。</p>
<p>在解释如何使用矩阵去进行向量变换之前，我们先来看看为什么矩阵可以实现向量变换？<br>下列学习参考《3D 数学基础：图形与游戏开发》<br>一个3维向量可以解释成3个基向量上平移后的组合(p,q,r为三个基向量)：<br>V = x × p + y × q + z × r;</p>
<p>当一个向量乘以矩阵的时候：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    [ p ]   [px  py  pz]</span><br><span class="line">M = [ q ] = [qx  qy  qz]</span><br><span class="line">    [ r ]   [rx  ry  rz]</span><br><span class="line"></span><br><span class="line">V = [x y z]</span><br><span class="line"></span><br><span class="line">                [px  py  pz]</span><br><span class="line">V * M = [x y z] [qx  qy  qz] = [x*px + y*qx + z*rx   x*py + y*qy + z*ry  x*pz + y*qz + z*rz] = x*p + y*q + z*r</span><br><span class="line">                [rx  ry  rz]</span><br></pre></td></tr></table></figure></p>
<p>“如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”</p>
<p>从上面我们可以看出矩阵是如何做到对于向量的坐标系转换的。</p>
<p>那么为什么我们后面用到的矩阵都是4×4而不是3×3的了？<br>4<em>4的矩阵我们叫做齐次矩阵。齐次矩阵出现的原因主要是除了记法方便，更重要的是因为3</em>3的变换矩阵只能表示线性变换，而4*4齐次矩阵能够表示线性变换和非线性变换。</p>
<p>那么这里我们来了解下什么是线性变换？<br>线性变换的满足下列公式：<br>F(a+b) = F(a) + F(b)<br>F(ka) = k × F(a)</p>
<p>因为线性变换不包含平移，所以这也是4×4齐次矩阵的出现的原因。</p>
<p>了解了使用矩阵的原因和为什么使用4×4齐次矩阵的原因后，让我们来看看，我们是如何通过矩阵来实现3D图形里的实现物体的坐标系变换的。<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)</p>
<p>因为矩阵乘法满足结合律<br>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × (M(m-w) × M(w-v) × M(v-p)) = V * N<br>所以我们只需要求出所有坐标系变换矩阵的乘积后再对V进行操作即可。</p>
<p>因为单个矩阵存储着一系列的变换，而这些变换可以通过多个单个变换组合而成，所以下列式子是成立的<br>M = S(scale) × R(rotation) × T(translation)</p>
<p>但这里有个比较关键的点，S,R,T直接的乘法顺序，矩阵是不满足交换律的，我们必须按S <em> R </em> T的顺序，原因参考下面：<br><a href="https://msdn.microsoft.com/en-us/library/eews39w7%28v=vs.110%29.aspx" target="_blank" rel="external">One reason order is significant is that transformations like rotation and scaling are done with respect to the origin of the coordinate system. Scaling an object that is centered at the origin produces a different result than scaling an object that has been moved away from the origin. Similarly, rotating an object that is centered at the origin produces a different result than rotating an object that has been moved away from the origin.</a></p>
<p>从上面可以看出，之所必须按S <em> R </em> T的顺序是因为S和R都是针对坐标系原点进行的，一旦先执行T，那么相对于坐标系原点的位置就会有所变化，这之后再做S和R就会出现不一样的表现。</p>
<p>因为OpenGL是列向量是左乘，所以在OpenGL中顺序如下：<br>V’ = T × R × S × V</p>
<p>DX中顺序如下：<br>V’ = V × S × R × T</p>
<p>获取最终的M(m-w)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetWorldTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f ScaleTrans, RotateTrans, TranslationTrans;</span><br><span class="line"></span><br><span class="line">    ScaleTrans.InitScaleTransform(m_scale.x, m_scale.y, m_scale.z);</span><br><span class="line">    RotateTrans.InitRotateTransform(m_rotateInfo.x, m_rotateInfo.y, m_rotateInfo.z);</span><br><span class="line">    TranslationTrans.InitTranslationTransform(m_worldPos.x, m_worldPos.y, m_worldPos.z);</span><br><span class="line"></span><br><span class="line">    m_Wtransformation = TranslationTrans * RotateTrans * ScaleTrans;</span><br><span class="line">    <span class="keyword">return</span> m_Wtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)<br>我们知道了M(m-w)是如何计算出来的了，接下来我们要了解M(w-v) — 世界坐标系到观察坐标系<br>在了解如何从世界坐标系转换到观察坐标系之前我们先来看看摄像机的定义：<br>位置 — (x,y,z)<br>N — The vector from the camera to its target.（look at 朝向）<br>V — When standing upright this is the vector from your head to the sky.(垂直于N向上的向量)<br>U — This vector points from the camera to its “right” side”.(在N和V定了之后可以算出Camera的向右的向量)</p>
<p>摄像机坐标系和世界坐标系：<br><img src="/img/OpenGL/CameraCoordinateTranslation.PNG" alt="CameraCoordinateTranslation"></p>
<p>要想得到物体从世界坐标系转换到摄像机坐标系，其实就是个坐标系转换的问题。<br>我们首先把摄像机移动到世界坐标原点(移动摄像机位置即可)：<br>[ 1 0 0 -x ]<br>[ 0 1 0 -y ]<br>[ 0 0 1 -z ]<br>[ 0 0 0  1 ]</p>
<p>这样一来考虑如何变化坐标系即可：<br><img src="/img/OpenGL/CameraCoordinate2.PNG" alt="CameraCoordinate2"><br>通过N,V,U，我们已经能够得出X(camera),Y(camera),Z(camera)3个基向量了。<br>还记得我们之前说的 — “如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”<br>所以：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ Ux Uy Uz <span class="number">0</span> ]    [X(world)]    [X(camera)]</span><br><span class="line">[ Vx Vy Vz <span class="number">0</span> ]    [Y(world)]    [Y(camera)]</span><br><span class="line">[ Nx Ny Nz <span class="number">0</span> ] *  [Z(world)] =  [Z(camera)]</span><br><span class="line">[ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]    [    <span class="number">1</span>   ]    [     <span class="number">1</span>   ]</span><br></pre></td></tr></table></figure></p>
<p>结合前面提到的先把摄像机移动到世界原点，得出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         [ Ux Uy Uz <span class="number">0</span> ]   [ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> -x ]</span><br><span class="line">M(w-v) = [ Vx Vy Vz <span class="number">0</span> ] * [ <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> -y ]</span><br><span class="line">         [ Nx Ny Nz <span class="number">0</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> -z ]</span><br><span class="line">         [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span> ]</span><br></pre></td></tr></table></figure></p>
<p>M(w-v)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitTranslationTransform(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">&#123;</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>; m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">3</span>] = x;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">3</span>] = y;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>; m[<span class="number">2</span>][<span class="number">3</span>] = z;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4f::InitCameraTransform(<span class="keyword">const</span> Vector3f&amp; Target, <span class="keyword">const</span> Vector3f&amp; Up)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f N = Target;</span><br><span class="line">    N.Normalize();</span><br><span class="line">    Vector3f U = Up;</span><br><span class="line">    U.Normalize();</span><br><span class="line">    U = U.Cross(N);</span><br><span class="line">    Vector3f V = N.Cross(U);</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = U.x;   m[<span class="number">0</span>][<span class="number">1</span>] = U.y;   m[<span class="number">0</span>][<span class="number">2</span>] = U.z;   m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = V.x;   m[<span class="number">1</span>][<span class="number">1</span>] = V.y;   m[<span class="number">1</span>][<span class="number">2</span>] = V.z;   m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = N.x;   m[<span class="number">2</span>][<span class="number">1</span>] = N.y;   m[<span class="number">2</span>][<span class="number">2</span>] = N.z;   m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetViewTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f CameraTranslationTrans, CameraRotateTrans;</span><br><span class="line"></span><br><span class="line">    CameraTranslationTrans.InitTranslationTransform(-m_camera.Pos.x, -m_camera.Pos.y, -m_camera.Pos.z);</span><br><span class="line">    CameraRotateTrans.InitCameraTransform(m_camera.Target, m_camera.Up);</span><br><span class="line">    </span><br><span class="line">    m_Vtransformation = CameraRotateTrans * CameraTranslationTrans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Vtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来M(w-v)也就实现了，接下来让我们看看M(v-p)是如何计算出来的吧。<br>M(v-p)这的p有多种投影方式，这里我只以Perspective Projection为例。<br>在转换到Camera坐标系后，我们还需要通过透视投影才能将3D物体映射到2D平面上。<br>Perspective Projection主要由下列四部分决定：</p>
<ol>
<li>The aspect ratio - the ratio between the width and the height of the rectangular area which will be the target of projection.</li>
<li>The vertical field of view.</li>
<li>The location of the near Z plane.</li>
<li>The location of the far Z plane.</li>
</ol>
<p>这一章的推导可以参考<a href="http://www.cnblogs.com/graphics/archive/2012/07/25/2582119.html" target="_blank" rel="external">透视投影详解</a><br>一开始推导过程中不明白的一点是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           1</span><br><span class="line">Z'' = a * --- + b</span><br><span class="line">           Pz</span><br></pre></td></tr></table></figure></p>
<p>后来看了《Mathematics for 3D Game Programming and Computer Grahpics 3rd section》的5.4.1 Depth Interpolation后明白了，光栅化的时候对于深度的运算证明了是对Z的倒数进行插值来得到Z的值的。<br>所以上述公式是成立的。</p>
<p>经过一系列推导后，我们得出了：<br><img src="/img/OpenGL/PerspectiveProject1.PNG" alt="PerspectiveProject1"><br><img src="/img/OpenGL/PerspectiveProject2.PNG" alt="PerspectiveProject2"><br><img src="/img/OpenGL/PerspectiveProject3.PNG" alt="PerspectiveProject3"><br><img src="/img/OpenGL/PerspectiveProject4.PNG" alt="PerspectiveProject4"></p>
<p>M(v-p)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitPersProjTransform(<span class="keyword">const</span> PersProjInfo&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ar         = p.Width / p.Height;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> zRange     = p.zNear - p.zFar;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFOV = tanf(ToRadian(p.FOV / <span class="number">2.0f</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>/(tanHalfFOV * ar); m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>/tanHalfFOV; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">2</span>][<span class="number">2</span>] = (-p.zNear - p.zFar)/zRange ; m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2.0f</span>*p.zFar*p.zNear/zRange;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;            m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0.0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Keyboard_&amp;&amp;_Mouse_Control">Keyboard &amp;&amp; Mouse Control</h3><p>这一章节主要是讲通过Glut提供的API如何去响应键盘和鼠标的控制。<br>本章节里面主要用到了两个类：</p>
<ol>
<li>Pipeline</li>
<li>Camera</li>
</ol>
<p>Pipeline主要是针对上一章节我们对于如何通过矩阵变化把物体显示到2D平面上的抽象：<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × M(m-w) × M(w-v) × M(v-p) = V × N</p>
<p>Pipeline只要知道了物体S,R,T信息就可以得出M(m-w)，知道了Camera信息就可以得出M(w-v),知道了透视投影信息就可以得出M(v-p)。</p>
<p>我们通过修改摄像机的相关信息得出在移动摄像机后的N,并作用于物体，这样一来就能使物体显示在正确位置了。</p>
<p>而Camera类是对摄像机的抽象。</p>
<p>Pipeline和Camera的源代码可在<a href="http://ogldev.atspace.co.uk/" target="_blank" rel="external">Modern OpenGL Tutorials</a>下载</p>
<p>这里我只关心针对键盘和鼠标的响应的相关代码：<br>Glut里针对键盘和鼠标的API主要是下列几个：</p>
<ol>
<li>glutSpecialFunc() — 主要是针对特殊按键比如F1</li>
<li>glutKeyboardFunc() — 主要是针对普通按键比如A,B,C……</li>
<li>glutPassiveMotionFunc() — 主要是针对在没有鼠标按键被按下的情况下，鼠标在窗口内移动的情况</li>
<li>glutMotionFunc() — 主要是针对在鼠标按键被按下的情况下，鼠标在窗口内移动的情况</li>
</ol>
<p>相关代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecialKeyboardCB</span><span class="params">(<span class="keyword">int</span> Key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    OGLDEV_KEY OgldevKey = GLUTKeyToOGLDEVKey(Key);</span><br><span class="line">    pGameCamera-&gt;OnKeyboard(OgldevKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">KeyboardCB</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">            glutLeaveMainLoop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PassiveMouseCB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pGameCamera-&gt;OnMouse(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallbacks</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">    glutSpecialFunc(SpecialKeyboardCB);</span><br><span class="line">    glutPassiveMotionFunc(PassiveMouseCB);</span><br><span class="line">    glutKeyboardFunc(KeyboardCB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/MouseAndKeyboardStudy.PNG" alt="MouseAndKeyboardStudy"></p>
<h3 id="Texture_Mapping">Texture Mapping</h3><p>“Textures are composed of texels, which often contain color values.”</p>
<p>“Textures are bound to the OpenGL context via texture units, which are represented as binding points named GL_TEXTURE0 through GL_TEXTUREi where i is one less than the number of texture units supported by the implementation.”</p>
<p>The textures are accessed via sampler variables which were declared with dimensionality that matches the texture in shader</p>
<p>在真正接触Texutre之前，让我们理解下下列几个重要的概念：</p>
<ol>
<li><p>Texture object – contains the data of the texture image itself, i.e. the texels（可以看出Texture object才是含有原始数据信息的对象）</p>
</li>
<li><p>Texture unit – texture object bind to a ‘texture unit’ whose index is passed to the shader. So the shader reaches the texture object by going through the texture unit.（我们访问texture数据信息并不是通过texture object，而是在shader里通过访问特定索引的texture unit去访问texture object里的数据）</p>
</li>
<li><p>Sampler Object – configure it with a sampling state and bind it to the texture unit. When you do that the sampler object will override any sampling state defined in the texture object.（Sampler Object一些sampling的配置信息，当用于texture object时会覆盖texture object里的原始sampler设定）</p>
</li>
<li><p>Sampler uniform – corresponding to handle of texture unit(用于在Shader里访问texture unit，texture unit和texture object绑定，也就间接的访问了texture的原始数据)</p>
</li>
</ol>
<p>Relationship between texture object, texture unit, sampler object and sampler uniform<br><img src="/img/OpenGL/TextureConcepts.png" alt="RelationshipBetweenThem"></p>
<p>因为OpenGL没有提供从图片加载texture的API，所以这里我们需要使用第三方库来完成这项工作，这里教程上使用的是ImageMagick。<br>ImageMagick主要是为了从多种格式的资源文件中读取原始数据，在我们指定glTexImage2D()的原始数据的时候提供所在内存地址。</p>
<p>Steps to use texture mapping:</p>
<ol>
<li><p>Create a texture object and load texel data into it<br>glGenTextures() — gen texture object<br>glBindTexture() — Tells OpenGL the texture object we refer to in all the following texture related calls, until a new texture object is bound.<br>glTexImage2D() — load texel data into texture object</p>
</li>
<li><p>Include texture coordinates with your vertices</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vertex Vertices[<span class="number">4</span>] = &#123; Vertex(Vector3f(-<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.5773f</span>), Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">0.0f</span>, -<span class="number">1.0f</span>, -<span class="number">1.15475f</span>), Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.5773f</span>),  Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),      Vector2f(<span class="number">0.5f</span>, <span class="number">1.0f</span>)) &#125;;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把顶点对应的纹理坐标信息写到vertex数据里</span></span><br><span class="line"><span class="comment">//说道纹理坐标就不得不提一下Texture UV纹理坐标了，Texture的图片被映射到0-1的二维坐标，图见后面：</span></span><br><span class="line"></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), <span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">const</span> GLvoid*)<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后通过指定如何解析顶点数据里面的的数据在Shader里访问vertex的texture纹理坐标信息去sample出texture数据信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Associate a texture sampler with each texture map you intend to use in your shader<br>glTexParameterf() — Texture采样方式的配置<br>还记得我们之前讲到的Sampler object吗？这里的配置就好比我们在sampler object里配置后再作用于特定的texture object<br>这里我就不说关于采样方式配置相关的内容了（采样方式会决定最终像素的计算方式），这里值得一提的是mipmap的概念。<br>mipmap主要是由于物体在场景中因为距离的缘故会在屏幕显示的大小有变化，如果我们在物体很远，只需要显示很小一块的时候还依然采用很大的纹理贴图，最终显示在屏幕上的纹理会很不清晰（失真）。为了解决这个问题，mipmap应运而生，通过事先生成或指定多个级别的同一纹理贴图，然后在程序运作的过程中通过计算算出应该使用哪一个等级的纹理贴图来避免大纹理小色块失真的问题。<br>我们可以手动通过：<br>glTexStorage2D() &amp;&amp; glTexSubImage2D() 去手动指定各级纹理贴图<br>也可以通过：<br>glGenerateMipmap() — 自动去生成对应的mipmap纹理贴图<br>而程序在实际运作过程中如何去计算Mipmap Level这里就不做介绍了，详细参考《OpenGL Programming Guide 8th Edition》的Calculating the Mipmap章节<br>相关函数：<br>textureLod()<br>textureGrad()</p>
</li>
<li><p>Active texture unit and bind texture object to it<br>glActiveTexture() — 激活特定的texture unit然后绑定特定texture object到特定texture unit上<br>glBindTexture() — 绑定特定的texture object到texture unit上</p>
</li>
<li><p>Retrieve the texel values through the texture sampler from your shader<br>首先我们在程序中指定了我们即将访问的Texture unit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gSampler = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler"</span>);</span><br><span class="line">assert(gSampler != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">glUniform1i(gSampler, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Note:<br>“The important thing to note here is that the actual index of the texture unit is used here, and not the OpenGL enum GL_TEXTURE0 (which has a different value).”</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	TexCoord0 = TexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = texture2D(gSampler, TexCoord0.xy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出我们在fragment shader里，通过传入的gSampler确认了使用哪一个texture unit，通过传入的TexCoord0确认了对应的纹理坐标信息去获取对应的texture信息，然后最终通过texture2D从texture里取得了特定的颜色信息作为输出，就这样纹理图片的信息就作用在了三角形上并显示出来。</p>
<p><img src="/img/OpenGL/TextureCoordinate.PNG" alt="TextureCoordinate"></p>
<p>final result:<br><img src="/img/OpenGL/BasicTexture.PNG" alt="BasicTexture"></p>
<p>下面我简单测试了下两个Texture计算出最终纹理信息：<br>TextureStudy.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeTextureInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gSampler = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler"</span>);</span><br><span class="line">	assert(gSampler != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">	gSampler2 = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler2"</span>);</span><br><span class="line">	assert(gSampler2 != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Specify the inder of texture unit we will use in shader</span></span><br><span class="line">	glUniform1i(gSampler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glUniform1i(gSampler2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	pTexture = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/texture1.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pTexture-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pTexture2 = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/texture2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pTexture2-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallbackCB</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	pTexture-&gt;Bind(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	pTexture2-&gt;Bind(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = <span class="number">0.5</span> * texture2D(gSampler, TexCoord0.xy) + <span class="number">0.5</span> * texture2D(gSampler2, TexCoord0.xy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始图片分别为：<br><img src="/img/OpenGL/texture1.png" alt="Texture1"><br><img src="/img/OpenGL/texture2.jpg" alt="Texture2"></p>
<p>final result:<br><img src="/img/OpenGL/MultipleTexture.PNG" alt="MultipleTexture"></p>
<p>Point Sprites:<br>待理解学习……</p>
<p>Rendering to Texture Maps:<br>待理解学习……</p>
<p>Sumary：</p>
<ol>
<li><p>Use immutable texture storage for textures wherever possible – When a texture is marked as immutable, the OpenGL implementation can make certain assumptions about the validity of a texture object （尽量使用不可变的texture storage， 这样OpenGL可以确保texture的有效性）</p>
</li>
<li><p>Create and initialize the mipmap chain for textures unless you have a good reason not to – improve the image quality of your program’s rendering, but also will make more efficient use of the caches in the graphics processor （为了渲染效率，减轻GPU负担，尽可能为texture创建mipmap）</p>
</li>
<li><p>Use an integer sampler in your shader when your texture data is an unnormalized integer and you intend to use the integer values it contains directly in the shader （尽量在shader里使用integer类型的sampler）</p>
</li>
</ol>
<p>Note:<br>“The maximum number of texture units supported by OpenGL<br>can be determined by retrieving the value of the GL<em>MAX_COMBINED</em><br>TEXTURE_IMAGE_UNITS constant, which is guaranteed to be at least 80 as<br>of OpenGL 4.0.”</p>
<p>Proxy texture – used to test the capabilities of the OpenGL implementation when certain limits are used in combination with each other.</p>
<h3 id="Light_and_Shadow">Light and Shadow</h3><p>光源类型：</p>
<ol>
<li>Ambient Light (环境光) — 环境光只影响ambient</li>
<li>Directional Light (方向光) — 方向光会影响diffuse &amp; specular</li>
<li>Point Light (点光源) — 与方向光的区别是有attenuation(衰弱)而且点光源照射物体的表面的方向不一样，同样会影响diffuse &amp; specular</li>
</ol>
<p>传统的光照组成：<br>Ambient (环境光) — 与光照的方向无关<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FragColor = texture2D(gSampler, TexCoord0.xy) *</span><br><span class="line">        vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *</span><br><span class="line">        gDirectionalLight.AmbientIntensity;</span><br></pre></td></tr></table></figure></p>
<p>因为环境光与光照方向无关，只需考虑方向光的颜色和方向光所占比重，所以基本上主要计算归结于上述运算。</p>
<p>final effect:<br><img src="/img/OpenGL/Ambient.PNG" alt="Ambient"></p>
<p>Note:<br>这里源代码里有个错误，在子类重写虚函数的KeyboardCB的时候，由于参数写的不对，没能正确重写该虚函数而没有被调到。<br>错误：<br>virtual void KeyboardCB(OGLDEV_KEY OgldevKey);<br>正确：<br>virtual void KeyboardCB(OGLDEV_KEY OgldevKey, OGLDEV_KEY_STATE OgldevKeyState = OGLDEV_KEY_STATE_PRESS)</p>
<p>Diffuse (漫反射光) — 与光照的方向和顶点normal有关<br>因为漫反射光要考虑光照的方向和物体的顶点法线，所以我们需要在shader里进行计算之前要把顶点的法线算出来然后传入Shader进行计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcNormals</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* pIndices, <span class="keyword">unsigned</span> <span class="keyword">int</span> IndexCount, Vertex* pVertices, <span class="keyword">unsigned</span> <span class="keyword">int</span> VertexCount)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; IndexCount ; i += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index0 = pIndices[i];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index1 = pIndices[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index2 = pIndices[i + <span class="number">2</span>];</span><br><span class="line">        Vector3f v1 = pVertices[Index1].m_pos - pVertices[Index0].m_pos;</span><br><span class="line">        Vector3f v2 = pVertices[Index2].m_pos - pVertices[Index0].m_pos;</span><br><span class="line">        Vector3f Normal = v1.Cross(v2);</span><br><span class="line">        Normal.Normalize();</span><br><span class="line"></span><br><span class="line">        pVertices[Index0].m_normal += Normal;</span><br><span class="line">        pVertices[Index1].m_normal += Normal;</span><br><span class="line">        pVertices[Index2].m_normal += Normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; VertexCount ; i++) &#123;</span><br><span class="line">        pVertices[i].m_normal.Normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#version 330</span><br><span class="line"></span><br><span class="line">layout (location = 0) in vec3 Position;</span><br><span class="line">layout (location = 1) in vec2 TexCoord;</span><br><span class="line">layout (location = 2) in vec3 Normal;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line">uniform mat4 gWorld;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line">out vec3 Normal0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = gWVP * vec4(Position, 1.0);</span><br><span class="line">    TexCoord0 = TexCoord;</span><br><span class="line">    Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意“Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;” — 因为我们对于顶点法线的计算是基于物体没有移动变化之前的，所以我们真正计算所用的顶点法线需要通过世界坐标系矩阵的转换。</p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line">in vec3 Normal0;                                                                    </span><br><span class="line">                                                                                    </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">struct</span> DirectionalLight                                                             </span><br><span class="line">&#123;                                                                                   </span><br><span class="line">    vec3 Color;                                                                     </span><br><span class="line">    <span class="keyword">float</span> AmbientIntensity;                                                         </span><br><span class="line">    <span class="keyword">float</span> DiffuseIntensity;                                                         </span><br><span class="line">    vec3 Direction;                                                                 </span><br><span class="line">&#125;;                                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line">uniform DirectionalLight gDirectionalLight;                                         </span><br><span class="line">uniform sampler2D gSampler;                                                         </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    vec4 AmbientColor = vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *                       </span><br><span class="line">                        gDirectionalLight.AmbientIntensity;                         </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">float</span> DiffuseFactor = dot(normalize(Normal0), -gDirectionalLight.Direction);    </span><br><span class="line">                                                                                    </span><br><span class="line">    vec4 DiffuseColor;                                                              </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (DiffuseFactor &gt; <span class="number">0</span>) &#123;                                                        </span><br><span class="line">        DiffuseColor = vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *                        </span><br><span class="line">                       gDirectionalLight.DiffuseIntensity *                         </span><br><span class="line">                       DiffuseFactor;                                               </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                          </span><br><span class="line">        DiffuseColor = vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                                            </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    FragColor = texture2D(gSampler, TexCoord0.xy) *                                 </span><br><span class="line">                (AmbientColor + DiffuseColor);                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从“float DiffuseFactor = dot(normalize(Normal0), -gDirectionalLight.Direction);”可以看出，光照的方向和顶点法线之间的角度直接决定了漫反射光所占的比重。<br>参见<a href="https://en.wikipedia.org/wiki/Lambert&#39;s_cosine_law" target="_blank" rel="external">Lambert’s cosine law</a></p>
<p>final effect:<br><img src="/img/OpenGL/Diffuse.PNG" alt="Diffuse"></p>
<p>Note:<br>这里我按照官网和源代码的方式按自己的方式写了，但不知道为何DiffuseFactor得出的值当我去做if else判断等，无论是&gt;0,&lt;0,==0都不会进去，都只会进入最终的else。<br>我通过gDEBugger查看了uniform的值没有问题，C++那一侧所有的相关计算的值也都正确，这里弄了半天也没有解决，本来准备用Nsight调试GLSL的，发现我的笔记本好像不被支持。<br>个人最终认为是顶点的法线在传递给Shader的时候出问题了，导致dot之后计算DiffuseFactor出问题，虽然在VS一侧下的断点查看normal是正确的，但不确定为什么shader一侧获得的值会有问题。（这一结论主要是因为同样的shader代码在加载现有模型的时候起作用发现的）</p>
<p>Specular (镜面反射光) — 与光照的方向和eye观察还有顶点normal有关<br>Specular在Diffuse的基础上，还要多考虑一个因素（观察者所在位置，如果观察者正好在反光处，那么该观察点就会比在其他位置的观察点观察同一位置的看起来更亮）。但现实中并不是所有物体都有这一特性，所以Specular更针对物体材质而言而非光线本身。</p>
<p>看一下下图：<br><img src="/img/OpenGL/SpecularModle.PNG" alt="SpecularModle"><br>I是光线入射方向<br>N是平面法线<br>R是完美反射后的光线<br>V是观察者观察方向<br>a是观察者方向与完美反射光线的夹角<br>从上图可以看出当观察者所在观察角度V与R越接近时，我们可以理解为观察者观察该点会达到最大量值</p>
<p>我们计算出R主要是通过I和N和-N之间的计算：<br>详情见下图：<br><img src="/img/OpenGL/SpecularModle2.PNG" alt="SpecularModle2"><br>R = I + V<br>V = 2 <em> N </em> dot(-N,I)<br>这里值得一提的是OpenGL里提供了reflect方法，通过光线和平面法线就能直接算出反射R</p>
<p>让我们直接看一下Specular的计算公式：<br><img src="/img/OpenGL/SpecularCalculation.PNG" alt="SpecularCalculation"><br>M — 是跟物体材质有关的，材质决定了specular的反光系数<br>     p<br>(R.V) — 是指观察者所在位置和完美反射光线之间夹角的P次方，P是shininess factor（発光系数之类的）<br>上述换成代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vec3 VertexToEye = normalize(gEyeWorldPos - WorldPos0);                     </span><br><span class="line">vec3 LightReflect = normalize(reflect(gDirectionalLight.Direction, Normal));</span><br><span class="line"><span class="keyword">float</span> SpecularFactor = dot(VertexToEye, LightReflect);                      </span><br><span class="line"><span class="keyword">if</span> (SpecularFactor &gt; <span class="number">0</span>) &#123;                                                   </span><br><span class="line">    SpecularFactor = <span class="built_in">pow</span>(SpecularFactor, gSpecularPower);</span><br><span class="line">    SpecularColor = vec4(gDirectionalLight.Color * gMatSpecularIntensity * SpecularFactor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">FragColor = texture2D(gSampler, TexCoord0.xy) *                                 </span><br><span class="line">            (AmbientColor + DiffuseColor + SpecularColor);</span><br></pre></td></tr></table></figure></p>
<p>Limitations of the Classic Lighting Model: （传统光源的不足之处）<br>Big Missing:</p>
<ol>
<li>Assume no other objects blocking the path of the lights to the surface （假设光不会被物体遮挡）</li>
<li>Accurate ambient lighting （统一固定精确的环境光，现实中是由削弱的（attenuation））</li>
</ol>
<p>了解了光源的三个组成，也了解了传统光源的不足，让我们来看看另一种光照Point Light：<br>Point Light是有伴随距离而削弱（attenuation）的光源<br>公式如下：<br><img src="/img/OpenGL/PointLightFormulation.PNG" alt="PointLightFormulation"></p>
<p>在实现Point Light的计算的时候，我们只需要把光照的方向根据Point Light位置算一下，并在最后除以根据物体位置与Point Light的光源位置算出的attenuation即可、<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">CalcPointLight</span><span class="params">(<span class="keyword">int</span> Index, vec3 Normal)</span>                                                 </span><br><span class="line"></span>&#123;                                                                                           </span><br><span class="line">    vec3 LightDirection = WorldPos0 - gPointLights[Index].Position;                         </span><br><span class="line">    <span class="keyword">float</span> Distance = length(LightDirection);                                                </span><br><span class="line">    LightDirection = normalize(LightDirection);                                             </span><br><span class="line">                                                                                            </span><br><span class="line">    vec4 Color = CalcLightInternal(gPointLights[Index].Base, LightDirection, Normal);       </span><br><span class="line">    <span class="keyword">float</span> Attenuation =  gPointLights[Index].Atten.Constant +                               </span><br><span class="line">                         gPointLights[Index].Atten.Linear * Distance +                      </span><br><span class="line">                         gPointLights[Index].Atten.Exp * Distance * Distance;               </span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="keyword">return</span> Color / Attenuation;                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看一下Spot Light:<br>Spot Light和Point Light的主要区别在于，Spot Light定义了一个可影响的范围Cone和其垂直照射的方向。<br>而这个Cone通过Cutoff来定义：<br>Cutoff — “ The cutoff value represents the maximum angle between the light direction and the light to pixel vector for pixels that are under the influence of the spot light.”<br>见下图：<br><img src="/img/OpenGL/SpotLight.PNG" alt="SpotLight"></p>
<p>通过计算出所在点是否在Spot Light的Cone里去决定是否影响该颜色值。<br>这里需要关注的一点是关于如何映射Cutoff值到[0，1]，因为一般来说Cutoff的值不可能设置到0（即90度），所以我们要想计算边缘化削弱效果，我们需要对Cutoff的值进行线性插值。<br>推导见如下（来源之OpenGL Tutorial 21）：<br><img src="/img/OpenGL/SpotLightCutoffMapping.PNG" alt="SpotLightCutoffMapping"></p>
<p>知道了怎么确认是否影响该点颜色，以及如何插值获取影响值，那么最终归结代码见如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">CalcSpotLight</span><span class="params">(<span class="keyword">struct</span> SpotLight l, vec3 Normal)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec3 LightToPixel = normalize(WorldPos0 - l.Base.Position);</span><br><span class="line">    <span class="keyword">float</span> SpotFactor = dot(LightToPixel, l.Direction);</span><br><span class="line">    <span class="comment">//计算所在点是否在Spot Light的Cone里去决定是否影响该颜色值。</span></span><br><span class="line">    <span class="keyword">if</span> (SpotFactor &gt; l.Cutoff) &#123;</span><br><span class="line">        vec4 Color = CalcPointLight(l.Base, Normal);</span><br><span class="line">        <span class="comment">//插值计算影响值</span></span><br><span class="line">        <span class="keyword">return</span> Color * (<span class="number">1.0</span> - (<span class="number">1.0</span> - SpotFactor) * <span class="number">1.0</span>/(<span class="number">1.0</span> - l.Cutoff));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vec4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>More Advanced Lighting Model:<br>Hemisphere Lighting:<br>The idea behind hemisphere lighting is that we model the illumination as two hemispheres. The upper hemisphere represents the sky and the lower hemisphere represents the ground</p>
<p>Imaged-Based Lighting:<br>“It is often easier and much more efficient to sample the lighting in such environments and store the results in one or more environment maps”</p>
<p>Lighting with Spherical Harmonics:<br>“This method reproduces accurate diffuse reflection, based on the content of a light probe image, without accessing the light probe image at runtime”</p>
<p><a href="www.debevec.org">详情参考</a> </p>
<p>总结:<br>Ambient (环境光) — 与光照的方向无关<br>环境光不会削弱不考虑方向，所以只需考虑光照颜色和平面颜色即可<br>Diffuse (漫反射光) — 与光照的方向和顶点normal有关<br>光照的方向和顶点法线之间的角度直接决定了漫反射光所占的比重。<br>Specular (镜面反射光) — 与光照的方向和eye观察还有顶点normal有关<br>观察者所在位置和光照方向和法线会决定观察者所在位置的Specular反射比例，物体材质会决定Specular反射系数。<br>最终通过计算环境中所有光源对物体的ambient, diffuse, specular影响计算出物体的最终color</p>
<p>接下来我们看一个真实渲染过程中比较重要的技术 — Shadow Mapping<br>Shadow Mapping — Uses a depth texture to determine whether a point is lit or not.</p>
<p>Shadow mapping is a multipass technique that uses depth textures to provide a solution to rendering shadows (核心思想是通过比较通过光源点观察保存的深度信息（depth texture）和从观察点观察的深度信息来判断哪些点是shadowed，哪些是unshadowed — 注意比较的是通过映射到2D depth texture后的信息)<br>A key pass is to view the scene from the shadow-casting light source rather than from the final viewpoint<br>Two passes:</p>
<ul>
<li><em>First Pass</em><br>Shadow map — by rendering the scene’s depth from the point of the light into a depth texture, we can obtain a map of the shadowed and unshadowed points in the scene<br>在第一个pass中，我按照事例代码中写了，但发现最后显示的是纯白色的图像。<br>后来就不断去查问题。<br><img src="/img/OpenGL/ShaowMapFirstPass.PNG" alt="ShaowMapFirstPassFailed"><br>首先，我怀疑depth texture是不是没有生成成功？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the FBO</span></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the depth buffer</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;m_shadowMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_shadowMap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable writes to the color buffer</span></span><br><span class="line">glDrawBuffer(GL_NONE);</span><br><span class="line">glReadBuffer(GL_NONE);</span><br><span class="line"></span><br><span class="line">GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但上述代码没有报任何错误，通过gDebugger查看Texture的时候发现depth texture是生成成功了的。<br><img src="/img/OpenGL/ShaowMapFirstPassCreate.PNG" alt="ShaowMapFirstPassCreate"><br>从上图仔细看，模型的深度信息时被生成到了FBO 1所绑定的Depth Texture中了的。</p>
<p>那么接下来，我就怀疑是不是我激活的Texture unit有错误？<br>以下是将Depth Texture渲染到一个平面上的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ShadowMapFBO::BindForReading(GLenum TextureUnit)</span><br><span class="line">&#123;</span><br><span class="line">    glActiveTexture(TextureUnit);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glUniform1i(gTextureLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	gShadowMapFBO.BindForReading(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">5.0f</span>, <span class="number">5.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">	p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">	p.SetCamera(pGameCamera-&gt;GetPos(), pGameCamera-&gt;GetTarget(), pGameCamera-&gt;GetUp());</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	glUniformMatrix4fv(gWVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)p.GetWVPTrans());</span><br><span class="line"></span><br><span class="line">	gPQuade-&gt;Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/OpenGL/MyTextureList.PNG" alt="MyTextureList"><br><img src="/img/OpenGL/DemoTextureList.PNG" alt="DemoTextureList"><br>通过上图，我发现我自己的代码有三个Texture被生成，但Demo只有两个，并且我自己写的代码Enable的并非FBO 1绑定生成的Texture而是第三个Texture，所以这是我怀疑我在加载Mesh的时候加载了第三个Texture并将其绑定在了Texture unit 0，而我碰巧激活了这一个Texture unit。</p>
<p>由于我的mesh.cpp是沿用上一个tutorial的代码，所以我没有更新到最新教程的mesh代码。<br>下面是我所用的mesh.cpp的一个加载Texture的方法和Texture源代码加载的时候的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Mesh::InitMaterials(<span class="keyword">const</span> aiScene* pScene, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load a white texture in case the model does not include its own texture</span></span><br><span class="line">    <span class="keyword">if</span> (!m_Textures[i]) &#123;</span><br><span class="line">        m_Textures[i] = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/white.png"</span>);</span><br><span class="line"></span><br><span class="line">        Ret = m_Textures[i]-&gt;Load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mesh::Render()</span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MaterialIndex &lt; m_Textures.size() &amp;&amp; m_Textures[MaterialIndex]) &#123;</span><br><span class="line">        m_Textures[MaterialIndex]-&gt;Bind(GL_TEXTURE0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Texture::Load()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m_image.read(m_fileName);</span><br><span class="line">        m_image.write(&amp;m_blob, <span class="string">"RGBA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Magick::Error&amp; Error) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error loading texture '"</span> &lt;&lt; m_fileName &lt;&lt; <span class="string">"': "</span> &lt;&lt; Error.what() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_textureObj);</span><br><span class="line">    glBindTexture(m_textureTarget, m_textureObj);</span><br><span class="line">    glTexImage2D(m_textureTarget, <span class="number">0</span>, GL_RGBA, m_image.columns(), m_image.rows(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_blob.data());</span><br><span class="line">    glTexParameterf(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    </span><br><span class="line">    glBindTexture(m_textureTarget, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Texture::Bind(GLenum TextureUnit)</span><br><span class="line">&#123;</span><br><span class="line">    glActiveTexture(TextureUnit);</span><br><span class="line">    glBindTexture(m_textureTarget, m_textureObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出如果我加载的mesh没有含有贴图的话，我会指定他去默认加载white.png作为贴图，并且渲染的时候激活Texture unit 0并将该纹理绑定到Texture unit 0</p>
<p>这也就是为什么我后来调用下列代码出现了Active错误的texture的原因。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniform1i(gTextureLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">gShadowMapFBO.BindForReading(GL_TEXTURE0);</span><br></pre></td></tr></table></figure></p>
<p>所以在不改Texture和Mesh源代码的情况下，我只需要将生成的Texture unit绑定到GL_TEXTURE2并指定Shader去访问Texture unit 2即可。<br>将上述代码改为如下即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniform1i(gTextureLocation, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">gShadowMapFBO.BindForReading(GL_TEXTURE2);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/OpenGL/ShadowMapFirstPassSuccessful.PNG" alt="ShadowMapFirstPassSuccessful"></p>
<p>在渲染到Depth Texture的时候，主要是通过以下步骤：</p>
<ol>
<li><p>创建新的FBO和Texture object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the FBO</span></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the depth texture</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;m_shadowMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活新的FBO并绑定Texture object到FBO的Depth buffer上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_shadowMap, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭颜色写入到新的FBO。因为我们只需要Depth信息，所以我们不需要写入颜色信息到新的FBO里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawBuffer(GL_NONE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查新的FBO的状态是否完整</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活新的FBO并清除Depth信息后以光线来源的角度draw call写入depth信息到新的FBO和绑定的depth texture里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShadowMapPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gShadowMapFBO.BindForWriting();</span><br><span class="line"></span><br><span class="line">	glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">	p.Rotate(<span class="number">0.0f</span>, gScale, <span class="number">0.0f</span>);</span><br><span class="line">	p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">	p.SetCamera(gSpotLight.Position, gSpotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set uniform variable value</span></span><br><span class="line">	glUniformMatrix4fv(gWVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)p.GetWVPTrans());</span><br><span class="line"></span><br><span class="line">	gPTank-&gt;Render();</span><br><span class="line"></span><br><span class="line">	glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><em>Second Pass</em><br>Rendering the scene from the point of view of the viewer. Project the surface coordinates into the light’s reference frame and compare their depths to the depth recorded into the light’s depth texture. Fragments that are further from the light than the recorded depth value were not visible to the light, and hence in shadow</li>
</ul>
<p>第二个pass的关键有下列几个点：</p>
<ol>
<li><p>正常方式渲染时，通过传递Light的MVP去计算每一个顶点在光源角度观察时的投影位置信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    m_pLightingEffect-&gt;Enable();</span><br><span class="line"></span><br><span class="line">    m_pLightingEffect-&gt;SetEyeWorldPos(m_pGameCamera-&gt;GetPos());</span><br><span class="line">   </span><br><span class="line">    m_shadowMapFBO.BindForReading(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line">    Pipeline p;</span><br><span class="line">    p.SetPerspectiveProj(m_persProjInfo);</span><br><span class="line"></span><br><span class="line">    p.Scale(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    p.Rotate(<span class="number">90.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    m_pLightingEffect-&gt;SetWVP(p.GetWVPTrans());</span><br><span class="line">    m_pLightingEffect-&gt;SetWorldMatrix(p.GetWorldTrans());        </span><br><span class="line">    p.SetCamera(m_spotLight.Position, m_spotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    m_pLightingEffect-&gt;SetLightWVP(p.GetWVPTrans());</span><br><span class="line">    m_pGroundTex-&gt;Bind(GL_TEXTURE0);</span><br><span class="line">    m_pQuad-&gt;Render();</span><br><span class="line"></span><br><span class="line">    p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">    p.Rotate(<span class="number">0.0f</span>, m_scale, <span class="number">0.0f</span>);</span><br><span class="line">    p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    m_pLightingEffect-&gt;SetWVP(p.GetWVPTrans());</span><br><span class="line">    m_pLightingEffect-&gt;SetWorldMatrix(p.GetWorldTrans());</span><br><span class="line">    p.SetCamera(m_spotLight.Position, m_spotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    m_pLightingEffect-&gt;SetLightWVP(p.GetWVPTrans());</span><br><span class="line">    m_pMesh-&gt;Render();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lighting.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 TexCoord;                                             </span><br><span class="line">layout (location = <span class="number">2</span>) in vec3 Normal;                                               </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gWVP;                                                                  </span><br><span class="line">uniform mat4 gLightWVP;                                                             </span><br><span class="line">uniform mat4 gWorld;                                                                </span><br><span class="line">                                                                                    </span><br><span class="line">out vec4 LightSpacePos;                                                             </span><br><span class="line">out vec2 TexCoord0;                                                                 </span><br><span class="line">out vec3 Normal0;                                                                   </span><br><span class="line">out vec3 WorldPos0;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//这里就是转换到以光源为摄像机角度的透视投影后的坐标信息</span></span><br><span class="line">    LightSpacePos = <span class="function">gLightWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;                                 </span><br><span class="line">	......                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过把光源角度下投影的位置信息转换到NDC space(设备坐标系，光栅化后xyz都映射到[-1,1])，这时就得到了顶点在光源角度下NDC的坐标信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lighting.fs                                                 </span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcShadowFactor</span><span class="params">(vec4 LightSpacePos)</span>                                                 </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="comment">//通过除以w我们可以得到NDC space的信息</span></span><br><span class="line">    vec3 ProjCoords = LightSpacePos.xyz / LightSpacePos.w;                    </span><br><span class="line">	......                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后通过转换纹理坐标映射到[0,1]去查询Depth texture中的深度信息和自身的z深度信息作比较，如果depth texture中值更小说明改点处于被遮挡区域应该是阴影部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcShadowFactor</span><span class="params">(vec4 LightSpacePos)</span>                                                 </span><br><span class="line"></span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    vec2 UVCoords;                                                                         </span><br><span class="line">    UVCoords.x = <span class="number">0.5</span> * ProjCoords.x + <span class="number">0.5</span>;                                                 </span><br><span class="line">    UVCoords.y = <span class="number">0.5</span> * ProjCoords.y + <span class="number">0.5</span>;                                                 </span><br><span class="line">    <span class="keyword">float</span> z = <span class="number">0.5</span> * ProjCoords.z + <span class="number">0.5</span>;                                                    </span><br><span class="line">    <span class="keyword">float</span> Depth = texture(gShadowMap, UVCoords).x;                                         </span><br><span class="line">    <span class="keyword">if</span> (Depth &lt; z + <span class="number">0.00001</span>)                                                               </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>;                                                                        </span><br><span class="line">    <span class="keyword">else</span>                                                                                   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为原本x，y，z在NDC space下是[-1,1]，为了映射到[0,1]，我们只需要按上述方法即可。<br>这样一来就得到NDC space下的纹理坐标信息和深度z信息，然后通过查询depth texture获取光源角度的深度信息和现有顶点在光源角度的深度信息做比较得出是否处于阴影的结论。</p>
<p>这里实现相当复杂就没有自己再去写一遍，具体参考Tutorial 24的源代码。<br>最终效果：<br><img src="/img/OpenGL/ShadowMapFinal.PNG" alt="ShadowMap"></p>
<h3 id="Skybox">Skybox</h3><p>A skybox is a method of creating backgrounds to make a computer and video games level look bigger than it really is. When a skybox is used, the level is enclosed in a cuboid. (From wiki)<br><img src="/img/OpenGL/SkyboxTexture.PNG" alt="SkyboxTexture"></p>
<p>在OpenGL中实现Skybox是通过Cubemap。</p>
<p>In order to sample from the cubemap we will use a 3D texture coordinate instead of the 2D coordinate</p>
<p>Skydome —  A skybox which uses a sphere is sometimes called a skydome.</p>
<p>实现skybox主要有下列几点需要注意：</p>
<ol>
<li><p>生成Cubemap texture,分别指定6个对应skybox的六个面类型的纹理数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLenum types[<span class="number">6</span>] = &#123;  GL_TEXTURE_CUBE_MAP_POSITIVE_X,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_NEGATIVE_X,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_POSITIVE_Y,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_POSITIVE_Z,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> CubemapTexture::Load()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//生成cubemap texture</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_textureObj);</span><br><span class="line">    glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureObj);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定对应skybox六个面类型的纹理数据</span></span><br><span class="line">    glTexImage2D(types[i], <span class="number">0</span>, GL_RGB, pImage-&gt;columns(), pImage-&gt;rows(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, blob.data());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染skybox的时候，需要把glCullFace和glDepthFunc设置成GL_FRONT和GL_LEQUAL（因为camera是放在skybox sphere内部的，而sphere的triangle是front face, 所以针对skybox sphere我们需要cull的是front而非back。为了使得skybox永远不会被clip掉，我们需要修改默认的glDepthFunc到GL_LEQUAL来确保在Z = 1的far平面也不会被clip。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SkyBox::Render()</span><br><span class="line">&#123;</span><br><span class="line">    m_pSkyboxTechnique-&gt;Enable();</span><br><span class="line"></span><br><span class="line">    GLint OldCullFaceMode;</span><br><span class="line">    glGetIntegerv(GL_CULL_FACE_MODE, &amp;OldCullFaceMode);</span><br><span class="line">    GLint OldDepthFuncMode;</span><br><span class="line">    glGetIntegerv(GL_DEPTH_FUNC, &amp;OldDepthFuncMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确保skybox sphere不被clip掉并且显示出正确的一面</span></span><br><span class="line">    glCullFace(GL_FRONT);</span><br><span class="line">    glDepthFunc(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line"></span><br><span class="line">    m_pMesh-&gt;Render();</span><br><span class="line"></span><br><span class="line">    glCullFace(OldCullFaceMode);</span><br><span class="line">    glDepthFunc(OldDepthFuncMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保skybox深度检测时值永远在Z = 1的far平面（这样一来确保skybox深度检测永远失败，因为我们吧glDepthFunc设置成了GL_LEQUAL）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">skybox.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">out vec3 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec4 WVP_Pos = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//通过把gl_Position的z设置成w，在光栅化进入fragment shader之前，skybox的z值会永远映射到1(即远平面)，确保skybox深度检测永远fail但永远不被clip（因为我们吧glDepthFunc设置成了GL_LEQUAL）</span></span><br><span class="line">    gl_Position = WVP_Pos.xyww;</span><br><span class="line">    TexCoord0 = Position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把object space的3D坐标当做3D texture坐标的索引值去查询纹理信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">skybox.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">out vec3 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//因为cubemap这里默认cube和sphere都是以自身中心作为基准（个人认为这里的基准是可变的（建模工具可设定）），这样一来把object space的坐标信息通过光栅化后传递到fs中就可以作为texture coordinate来查询纹理信息</span></span><br><span class="line">    TexCoord0 = Position;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">skybox.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec3 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform samplerCube gCubemapTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这里的TexCoord0是经过光栅化后映射到了[-1,1]</span></span><br><span class="line">    FragColor = texture(gCubemapTexture, TexCoord0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/img/OpenGL/Skybox.PNG" alt="Skybox"></p>
<p>Note:<br>“An interesting performance tip is to always render the skybox last (after all the other models). The reason is that we know that it will always be behind the other objects in the scene.”</p>
<h3 id="Normal_Mapping">Normal Mapping</h3><p>在了解Normal Mapping之前不得不提Bump Mapping<br>下列关于Bump Mapping大部分内容来源:<br><a href="http://blog.csdn.net/pizi0475/article/details/48547329" target="_blank" rel="external">OpenGL 法线贴图 切线空间 整理</a><br><a href="https://en.wikipedia.org/wiki/Bump_mapping" target="_blank" rel="external">Bump mapping</a><br><a href="http://demo.netfoucs.com/zangle260/article/details/44156795" target="_blank" rel="external">关于法线贴图, 法线, 副法线, 切线 的东东,看了很容易理解</a></p>
<p>What is Bump Mapping?<br><a href="https://en.wikipedia.org/wiki/Bump_mapping" target="_blank" rel="external">Bump mapping[1] is a technique in computer graphics for simulating bumps and wrinkles on the surface of an object. This is achieved by perturbing the surface normals of the object and using the perturbed normal during lighting calculations.</a></p>
<p>可以看出Bump Mapping是通过改变物体顶点法线来影响光照的效果，最终看起来有凹凸的效果（而非顶点之间真实的深度差），是一种欺骗眼睛的技术。</p>
<p>“Jim Blinn在1978发表了一篇名为：“Simulation of Wrinkled Surfaces”，提出了Bump Mapping这个东东。Bump Mapping通过一张Height Map记录各象素点的高度信息，有了高度信息，就可以计算HeightMap中当前象素与周围象素的高度差，这个高度差就代表了各象素的坡度，用这个坡度信息去绕动法向量，得到最终法向量，用于光照计算。坡度越陡，绕动就越大。”</p>
<p>Why Bump Mapping?<br>“如果要在几何体表面表现出凹凸不平的细节，那么在建模的时候就会需要很多的三角面，如果用这样的模型去实时渲染，出来的效果是非常好，只是性能上很有可能无法忍受。Bump Mapping不需要增加额外的几何信息,就可以达到增强被渲染物体的表面细节的效果，可以大大地提高渲染速度，因此得到了广泛的应用。”</p>
<p>What is Normal Mapping?<br>“Normal Mapping也叫做Dot3 Bump Mapping,它也是Bump Mapping的一种，区别在于Normal Mapping技术直接把Normal存到一张NormalMap里面，从NormalMap里面采回来的值就是Normal，不需要像HeightMap那样再经过额外的计算。”</p>
<p>“值得注意的是，NormalMap存的Normal是基于切线空间的，因此要进行光照计算时，需要把Normal,Light Direction,View direction统一到同一坐标空间中。”</p>
<p>这里不得不提的一个点就是切线空间(tangent space)<br>What is tangent space?<br>“ Tangent Space与World Space，View Space其实是同样的概念，均代表三维坐标系。在这个坐标系中，X轴对应纹理坐标的U方向，沿着该轴纹理坐标U线性增大。Y轴对应纹理坐标的V方向，沿着该轴纹理坐标V线性增大。Z轴则是UXV，垂直于纹理平面。”</p>
<p>Why do we need tangent space?<br>“为什么normal map里面存的法线信息是基于tangent sapce而不是基于local space呢?基于local space理论上也是可以的，但是这样的normal map只能用于一个模型，不同把这个normal map用于其他模型。比如说建模了一个人，并且生成了该模型基于local space的normal map， 如果我们建模同一个人，但是放的位置和角度和之前的不一样，那么之前的normal map就不能用了，因为local Space并不一样，但如果我们normal map里存的是tangent space的normal的话，就不存在这个问题，因为只要模型一样，模型上每个点的tangent space就是一样的，所谓以不变应万变。”</p>
<p>可以看出tangent space是针对顶点而言的。</p>
<p>How to get tangent space?<br>让我们看一下下图：<br><img src="/img/OpenGL/TangentSpaceCaculation.PNG" alt="TangentSpaceCaculation"><br>以下推导来源于:<br><a href="http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html" target="_blank" rel="external">Tutorial 26:Normal Mapping</a><br><img src="/img/OpenGL/TangentSpaceDeduce.PNG" alt="TangentSpaceDeduce"><br><img src="/img/OpenGL/TangentSpaceDeduce2.PNG" alt="TangentSpaceDeduce2"><br>从上面而已看出通过三角形的顶点和纹理信息可以算出T和B</p>
<p>Note:<br>在实际开发中我们并非一定要手动写代码运算，比如”Open Asset Import Library就支持flag called ‘aiProcess_CalcTangentSpace’ which does exactly that and calculates the tangent vectors for us”</p>
<p>Normal Map也通过工具可以生成，比如3D Max， Maya， 教程里用的GNU Image Manipulation Program (GIMP)…….</p>
<p>当我们通过Normap Map获取得到normal值时，因为该normal值时位于tangent space下，所以我们必须对其进行坐标系转换，必须转换到world space后才参与光照计算。</p>
<p>而这个变换到世界坐标系的矩阵，可以通过tangent这个向量和顶点法线信息推导出来。</p>
<ol>
<li>加载mesh时生成tangent数据，渲染时指定tangent数据位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Mesh::LoadMesh(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Assimp::Importer Importer;</span><br><span class="line">    <span class="comment">//aiProcess_CalcTangentSpace指定生成tangent数据</span></span><br><span class="line">    <span class="keyword">const</span> aiScene* pScene = Importer.ReadFile(Filename.c_str(), aiProcess_Triangulate |</span><br><span class="line">                                                                aiProcess_GenSmoothNormals |</span><br><span class="line">                                                                aiProcess_FlipUVs |</span><br><span class="line">                                                                aiProcess_CalcTangentSpace);    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::Render()</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">//指定tangent数据读取方式</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">3</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">const</span> GLvoid*)<span class="number">32</span>); <span class="comment">// tangent</span></span><br><span class="line">     </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将tangent和顶点法线转换到世界坐标系</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">layout (location = 0) in vec3 Position;</span><br><span class="line">layout (location = 1) in vec2 TexCoord;</span><br><span class="line">layout (location = 2) in vec3 Normal;</span><br><span class="line">layout (location = 3) in vec3 Tangent;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line">uniform mat4 gLightWVP;</span><br><span class="line">uniform mat4 gWorld;</span><br><span class="line"></span><br><span class="line">out vec4 LightSpacePos;</span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line">out vec3 Normal0;</span><br><span class="line">out vec3 WorldPos0;</span><br><span class="line">out vec3 Tangent0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	//将tangent和顶点法线转换到世界坐标系</span><br><span class="line">    Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;</span><br><span class="line">    Tangent0 = (gWorld * vec4(Tangent, 0.0)).xyz;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过转换到世界坐标系的tangent和normal计算出bitangent（转换到世界坐标系后的B）（下面T代表tangent， N代表normal， B代表bitangent）</p>
</li>
<li><p>逆算出tangent space下normal map里的顶点法线值</p>
</li>
<li><p>通过算出的位于世界坐标系的TBN去转换tangent space下逆算后的normal map的顶点法线值，最终得到位于世界坐标的顶点法线</p>
</li>
<li><p>算出位于世界坐标系的顶点法线后，最后正常参与diffuse光照计算即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(lighting.fs:<span class="number">132</span>)</span><br><span class="line"><span class="function">vec3 <span class="title">CalcBumpedNormal</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec3 Normal = normalize(Normal0);</span><br><span class="line">    vec3 Tangent = normalize(Tangent0);</span><br><span class="line">    <span class="comment">//得到位于TN平面且垂直于N的向量</span></span><br><span class="line">    Tangent = normalize(Tangent - dot(Tangent, Normal) * Normal);</span><br><span class="line">    <span class="comment">//通过叉乘得出垂直于T和N的B</span></span><br><span class="line">    vec3 Bitangent = cross(Tangent, Normal);</span><br><span class="line">    vec3 BumpMapNormal = texture(gNormalMap, TexCoord0).xyz;</span><br><span class="line">    <span class="comment">//这里需要注意一点：</span></span><br><span class="line">    <span class="comment">//"我们在描述色彩的时候，RGB三个通道的取值范围都是从零开始的。可是当我们尝试把一个任意的法线保存在一张纹理中的时候，会面临取负值的问题。因此我们要把法线做压缩。方法很简单，把XYZ每个轴上的法线投影长度进行N＋1/2的运算。这样就把所有的法线压缩到了0和1的范围里。"</span></span><br><span class="line">    <span class="comment">//所以这里通过列方法算回原有的顶点法线值</span></span><br><span class="line">    BumpMapNormal = <span class="number">2.0</span> * BumpMapNormal - vec3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    vec3 NewNormal;</span><br><span class="line">    <span class="comment">//由于位于世界坐标系的T,N,B都算出来了，所以可以构建一个TBN的矩阵去把normal map里的法线值转换到世界坐标系</span></span><br><span class="line">    mat3 TBN = mat3(Tangent, Bitangent, Normal);</span><br><span class="line">    NewNormal = TBN * BumpMapNormal;</span><br><span class="line">    <span class="comment">//最后归一化算出来的顶点法线既得到了我们需要的位于世界坐标系的顶点法线，最后正常参与diffuse光照计算即可</span></span><br><span class="line">    NewNormal = normalize(NewNormal);</span><br><span class="line">    <span class="keyword">return</span> NewNormal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>让我们看看Normal Map Texture<br><img src="/img/OpenGL/NormalMapTexture.PNG" alt="NormalMapTexture"></p>
<p>See Normal Mapping(left) and Regular Mapping(right)<br><img src="/img/OpenGL/NormalMappingAndRegularMapping.PNG" alt="NormalMappingAndRegularMapping"></p>
<p>Note:<br><a href="https://en.wikipedia.org/wiki/Normal_mapping" target="_blank" rel="external">A common use of this(normal mapping) technique is to greatly enhance the appearance and details of a low polygon model by generating a normal map from a high polygon model or height map.</a></p>
<p>高模normal map用于低模模型上，即不增加渲染负担又能增加渲染细节。</p>
<p>More：<br><a href="http://blog.csdn.net/pizi0475/article/details/48547329" target="_blank" rel="external">下面内容来源</a><br>Parallax Mapping<br>当使用Normal Mapping技术时，并没有把视线方向考滤进去。在真实世界中，如果物体表面高低不平，当视线方向不同时，看到的效果也不相同。Parallax Mapping就是为了解决此问题而提出的。</p>
<p>Parallax Mapping首先在一篇名为“Detailed Shape Representation with Parallax Mapping”的文章中提出。它的基本思想如下图示（本图来自Parallax Mapping with Offset Limiting: A PerPixel Approximation of Uneven Surfaces）。在图示的视线方向，如果表面是真正的凹凸不平的，如real surfacer所示，那么能看到的是B点，因此用于采样法线的正确纹理坐是TB而不是TA。<br><img src="/img/OpenGL/ParallaxMappinge.PNG" alt="ParallaxMappinge"><br>因此，我们需要对纹理坐标作偏移，为了满足实时渲染的要求，采用了取近似偏移的方法（如下图示），这种近似的算法已经可以达到比较好的效果。具体的offset计算可以参考：“Parallax Mapping with Offset Limiting: A PerPixel Approximation of Uneven Surface”，里面有详细的讲解。<br><img src="/img/OpenGL/ParallaxMappinge2.PNG" alt="ParallaxMappinge2"></p>
<p>Parallax Occlusion Mapping<br>Parallax Occlusion Mapping是对Parallax Mapping的改进，DirectX SDK中有个Sample专门讲这个，相关细节可以参看此Sample. Parallax Occlusion Mapping中实现了Self Shadow，还计算了比较精确的offset，复杂度比Parallax Mapping大，但是实现效果更好。</p>
<h3 id="BillBoard_And_Geometry_Shader">BillBoard And Geometry Shader</h3><p>Geometry shader(Optional)<br>“The geometry shader sits logically right before primitive assembly<br>and fragment shading.”</p>
<p>Receives as its input complete primitives as a collection of vertices, and these inputs are represented as array (Geometry shader接收完整图形的顶点集合，这些顶点集合在geometry shader中通过gl_in[]数组的方式访问)</p>
<p>gl_in的声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in gl_PerVertex &#123;</span><br><span class="line">vec4 gl_Position;</span><br><span class="line"><span class="keyword">float</span> gl_PointSize;</span><br><span class="line"><span class="keyword">float</span> gl_ClipDistance[];</span><br><span class="line">&#125;gl_in[];</span><br></pre></td></tr></table></figure></p>
<p>Geometry Features:</p>
<ol>
<li><p>Producing Primitives<br>They can have a different primitive type for their output than they do for their input. (EG: wireframe rendering, billboards and even interesting instancing effects)(Billboard效果见后面)</p>
</li>
<li><p>Culling Geometry<br>Selective culling （geometry shader通过对特定的gl_PrimitiveIDIn进行生成特定的primitive实现selective culling）<br>“gl_PrimitiveIDIn is a geometry language input variable that holds the number of primitives processed by the shader since the current set of rendering primitives was started.”</p>
</li>
<li><p>Geometry Amplification<br>Produces more primitives on its output than it accepts on its input<br>(can be used to implement fur shells or moderate tessellation — 因为可以对传入的primitive数据进行处理并生成多个primitive，所以能通过复制并改变primitive的信息数据来实现毛发等效果)<br>Gl_MaxGeometryOutputVertices &amp; glGetIntegerv(GL_MAX_GEOMETRY_OUTPUT_VERTICES)</p>
</li>
</ol>
<p>毛发效果(来源OpenGL红宝书第八版)：<br><img src="/img/OpenGL/Geometry_Shader_Fur.PNG" alt="Geometry_Shader_Fur"></p>
<p>这里我们详细看看Geometry Shader是如何实现Billboard效果：<br>Billboard - “A billboard is a quad which always faces the camera. “</p>
<ol>
<li>Before a geometry shader may be linked, the input primitive type, output primitive type, and the maximum number of vertices that is might produce must be specified (在链接geometry shader之前，我们必须先定义geometry shader的输入输出类型) </li>
</ol>
<p>``CPP<br>version 330<br>//指明GS中传入的数据是以点为单位                                                           layout(points) in;<br>//指明GS将输出的primitive是triangle_strip<br>layout(triangle_strip) out;<br>//指明GS生成的最大顶点数量是4，因为这里我们只需4个顶点组成一个quad即可<br>layout(max_vertices = 4) out;                                                       </p>
<p>……</p>
<p>void main()<br>{<br>    ……<br>}<br>//e.g:<br>//layout (input primitive type) in;<br>//layout (output primitive type, max<em>vertices = number) out; (这里的max</em>//vertices会遇到一个硬件限制所支持的max_vertices的最大值—超出最大值后program //link会出错，通过在program link后调用glGetProgramiv() with GL_INFO_LOG_LENGTH //parameter可以得program link的出错信息，shader compile的log同理)<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> 利用传递进来的顶点primitive数据生成新的面向camera的primitive数据</span><br><span class="line">```CPP</span><br><span class="line"><span class="preprocessor">#version 330                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">layout</span>(points) <span class="keyword">in</span>;                                                                  </span><br><span class="line"><span class="keyword">layout</span>(triangle_strip) <span class="keyword">out</span>;                                                         </span><br><span class="line"><span class="keyword">layout</span>(max_vertices = <span class="number">4</span>) <span class="keyword">out</span>;                                                       </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">mat4</span> gVP;                                                                   </span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">vec3</span> gCameraPos;                                                            </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">out</span> <span class="keyword">vec2</span> TexCoord;                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">void</span> main()                                                                         </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//通过gl_in我们可以在GS中访问传入的primitive的顶点数据，这里因为我们指定了传入的layout(points) in，所以这里只需访问gl_in[0]即可                                        </span></span><br><span class="line">    <span class="comment">//通过计算出面向camera时quad所在的物体坐标系信息，我们在这基础上对顶点数据做偏移，这样算出来的顶点数据生成的primitive始终面向Camera                              </span></span><br><span class="line">    <span class="keyword">vec3</span> Pos = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>.xyz;                                            </span><br><span class="line">    <span class="keyword">vec3</span> toCamera = <span class="built_in">normalize</span>(gCameraPos - Pos);                                    </span><br><span class="line">    <span class="keyword">vec3</span> up = <span class="keyword">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);                                                  </span><br><span class="line">    <span class="keyword">vec3</span> right = <span class="built_in">cross</span>(toCamera, up);                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos -= (right * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//这里之所以只传gVP而非gMVP是因为我们在创建顶点数据的时候就是传递的世界坐标信息</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = gVP * <span class="keyword">vec4</span>(Pos, <span class="number">1.0</span>);                                             </span><br><span class="line">    TexCoord = <span class="keyword">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);                                                      </span><br><span class="line">    <span class="built_in">EmitVertex</span>();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += <span class="number">1.0</span>;                                                                   </span><br><span class="line">    <span class="built_in">gl_Position</span> = gVP * <span class="keyword">vec4</span>(Pos, <span class="number">1.0</span>);                                             </span><br><span class="line">    TexCoord = <span class="keyword">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>);                                                      </span><br><span class="line">    <span class="comment">//通过调用EmitVertex指定利用上面的数据生成新的vertex加入到最终的primitive构造中</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y -= <span class="number">1.0</span>;                                                                   </span><br><span class="line">    Pos += right;                                                                   </span><br><span class="line">    <span class="built_in">gl_Position</span> = gVP * <span class="keyword">vec4</span>(Pos, <span class="number">1.0</span>);                                             </span><br><span class="line">    TexCoord = <span class="keyword">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);                                                      </span><br><span class="line">    <span class="built_in">EmitVertex</span>();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += <span class="number">1.0</span>;                                                                   </span><br><span class="line">    <span class="built_in">gl_Position</span> = gVP * <span class="keyword">vec4</span>(Pos, <span class="number">1.0</span>);                                             </span><br><span class="line">    TexCoord = <span class="keyword">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);                                                      </span><br><span class="line">    <span class="built_in">EmitVertex</span>();                                                                   </span><br><span class="line">    <span class="comment">//通过调用EndPrimitive指定前面生成的顶点数据作为一个新的primitive  </span></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();                                                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>``CPP<br>void BillboardList::CreatePositionBuffer()<br>{<br>    Vector3f Positions[NUM_ROWS <em> NUM_COLUMNS];<br>    //创建顶点数据的时候即传递的世界坐标<br>    for (unsigned int j = 0 ; j &lt; NUM_ROWS ; j++) {<br>        for (unsigned int i = 0 ; i &lt; NUM_COLUMNS ; i++) {<br>            Vector3f Pos((float)i, 0.0f, (float)j);<br>            Positions[j </em> NUM_COLUMNS + i] = Pos;<br>        }<br>    }</p>
<pre><code><span class="attribute">...</span><span class="attribute">...</span>
</code></pre><p>}<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EmitVertex() – produces <span class="operator">a</span> <span class="built_in">new</span> vertex <span class="keyword">at</span> <span class="operator">the</span> output <span class="operator">of</span> <span class="operator">the</span> geometry shader. Each <span class="built_in">time</span> <span class="keyword">it</span> is called, <span class="operator">a</span> vertex is appended <span class="built_in">to</span> <span class="operator">the</span> <span class="function"><span class="keyword">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">current</span> <span class="title">strip</span> (将新的<span class="title">vertex</span>加入到<span class="title">primitive</span>的队列)</span></span><br><span class="line"></span><br><span class="line">EndPrimitive() – breaks <span class="operator">the</span> current strip <span class="operator">and</span> signals OpenGL that <span class="operator">a</span> <span class="built_in">new</span> strip should be started <span class="operator">the</span> next <span class="built_in">time</span> EmitVertex() is called (将之前所加入的vertex算作一个primitive的信息，通知OpenGL开始下一个primitive的构造)</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">When <span class="operator">the</span> geometry shader exits, <span class="operator">the</span> current primitive is ended implicitly (如果geometry shader结束了，那么当前还没有调用EndPrimitive()的primitive将视作结束)</span><br><span class="line"></span><br><span class="line">When EndPrimitive() is called, <span class="keyword">any</span> incomplete primitives will simply be discarded (当EndPrimitive()被调用的时候，数据不完全的primitive将被抛弃 <span class="comment">-- 不调用这个方法的primitive相当于culling掉)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 在FS中利用GS中生成的纹理坐标映射纹理信息并Cull掉纹理图片中黑色的部分</span><br><span class="line">```CPP</span><br><span class="line"><span class="comment">#version 330                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">uniform sampler2D <span class="variable">gColorMap</span>;                                                        </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="operator">in</span> vec2 TexCoord;                                                                   </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line">void main()                                                                         </span><br><span class="line">&#123;                                                                                   </span><br><span class="line">    FragColor = texture2D(<span class="variable">gColorMap</span>, TexCoord);                                     </span><br><span class="line">   <span class="comment"> //Cull掉纹理图片中黑色的部分</span></span><br><span class="line">    <span class="keyword">if</span> (FragColor.r == <span class="number">0</span> &amp;&amp; FragColor.g == <span class="number">0</span> &amp;&amp; FragColor.b == <span class="number">0</span>) &#123;</span><br><span class="line">        discard;                                                                    </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Final Effect:<br><img src="/img/OpenGL/GSBillboard.PNG" alt="GSBillboard"></p>
<ol>
<li>Geometry Shader Instance<br>Only runs the geometry shader and subsequent stages (rasterization) multiple times, rather than the whole pipeline (Geometry shader instancing draw call是通过运行多次geometry和rasterization和fragment来实现的)</li>
</ol>
<p>Geometry shader instancing is enabled in the shader by specifying the invocations layout qualifier<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (triangles, invocations = <span class="number">4</span>) in;  <span class="comment">//invocations = 4 indicates that the geometry shader will be called 4 times for each input primitives</span></span><br></pre></td></tr></table></figure></p>
<p>gl_InvocationID identifies the invocation number assigned to the geometry shader invocation.</p>
<ol>
<li>Multiple Viewport Rendering<br>gl_ViewportIndex (output variables available in the geometry shader that can redirect rendering into different regions of the framebuffer)</li>
</ol>
<p>gl_ViewportIndex is used to specify which set of viewport parameters will be used to perform the viewport transformation by OpenGL<br>“ (Multiple viewport concept （多个视图窗口） — 这里主要是通过gl_ViewportIndex访问多个viewport，然后在geometry shader中通过指定primitive输出到特定的viewport来实现多个视图窗口)</p>
<p>glViewportIndexedf() or glViewportIndexedfv() – specify how window x and y coordinates are generated from clip coordinates</p>
<p>glDepthRangeIndexed() – specify how the window z coordinate is generated</p>
<p>效果展示(这里展示的OpenGL红宝书第八版的例子)：<br><img src="/img/OpenGL/Geometry_Transform_Feedback_Buufer.PNG" alt="Geometry_Transform_Feedback_Buufer"></p>
<ol>
<li>Layer Rendering<br>It is also possible to use a 2D array texture as a color attachment and render into the slices of the array using a geometry shader (传入2D的纹理数组数据当做color attachment，通过geometry shader把传入的2D纹理数组信息去渲染多个slices)</li>
</ol>
<p>A restriction exits when using layered attachments to framebuffer: (使用layered attachment到framebuffer的规则):<br>All the attachments of that framebuffer must be layered (framebuffer的所有attachment都必须是layered)</p>
<p>Also, all attachments of a layered framebuffer must be of the same type (所有attach到layered framebuffer的attachment必须是同样类型)</p>
<p>gl_Layer – built in variable in geometry shader – that is used to specify the zero-based index of the layer into which rendering will be directed</p>
<p>可实现的效果好比:<br>Cube-Map</p>
<ol>
<li>添加cube_map texture为color attachment到framebuffer中</li>
<li>cube-map texture(2D texture)这里会被划分成六个layer的array texture</li>
<li><p>通过instanced geometry shader生成六个faces（对应六个layer），通过gl_InvocationID和gl_Layer访问六个faces并做相应的projection matrices运算实现Cube_Map Face的效果</p>
</li>
<li><p>Advanced Transform Feedback<br>这里首先要了解下什么是Transform Feeback？<br>Transform feedback can be considered a stage of the OpenGL pipeline that sits after all of the vertex-processing stages and directly before primitive assembly and rasterization. Transform feedback captures vertices as they are assembled into primitives and allow some or all of their attributes to be recorded into buffer objects. (Transform feedback发生在所有顶点运算阶段之后（所以如果geometry shader打开了，transform feedback就发生在geometry shader之后，相反是在vertex shader之后），在primitive assembly和光栅化之前。Transform feedback可以保存顶点的一些属性信息用于下一次的运算。)</p>
</li>
</ol>
<p>Why do we need transform feedback?<br>“DirectX10 introduced a new feature known as Stream Output that is very useful for implementing particle systems. OpenGL followed in version 3.0 with the same feature and named it Transform Feedback. The idea behind this feature is that we can connect a special type of buffer (called Transform Feedback Buffer right after the GS (or the VS if the GS is absent) and send our transformed primitives to it. In addition, we can decide whether the primitives will also continue on their regular route to the rasterizer. The same buffer can be connected as a vertex buffer in the next draw and provide the vertices that were output in the previous draw as input into the next draw. This loop enables the two steps above to take place entirely on the GPU with no application involvement (other than connecting the proper buffers for each draw and setting up some state).”</p>
<p>从上面可以看出，transform feedback可以帮助我们在构建primitive之前保存顶点相关的一些信息参与到下一次draw的运算且不用参与到Clipping，rasterizer和FS。最重要的是所有这一切都发生在GPU上，不需要从GPU上copy数据到CPU上做运算。</p>
<p>大致情况如下图：<br><img src="/img/OpenGL/TransformFeedbackFlowchart.PNG" alt="TransformFeedbackFlowchart"></p>
<p>了解一些相关概念：<br>Transform Feedback Objects:<br>“The state required to represent transform feedback is encapsulated into a<br>transform feedback object.”(transform feedback objects主要是存储跟transform feedback相关的一些状态。比如：哪一个buffer绑定到了transform feedback buffer的binding point)</p>
<p>Transform Feedback Buffer:<br>vertex shader或geometry shader中获取来的信息，这里的TFB是指通过glBindBufferBase之类方法后被绑定到Tansform Feedback Objects上的buffer</p>
<p>glBindBufferBase调用的时候需要指定index作为binding point，如果我们想要把Transform Feedback Buffer的数据存储在多个buffer的时候我们可以把多个buffer绑定到不同的binding point上，然后通过glTransformFeedbackVaryings传入的参数格式决定我们生成的数据是如何写入到各个buffer里的。</p>
<p>具体的glTransformFeedbackVaryings如何配置决定数据是如何写入到各个buffer的参见OpenGL红宝书Configuring Transform Feedback Varyings</p>
<p>接下来我们看看通过Transform Feedback实现Particle System的步骤：</p>
<ol>
<li><p>生成Transform Feedback Objets和用于存储数据的buffer,并将buffer绑定到特定Transform Feedback Objects上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ParticleSystem::InitParticleSystem(<span class="keyword">const</span> Vector3f&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    Particle Particles[MAX_PARTICLES];</span><br><span class="line">	ZERO_MEM(Particles);</span><br><span class="line">    <span class="comment">//Particle System最初的那个发射点信息</span></span><br><span class="line">	Particles[<span class="number">0</span>].Type = PARTICLE_TYPE_LAUCHER;</span><br><span class="line">	Particles[<span class="number">0</span>].Pos = pos;</span><br><span class="line">	Particles[<span class="number">0</span>].Vel = Vector3f(<span class="number">0.0f</span>, <span class="number">0.0001f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	Particles[<span class="number">0</span>].LifetimeMillis = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//生成2个transform feedback object和两个buffer</span></span><br><span class="line">    <span class="comment">//"OpenGL enforces a general limitation that the same resource cannot be bound for both input and output in the same draw call. //This means that if we want to update the particles in a vertex buffer we actually need two transform feedback buffers and toggle between them. //On frame 0 we will update the particles in buffer A and render the particles from buffer B and on frame 1 we will update the particles in buffer B and render the particles from buffer "</span></span><br><span class="line">    <span class="comment">//从上面可以看出我们之所以生成两个Transform Feedback Object和两个buffer是因为OpenGL要求我们不能在一次draw call里把同一个resource(这里指TFB和buffer)即作为输入也作为输出</span></span><br><span class="line">    <span class="comment">//所以我们想要通过fist pass去记录一些数据信息，然后再将其渲染到屏幕上，我们必须通过切换两个TFO和buffer来实现</span></span><br><span class="line">    <span class="comment">//记录到A的时候用B数据渲染，记录到B的时候通过A数据来渲染</span></span><br><span class="line">	glGenTransformFeedbacks(<span class="number">2</span>, m_TransformFeedback);</span><br><span class="line"></span><br><span class="line">	glGenBuffers(<span class="number">2</span>, m_ParticleBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//绑定TFO，使得接下来在TFB上的操作是跟特定TFO(transform feedback object)挂钩的</span></span><br><span class="line">		glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, m_TransformFeedback[i]);</span><br><span class="line">		glBindBuffer(GL_ARRAY_BUFFER, m_ParticleBuffer[i]);</span><br><span class="line">		glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Particles), Particles, GL_DYNAMIC_DRAW);</span><br><span class="line">		<span class="comment">//绑定对应buffer的对应的TFO上</span></span><br><span class="line">		glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, m_ParticleBuffer[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Transform Feedback Varyings(指定我们会如何在GS中去如何记录和存储哪些信息)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PSUpdateTechnique::Init()</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> GLchar* Varyings[<span class="number">4</span>];    </span><br><span class="line">    Varyings[<span class="number">0</span>] = <span class="string">"Type1"</span>;</span><br><span class="line">    Varyings[<span class="number">1</span>] = <span class="string">"Position1"</span>;</span><br><span class="line">    Varyings[<span class="number">2</span>] = <span class="string">"Velocity1"</span>;    </span><br><span class="line">    Varyings[<span class="number">3</span>] = <span class="string">"Age1"</span>;</span><br><span class="line">    <span class="comment">//在链接Update Shader之前，我们需要指明TFB会如何去记录和存储数据信息</span></span><br><span class="line">    <span class="comment">//这里指明了我们会在GS中去记录Varyings中四个变量的数据信息到TFB中</span></span><br><span class="line">    <span class="comment">//GL_INTERLEAVED_ATTRIBS表示我们会把所有的attribute数据都记录到一个buffer里   </span></span><br><span class="line">    glTransformFeedbackVaryings(m_shaderProg, <span class="number">4</span>, Varyings, GL_INTERLEAVED_ATTRIBS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Finalize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置设定一些Update Shader和Billboard Shader的一些数据信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ParticleSystem::InitParticleSystem(<span class="keyword">const</span> Vector3f&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_UpdateTechnique.Init())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_UpdateTechnique.Enable();</span><br><span class="line"></span><br><span class="line">	m_UpdateTechnique.SetRandomTextureUnit(RANDOM_TEXTURE_UNIT_INDEX);</span><br><span class="line">	m_UpdateTechnique.SetLauncherLifetime(<span class="number">100.0f</span>);</span><br><span class="line">	m_UpdateTechnique.SetShellLifetime(<span class="number">10000.0f</span>);</span><br><span class="line">	m_UpdateTechnique.SetSecondaryShellLifetime(<span class="number">2500.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_RandomTexture.InitRandomTexture(<span class="number">1000</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_RandomTexture.Bind(RANDOM_TEXTURE_UNIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_BillboardTechnique.Init())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_BillboardTechnique.Enable();</span><br><span class="line"></span><br><span class="line">	m_BillboardTechnique.SetColorTextureUnit(COLOR_TEXTURE_UNIT_INDEX);</span><br><span class="line"></span><br><span class="line">	m_BillboardTechnique.SetBillboardSize(<span class="number">0.01f</span>);</span><br><span class="line"></span><br><span class="line">	m_PTexture = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/fireworks_red.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_PTexture-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GLCheckError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次Draw Call，两个Pass，一个Pass去更新TFB里的数据，一个Pass去渲染TFB里的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	gParticleSystem.Render(deltatimemillis, p.GetVPTrans(), pGameCamera-&gt;GetPos());</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ParticleSystem::Render(<span class="keyword">int</span> deltatimemillis, <span class="keyword">const</span> Matrix4f&amp; vp, <span class="keyword">const</span> Vector3f&amp; camerapos)</span><br><span class="line">&#123;</span><br><span class="line">	m_Time += deltatimemillis;</span><br><span class="line">	<span class="comment">//因为Shader里会去模拟真实重力和粒子移动效果，所以Update的时候需要delta time</span></span><br><span class="line">	UpdateParticles(deltatimemillis);</span><br><span class="line"></span><br><span class="line">	RenderParticles(vp, camerapos);</span><br><span class="line">	<span class="comment">//这里就是我们之前说的通过切换两个TFO和buffer来实现一边更新TFB一边渲染TFB的效果</span></span><br><span class="line">	m_CurrVB = m_CurrTFB;</span><br><span class="line">	m_CurrTFB = (m_CurrTFB + <span class="number">1</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ParticleSystem::UpdateParticles(<span class="keyword">int</span> deltamillis)</span><br><span class="line">&#123;</span><br><span class="line">	m_UpdateTechnique.Enable();</span><br><span class="line">	m_UpdateTechnique.SetTime(m_Time);</span><br><span class="line">	m_UpdateTechnique.SetDeltaTimeMillis(deltamillis);</span><br><span class="line"></span><br><span class="line">	m_RandomTexture.Bind(RANDOM_TEXTURE_UNIT);</span><br><span class="line">    <span class="comment">//这里之所以调用glEnable(GL_RASTERIZER_DISCARD)是因为在Update Pass时，我们不需要进入RS阶段，所以这里关闭了Rasterizer</span></span><br><span class="line">	glEnable(GL_RASTERIZER_DISCARD);</span><br><span class="line">    <span class="comment">//Update Pass的时候，我们把m_ParticleBuffer[m_CurrVB]作为数据输入</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, m_ParticleBuffer[m_CurrVB]);</span><br><span class="line">	<span class="comment">//通过绑定m_TransformFeedback[m_CurrTFB]到GL_TRANSFORM_FEEDBACK，我们把GS里生成的数据存储到绑定了m_TransformFeedback[m_CurrTFB]的m_ParticleBuffer[m_CurrTFB] buffer里</span></span><br><span class="line">	<span class="comment">//这里就是我们说的A作为输入，B作为输出</span></span><br><span class="line">	glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, m_TransformFeedback[m_CurrTFB]);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">1</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), <span class="number">0</span>);                          <span class="comment">// type</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">4</span>);         <span class="comment">// position</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">2</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">16</span>);        <span class="comment">// velocity</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">3</span>, <span class="number">1</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">28</span>);          <span class="comment">// lifetime</span></span><br><span class="line">    <span class="comment">//激活Transform Feedback，指明GS输出的primitive type</span></span><br><span class="line">	glBeginTransformFeedback(GL_POINTS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_IsFirst)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//只有第一次我们是知道我们会draw的Point数量（因为particle发射器只有一个）</span></span><br><span class="line">		glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		m_IsFirst = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//第二次以后，顶点数量是未知的，因为GS是可以生成多个顶点数据的。</span></span><br><span class="line">		<span class="comment">//"The system automatically tracks the number of vertices for us for each buffer and later uses that number internally when the buffer is used for input. "</span></span><br><span class="line">		<span class="comment">//从上面可知，transfor feedback buffer里的顶点数量系统会自己去track</span></span><br><span class="line">		<span class="comment">//我们只需通知用哪一个TFB绑定的buffer作为数据输入即可</span></span><br><span class="line">		glDrawTransformFeedback(GL_POINTS, m_TransformFeedback[m_CurrVB]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glEndTransformFeedback();</span><br><span class="line"></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">	glDisableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">	glDisableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">	glDisableVertexAttribArray(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ParticleSystem::RenderParticles(<span class="keyword">const</span> Matrix4f&amp; vp, <span class="keyword">const</span> Vector3f&amp; camerapos)</span><br><span class="line">&#123;</span><br><span class="line">	m_BillboardTechnique.Enable();</span><br><span class="line">	m_BillboardTechnique.SetCameraPosition(camerapos);</span><br><span class="line">	m_BillboardTechnique.SetVP(vp);</span><br><span class="line">	m_PTexture-&gt;Bind(COLOR_TEXTURE_UNIT);</span><br><span class="line">    <span class="comment">//第二Pass的时候，我们需要渲染出图像，所以需要开启Rasterizer</span></span><br><span class="line">	glDisable(GL_RASTERIZER_DISCARD);</span><br><span class="line">    <span class="comment">//这里通过使用之前记录到m_ParticleBuffer[m_CurrTFB]的数据作为输入进行渲染</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, m_ParticleBuffer[m_CurrTFB]);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">4</span>);  <span class="comment">// position</span></span><br><span class="line">    <span class="comment">//绘制并渲染m_TransformFeedback[m_CurrTFB]所绑定的m_ParticleBuffer[m_CurrTFB]里的数据</span></span><br><span class="line">	glDrawTransformFeedback(GL_POINTS, m_TransformFeedback[m_CurrTFB]);</span><br><span class="line"></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是看Update Shader是如何去更新模拟粒子的生成和重力效果的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">ps_update.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in <span class="keyword">float</span> Type;                                                </span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 Position;                                             </span><br><span class="line">layout (location = <span class="number">2</span>) in vec3 Velocity;                                             </span><br><span class="line">layout (location = <span class="number">3</span>) in <span class="keyword">float</span> Age;                                                 </span><br><span class="line">                                                                                    </span><br><span class="line">out <span class="keyword">float</span> Type0;                                                                    </span><br><span class="line">out vec3 Position0;                                                                 </span><br><span class="line">out vec3 Velocity0;                                                                 </span><br><span class="line">out <span class="keyword">float</span> Age0;                                                                     </span><br><span class="line"></span><br><span class="line"><span class="comment">//VS里我们只是正常获取传入的顶点相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    Type0 = Type;                                                                   </span><br><span class="line">    Position0 = Position;                                                           </span><br><span class="line">    Velocity0 = Velocity;                                                           </span><br><span class="line">    Age0 = Age;                                                                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps_update.gs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout(points) in;                                                                  </span><br><span class="line">layout(points) out;                                                                 </span><br><span class="line">layout(max_vertices = <span class="number">30</span>) out;                                                      </span><br><span class="line">                                                                                    </span><br><span class="line">in <span class="keyword">float</span> Type0[];                                                                   </span><br><span class="line">in vec3 Position0[];                                                                </span><br><span class="line">in vec3 Velocity0[];                                                                </span><br><span class="line">in <span class="keyword">float</span> Age0[];                                                                    </span><br><span class="line">                                                                                    </span><br><span class="line">out <span class="keyword">float</span> Type1;                                                                    </span><br><span class="line">out vec3 Position1;                                                                 </span><br><span class="line">out vec3 Velocity1;                                                                 </span><br><span class="line">out <span class="keyword">float</span> Age1;                                                                     </span><br><span class="line">                                                                                    </span><br><span class="line">uniform <span class="keyword">float</span> gDeltaTimeMillis;                                                     </span><br><span class="line">uniform <span class="keyword">float</span> gTime;                                                                </span><br><span class="line">uniform sampler1D gRandomTexture;                                                   </span><br><span class="line">uniform <span class="keyword">float</span> gLauncherLifetime;                                                    </span><br><span class="line">uniform <span class="keyword">float</span> gShellLifetime;                                                       </span><br><span class="line">uniform <span class="keyword">float</span> gSecondaryShellLifetime;                                              </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PARTICLE_TYPE_LAUNCHER <span class="number">0.0f</span>                                                 </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PARTICLE_TYPE_SHELL <span class="number">1.0f</span>                                                    </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PARTICLE_TYPE_SECONDARY_SHELL <span class="number">2.0f</span>                                          </span></span><br><span class="line">       </span><br><span class="line"><span class="comment">//获取随机方向的方法，我们在gRandomTexture里随机写入了1D的数据信息</span></span><br><span class="line"><span class="function">vec3 <span class="title">GetRandomDir</span><span class="params">(<span class="keyword">float</span> TexCoord)</span>                                                   </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">     vec3 Dir = texture(gRandomTexture, TexCoord).xyz;                              </span><br><span class="line">     Dir -= vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);                                                    </span><br><span class="line">     <span class="keyword">return</span> Dir;                                                                    </span><br><span class="line">&#125;                                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    <span class="keyword">float</span> Age = Age0[<span class="number">0</span>] + gDeltaTimeMillis;                                         </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (Type0[<span class="number">0</span>] == PARTICLE_TYPE_LAUNCHER) &#123;</span><br><span class="line">        <span class="comment">//如果粒子发射器life time达到，我们在粒子发射器的位置生成新的粒子（随机方向）                                       </span></span><br><span class="line">        <span class="keyword">if</span> (Age &gt;= gLauncherLifetime) &#123;                                             </span><br><span class="line">            Type1 = PARTICLE_TYPE_SHELL;                                            </span><br><span class="line">            Position1 = Position0[<span class="number">0</span>];                                               </span><br><span class="line">            vec3 Dir = GetRandomDir(gTime/<span class="number">1000.0</span>);                                  </span><br><span class="line">            Dir.y = max(Dir.y, <span class="number">0.5</span>);                                                </span><br><span class="line">            Velocity1 = normalize(Dir) / <span class="number">20.0</span>;                                      </span><br><span class="line">            Age1 = <span class="number">0.0</span>;                                                             </span><br><span class="line">            EmitVertex();                                                           </span><br><span class="line">            EndPrimitive();                                                         </span><br><span class="line">            Age = <span class="number">0.0</span>;                                                              </span><br><span class="line">        &#125;                                                                           </span><br><span class="line">        <span class="comment">//重置并生成新的粒子发射器使其持续生成粒子</span></span><br><span class="line">        Type1 = PARTICLE_TYPE_LAUNCHER;                                             </span><br><span class="line">        Position1 = Position0[<span class="number">0</span>];                                                   </span><br><span class="line">        Velocity1 = Velocity0[<span class="number">0</span>];                                                   </span><br><span class="line">        Age1 = Age;                                                                 </span><br><span class="line">        EmitVertex();                                                               </span><br><span class="line">        EndPrimitive();                                                             </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        <span class="comment">//当当前粒子不是粒子发射器的时候，我们通过传入的delta time去更新粒子的位置持续时间等相关信息</span></span><br><span class="line">        <span class="keyword">float</span> DeltaTimeSecs = gDeltaTimeMillis / <span class="number">1000.0f</span>;                           </span><br><span class="line">        <span class="keyword">float</span> t1 = Age0[<span class="number">0</span>] / <span class="number">1000.0</span>;                                                </span><br><span class="line">        <span class="keyword">float</span> t2 = Age / <span class="number">1000.0</span>;                                                    </span><br><span class="line">        vec3 DeltaP = DeltaTimeSecs * Velocity0[<span class="number">0</span>];                                 </span><br><span class="line">        vec3 DeltaV = vec3(DeltaTimeSecs) * (<span class="number">0.0</span>, -<span class="number">9.81</span>, <span class="number">0.0</span>);                      </span><br><span class="line">        <span class="keyword">if</span> (Type0[<span class="number">0</span>] == PARTICLE_TYPE_SHELL)  &#123;                                     </span><br><span class="line">            <span class="comment">//若当前粒子是第一次粒子发射器发散出的粒子</span></span><br><span class="line">            <span class="comment">//我们通过粒子的持续时间决定是否进入第二次粒子炸裂阶段</span></span><br><span class="line">	        <span class="keyword">if</span> (Age &lt; gShellLifetime) &#123;</span><br><span class="line">	            <span class="comment">//还没达到炸裂时间点，我们仅仅更新该粒子的位置持续时间等相关信息</span></span><br><span class="line">	            Type1 = PARTICLE_TYPE_SHELL;                                        </span><br><span class="line">	            Position1 = Position0[<span class="number">0</span>] + DeltaP;                                  </span><br><span class="line">	            Velocity1 = Velocity0[<span class="number">0</span>] + DeltaV;                                  </span><br><span class="line">	            Age1 = Age;                                                         </span><br><span class="line">	            EmitVertex();                                                       </span><br><span class="line">	            EndPrimitive();                                                     </span><br><span class="line">	        &#125;                                                                       </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当由粒子发射器发散出的粒子达到炸裂时间点的时候，我们通过该粒子所在位置随机生成10个随机方向的粒子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;                                    </span><br><span class="line">                     Type1 = PARTICLE_TYPE_SECONDARY_SHELL;                         </span><br><span class="line">                     Position1 = Position0[<span class="number">0</span>];                                      </span><br><span class="line">                     vec3 Dir = GetRandomDir((gTime + i)/<span class="number">1000.0</span>);                   </span><br><span class="line">                     Velocity1 = normalize(Dir) / <span class="number">20.0</span>;                             </span><br><span class="line">                     Age1 = <span class="number">0.0f</span>;                                                   </span><br><span class="line">                     EmitVertex();                                                  </span><br><span class="line">                     EndPrimitive();                                                </span><br><span class="line">                &#125;                                                                   </span><br><span class="line">            &#125;                                                                       </span><br><span class="line">        &#125;                                                                           </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进入到第二次发散阶段的粒子，如果还在生命时间内，我们就更新起位置持续时间等相关信息，否则直接略过该粒子(即粒子消亡)                                </span></span><br><span class="line">            <span class="keyword">if</span> (Age &lt; gSecondaryShellLifetime) &#123;                                    </span><br><span class="line">                Type1 = PARTICLE_TYPE_SECONDARY_SHELL;                              </span><br><span class="line">                Position1 = Position0[<span class="number">0</span>] + DeltaP;                                  </span><br><span class="line">                Velocity1 = Velocity0[<span class="number">0</span>] + DeltaV;                                  </span><br><span class="line">                Age1 = Age;                                                         </span><br><span class="line">                EmitVertex();                                                       </span><br><span class="line">                EndPrimitive();                                                     </span><br><span class="line">            &#125;                                                                       </span><br><span class="line">        &#125;                                                                           </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">&#125;                                                                                   </span><br><span class="line"></span><br><span class="line">ps_update.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"><span class="comment">//因为Update Shader只负责update粒子信息，不许要渲染，所以这里ps_update.fs为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终的通过transform feedback生成的粒子信息会通过billboard一一渲染出来</span></span><br><span class="line">billboard.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line"><span class="comment">//这里只需要粒子的位置信息即可                                                         </span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    gl_Position = vec4(Position, <span class="number">1.0</span>);                                              </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">billboard.gs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout(points) in;                                                                  </span><br><span class="line">layout(triangle_strip) out;                                                         </span><br><span class="line">layout(max_vertices = <span class="number">4</span>) out;                                                       </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gVP;                                                                   </span><br><span class="line">uniform vec3 gCameraPos;                                                            </span><br><span class="line">uniform <span class="keyword">float</span> gBillboardSize;                                                       </span><br><span class="line">                                                                                    </span><br><span class="line">out vec2 TexCoord;                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    vec3 Pos = gl_in[<span class="number">0</span>].gl_Position.xyz;                                            </span><br><span class="line">    vec3 toCamera = normalize(gCameraPos - Pos);                                    </span><br><span class="line">    vec3 up = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);                                                  </span><br><span class="line">    vec3 right = cross(toCamera, up) * gBillboardSize;                              </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos -= right;                                                                   </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">0.0</span>, <span class="number">0.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += gBillboardSize;                                                        </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">0.0</span>, <span class="number">1.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y -= gBillboardSize;                                                        </span><br><span class="line">    Pos += right;                                                                   </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">1.0</span>, <span class="number">0.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += gBillboardSize;                                                        </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    EndPrimitive();                                                                 </span><br><span class="line">&#125;                                                                                   </span><br><span class="line"></span><br><span class="line">billboard.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">uniform sampler2D gColorMap;                                                        </span><br><span class="line">                                                                                    </span><br><span class="line">in vec2 TexCoord;                                                                   </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    FragColor = texture2D(gColorMap, TexCoord);                                     </span><br><span class="line">    <span class="comment">//过滤掉粒子纹理图片里较白的部分                                                </span></span><br><span class="line">    <span class="keyword">if</span> (FragColor.r &gt;= <span class="number">0.9</span> &amp;&amp; FragColor.g &gt;= <span class="number">0.9</span> &amp;&amp; FragColor.b &gt;= <span class="number">0.9</span>) &#123;           </span><br><span class="line">        discard;                                                                    </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过glDEBugger我们可以查看到Transform Feedback生成的数据信息：<br><img src="/img/OpenGL/TransformFeedbackBufferData.PNG" alt="TransformFeedbackBufferData"></p>
<p>Final Effect:<br><img src="/img/OpenGL/ParticleSystem.PNG" alt="ParticleSystem"></p>
<h2 id="OpenGL_Utility">OpenGL Utility</h2><h3 id="Open_Asset_Import_Library">Open Asset Import Library</h3><p>“Open Asset Import Library is a portable Open Source library to import various well-known 3D model formats in a uniform manne”</p>
<p><a href="http://www.assimp.org/" target="_blank" rel="external">官方网站</a></p>
<h4 id="assimp">assimp</h4><p>“assimp is a library to load and process geometric scenes from various data formats. It is tailored at typical game scenarios by supporting a node hierarchy, static or skinned meshes, materials, bone animations and potential texture data. The library is not designed for speed, it is primarily useful for importing assets from various sources once and storing it in a engine-specific format for easy and fast every-day-loading. “</p>
<p><a href="http://www.assimp.org/lib_html/index.html" target="_blank" rel="external">官方文档</a></p>
<p>Note:<br>个人理解，assimp主要是提供了对多种格式模型的数据解析，并抽象了所有数据到aiScene这个类里。<br>通过aiScene我们可以去访问模型数据里的顶点数据，纹理数据，材质数据等。<br>我们通过这些数据最终去作为我们的顶点数据创建顶点buffer，作为纹理数据创建纹理贴图，最终绘制出我们的模型。</p>
<p>源代码参考OpenGL Tutorial 22</p>
<h4 id="open3mod">open3mod</h4><p>“open3mod is a Windows-based model viewer. It loads all file formats that Assimp supports and is perfectly suited to quickly inspect 3d assets.”</p>
<p>主要用于快速查看各种资源格式的模型。<br><img src="/img/OpenGL/Open3mod.PNG" alt="Open3modUsing"></p>
<h3 id="GIMP">GIMP</h3><p>GNU Image Manipulation Program (GIMP) is a cross-platform image editor available for GNU/Linux, OS X, Windows and more operating systems.<br><a href="http://www.gimp.org/" target="_blank" rel="external">GIMPDownloadLink</a></p>
<p>gimp-normalmap plugin that supports to export normal map from texture<br><a href="https://code.google.com/archive/p/gimp-normalmap/" target="_blank" rel="external">gimp-normalmapDownloadLink</a></p>
<p>通过GIMP和gimp-normalmap插件，我们可以从texture中导出normal map使用。</p>
<h3 id="GLSL_Debuger">GLSL Debuger</h3><h4 id="Nsight">Nsight</h4><p><a href="http://www.nvidia.com/object/nsight.html" target="_blank" rel="external">NVIDIA® Nsight™ is the ultimate development platform for heterogeneous computing. Work with powerful debugging and profiling tools that enable you to fully optimize the performance of the CPU and GPU. - See more at: http://www.nvidia.com/object/nsight.html#sthash.Hc8TfPMs.dpuf</a><br>Nsight是NVIDIA开发的一套协助GPU开发的工具。<br>优点：</p>
<ol>
<li>支持直接调试GLSL和HLSL等着色器语言</li>
<li>和VS完美集成</li>
</ol>
<p>缺点：</p>
<ol>
<li>硬件限制比较多（比如主要针对NVIDIA公司的显卡）<br><a href="https://developer.nvidia.com/nsight-visual-studio-edition-requirements" target="_blank" rel="external">Nsight Visual Studio Edition Requirements</a></li>
</ol>
<h3 id="OpenGL_proiler,_debugger">OpenGL proiler, debugger</h3><h4 id="gDEBugger">gDEBugger</h4><p>gDEBugger是一个针对OpenGL和OpenCL开发的一套调试器，分析器和内存分析器等协助工具。<br>通过gDEBugger我们可以查看在某一贞关于OpenGL相关的大量信息（比如Uniform值，OpenGL的各个状态，Draw call次数等）<br>可以查看到OpenGL的一些状态，比如GL_CULL_FACE:<br><img src="/img/OpenGL/gDEBuggerCapture.PNG" alt="gDEBuggerCapture"></p>
<p>可以查看Shader的一些信息，并且可以编译Shader等：<br><img src="/img/OpenGL/gDEBuggerShaderInfo.PNG" alt="gDEBuggerShaderInfo"></p>
<h1 id="Reference_Website:">Reference Website:</h1><p><a href="http://www.opengl.org/sdk/docs/man4/" target="_blank" rel="external">OpenGL 4 reference page</a><br><a href="http://blog.csdn.net/guolihui112/article/details/5702915" target="_blank" rel="external">client-server 模式</a><br><a href="http://www.glprogramming.com/blue/ch01.html" target="_blank" rel="external">OpenGL Execute Model</a><br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a><br><a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">OpenGL Tutorial</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGL Windows &amp; Context</a><br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a><br><a href="https://www.opengl.org/wiki/OpenGL_Context" target="_blank" rel="external">OpenGL Context</a><br><a href="https://open.gl/context" target="_blank" rel="external">Window and OpenGL context</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGLBook.com Getting Started</a></p>
<p>Note:<br><strong>OpenGL uses right-handed coordinate system (OpenGL使用右手坐标系)</strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Rendering/">Rendering</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OpenGL/">OpenGL</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/" data-title="OpenGL_Study | 走停人生路" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/29/Computer-Graphic-Study/" title="Computer_Graphic_Study">
  <strong>上一篇：</strong><br/>
  <span>
  Computer_Graphic_Study</span>
</a>
</div>


<div class="next">
<a href="/2015/08/15/CSharp-Study/"  title="C# Study">
 <strong>下一篇：</strong><br/> 
 <span>C# Study
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/26/OpenGL-Study/" data-title="OpenGL_Study" data-url="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard_&&_Mouse_Control"><span class="toc-number">1.4.9.</span> <span class="toc-text">Keyboard && Mouse Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture_Mapping"><span class="toc-number">1.4.10.</span> <span class="toc-text">Texture Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light_and_Shadow"><span class="toc-number">1.4.11.</span> <span class="toc-text">Light and Shadow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Skybox"><span class="toc-number">1.4.12.</span> <span class="toc-text">Skybox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Normal_Mapping"><span class="toc-number">1.4.13.</span> <span class="toc-text">Normal Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BillBoard_And_Geometry_Shader"><span class="toc-number">1.4.14.</span> <span class="toc-text">BillBoard And Geometry Shader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Utility"><span class="toc-number">1.5.</span> <span class="toc-text">OpenGL Utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_Asset_Import_Library"><span class="toc-number">1.5.1.</span> <span class="toc-text">Open Asset Import Library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assimp"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">assimp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open3mod"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">open3mod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIMP"><span class="toc-number">1.5.2.</span> <span class="toc-text">GIMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL_Debuger"><span class="toc-number">1.5.3.</span> <span class="toc-text">GLSL Debuger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nsight"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Nsight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_proiler,_debugger"><span class="toc-number">1.5.4.</span> <span class="toc-text">OpenGL proiler, debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gDEBugger"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">gDEBugger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game-Engine/" title="Game_Engine">Game_Engine<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sort/" title="Sort">Sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Tony Tang. <br/>
			This is my new blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"TonyTang1990"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
