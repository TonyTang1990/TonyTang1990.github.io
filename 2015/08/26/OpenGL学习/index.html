
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>OpenGL学习 | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL学习">
<meta property="og:url" content="http://tonytang1990.github.io/2015/08/26/OpenGL学习/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGL_Render_Pipeline.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GLViewer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/OpenGLWindow.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingOpenGL.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UsingShader.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/UniformVariable.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Interpolation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinateTranslation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/CameraCoordinate2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject1.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject3.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PerspectiveProject4.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MouseAndKeyboardStudy.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TextureConcepts.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TextureCoordinate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/BasicTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/texture1.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/texture2.jpg">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MultipleTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Ambient.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Diffuse.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularModle.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularModle2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpecularCalculation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PointLightFormulation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpotLight.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpotLightCutoffMapping.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShaowMapFirstPass.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShaowMapFirstPassCreate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/MyTextureList.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DemoTextureList.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShadowMapFirstPassSuccessful.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ShadowMapFinal.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SkyboxTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Skybox.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TangentSpaceCaculation.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TangentSpaceDeduce.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TangentSpaceDeduce2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/NormalMapTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/NormalMappingAndRegularMapping.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ParallaxMappinge.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ParallaxMappinge2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Geometry_Shader_Fur.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Multiple_Viewports.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TransformFeedbackFlowchart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GSBillboard.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TransformFeedbackBufferData.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ParticleSystem.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/StreamDeclaration.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/SpiderMeshTree.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/PickingTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/3DPicking.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TessellationShaderProcess.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Domains.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TriangleDomainSubdivision.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TessellationFill.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TessellationClose.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TessellationFar.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/TessellationHeightMap.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/AOSAndSOA.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/VAOFinalEffect.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/InstancedRendering.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/GLFX.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/ForwardRendering.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DeferredShading.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/G-Buffer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DeferredShading_GeometryPass.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DSStart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DSClose.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DSSourceCode.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/StencilBufferEffect.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DeferredShadingStencilBufferUsing.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/DeferredShadingFinalEffect.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/Open3mod.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/gDEBuggerCapture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/OpenGL/gDEBuggerShaderInfo.PNG">
<meta property="og:updated_time" content="2019-03-04T16:42:43.051Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenGL学习">
<meta name="twitter:description" content="时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好  — 游戏梦
参考书籍：《OpenGL Programming Guide 8th Edition》 — Addison Wesley《Fundamentals of Computer Graphics (3rd Edition)》 — Peter">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">做着独立游戏梦，坚持走在游戏开发道路上的人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/26/OpenGL学习/" title="OpenGL学习" itemprop="url">OpenGL学习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2015-08-26T15:57:05.000Z" itemprop="datePublished"> 發表於 2015-08-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_render_pipeline"><span class="toc-number">1.2.1.</span> <span class="toc-text">OpenGL render pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Shader_Language_(GLSL)"><span class="toc-number">1.2.2.</span> <span class="toc-text">OpenGL Shader Language (GLSL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The_color_space_in_OpenGL"><span class="toc-number">1.2.3.</span> <span class="toc-text">The color space in OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-obj_and_-mtl_file_format"><span class="toc-number">1.2.4.</span> <span class="toc-text">.obj and .mtl file format</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard_&&_Mouse_Control"><span class="toc-number">1.4.9.</span> <span class="toc-text">Keyboard && Mouse Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture_Mapping"><span class="toc-number">1.4.10.</span> <span class="toc-text">Texture Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light_and_Shadow"><span class="toc-number">1.4.11.</span> <span class="toc-text">Light and Shadow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Skybox"><span class="toc-number">1.4.12.</span> <span class="toc-text">Skybox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Normal_Mapping"><span class="toc-number">1.4.13.</span> <span class="toc-text">Normal Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BillBoard_And_Geometry_Shader"><span class="toc-number">1.4.14.</span> <span class="toc-text">BillBoard And Geometry Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D_Picking"><span class="toc-number">1.4.15.</span> <span class="toc-text">3D Picking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic_Tessellation"><span class="toc-number">1.4.16.</span> <span class="toc-text">Basic Tessellation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vertex_Array_Objects"><span class="toc-number">1.4.17.</span> <span class="toc-text">Vertex Array Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instanced_Rendering"><span class="toc-number">1.4.18.</span> <span class="toc-text">Instanced Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLFX_-_An_OpenGL_Effect_Library"><span class="toc-number">1.4.19.</span> <span class="toc-text">GLFX - An OpenGL Effect Library</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deferred_Shading"><span class="toc-number">1.4.20.</span> <span class="toc-text">Deferred Shading</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Utility"><span class="toc-number">1.5.</span> <span class="toc-text">OpenGL Utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_Asset_Import_Library"><span class="toc-number">1.5.1.</span> <span class="toc-text">Open Asset Import Library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assimp"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">assimp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open3mod"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">open3mod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIMP"><span class="toc-number">1.5.2.</span> <span class="toc-text">GIMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL_Debuger"><span class="toc-number">1.5.3.</span> <span class="toc-text">GLSL Debuger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nsight"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Nsight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_proiler,_debugger"><span class="toc-number">1.5.4.</span> <span class="toc-text">OpenGL proiler, debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gDEBugger"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">gDEBugger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
		
		</div>
		
		<p><strong>时隔将近一年了，再次拾起了还未学完的OpenGL，这一年工作生活学习状态都不好，希望这一次能重新好好的把OpenGL学好，把图形渲染的基础知识掌握好</strong>  — 游戏梦</p>
<p>参考书籍：<br>《OpenGL Programming Guide 8th Edition》 — Addison Wesley<br>《Fundamentals of Computer Graphics (3rd Edition)》 — Peter Shirley, Steve Marschnner<br>《Real-Time Rendering, Third Edition》 — Tomas Akenine-Moller, Eric Haines, Naty Hoffman</p>
<p><a href="http://blog.sina.com.cn/tonytang1990" target="_blank" rel="external">旧博客地址</a></p>
<p><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/">渲染相关概念学习</a></p>
<h1 id="OpenGL">OpenGL</h1><h2 id="Introdction_to_OpenGL">Introdction to OpenGL</h2><h3 id="What_is_OpenGL?">What is OpenGL?</h3><ol>
<li>OpenGL is an application programming interface – “API” for short – which is merely a software library for accessing features in graphics hardware.(访问图形硬件设备功能的API)</li>
<li>OpenGL is a “C” language library(OpenGL是一个C语言库)</li>
</ol>
<h3 id="History">History</h3><p>It was first developed at Silicon Graphics Computer Systems with Version 1,0 released in July of 1994(<a href="https://zh.wikipedia.org/zh/OpenGL" target="_blank" rel="external">wiki</a>)</p>
<h3 id="Next_Generation_OpenGL">Next Generation OpenGL</h3><p><a href="https://en.wikipedia.org/wiki/Vulkan_%28API%29" target="_blank" rel="external">Vulkan</a></p>
<h2 id="OpenGL_relative_knowledge">OpenGL relative knowledge</h2><h3 id="OpenGL_render_pipeline">OpenGL render pipeline</h3><p><img src="/img/OpenGL/OpenGL_Render_Pipeline.PNG" alt="OpenGL Render Pipeline"></p>
<ol>
<li><p>Vertex Data<br> Sending Data to OpenGL</p>
</li>
<li><p>Vertex Shader<br> Process the data associated with that vertex</p>
</li>
<li><p>Tessellation Shader<br> Tessellation uses patchs to describe an object’s shape, and allows relatively simple collections of patch geometry to be tessellated to increase the number of geometric primitives providing better-looking models (eg: LOD) </p>
</li>
<li><p>Geometry Shader<br> Allows additional processing of individual geometric primitives, including creating new ones, before rasterization</p>
</li>
<li><p>Primitive Assembly<br>Organizes the vertices into their associated geometric primitives in preparation for clipping and rasterization </p>
</li>
<li><p>Clipping<br> Clip the vertex and pixels are outside of the viewport – this operation is handled automatically by OpenGL</p>
</li>
<li><p>Rasterization<br> Fragment generation. Pixels have a home in the framebuffer, while a fragment still can be rejected and never update its associated pixel location. </p>
</li>
<li><p>Fragment Shading<br> Use a fragment shading to determine the fragment’s final color, and potentially its depth value</p>
</li>
<li><p>Per-Fragment Operations<br> If a fragment successfully makes it through all of the enabled tests (eg: depth testing, stencil testing), it may be written directly to the framebuffer, updating the color of its pixel, or if blending is enabled, the fragment’s color will be combined with the pixel’s current color to generate a new color that is written into the framebuffer</p>
</li>
</ol>
<p>Note:<br>Fragment’s visibility is determined using depth testing and stencil testing<br>Pixel data is usually stored in texture map for use with texture mapping, which allows any texture stage to look up data values from one or more texture maps.</p>
<h3 id="OpenGL_Shader_Language_(GLSL)"><a href="http://zh.wikipedia.org/wiki/GLSL" target="_blank" rel="external">OpenGL Shader Language (GLSL)</a></h3><p>GLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。</p>
<p>编译和执行<br>GLSL 着色器不是独立的应用程式；其需要使用 OpenGL API 的应用程式。C、C++、C#、Delphi 和 Java 皆支援 OpenGL API，且支援 OpenGL 着色语言。<br>GLSL 着色器本身只是简单的字串集，这些字串集会传送到硬件厂商的驱动程式，并从程式内部的 OpenGL API 进入点编译。着色器可从程式内部或读入纯文字档来即时建立，但必须以字串形式传送到驱动程式。</p>
<p>工具<br>GLSL 着色器可以事先建立和测试，现有以下 GLSL 开发工具：<br>RenderMonkey - 这个软件是由 ATI 制作的，提供界面用以建立、编译和除错 GLSL 着色器，和 DirectX 着色器一样。仅能在 Windows 平台上执行。<br>GLSLEditorSample - 在 Mac OS X 上，它是目前唯一可用的程式，其提供着色器的建立和编译，但不能除错。它是 cocoa 应用程式，仅能在 Mac OS X 上执行。<br>Lumina - Lumina 是新的 GLSL 开发工具。其使用 QT 界面，可以跨平台。</p>
<h3 id="The_color_space_in_OpenGL">The color space in OpenGL</h3><p>In OpenGL, colors are represented in what’s called the RGB color space</p>
<h3 id="-obj_and_-mtl_file_format">.obj and .mtl file format</h3><p>参考文章:<br><a href="http://www.cnblogs.com/avril/archive/2010/08/06/1794437.html" target="_blank" rel="external">obj文件基本结构及读取 - 计算机图形学</a><br><a href="http://blog.csdn.net/sunyong_shj/article/details/15811173" target="_blank" rel="external"> 3D模型-OBJ材质文件 MTL格式分析 </a><br><a href="http://www.07net01.com/linux/_mtlwenjiangeshijiexi____jianmo__39917_1355121996.html" target="_blank" rel="external">.mtl文件格式解析 - [建模]</a></p>
<p>“OBJ文件不包含面的颜色定义信息，不过可以引用材质库，材质库信息储存在一个后缀是”.mtl”的独立文件中。关键字”mtllib”即材质库的意思。 材质库中包含材质的漫射(diffuse)，环境(ambient)，光泽(specular)的RGB(红绿蓝)的定义值，以及反射(specularity)，折射(refraction)，透明度(transparency)等其它特征。  “usemtl”指定了材质之后，以后的面都是使用这一材质，直到遇到下一个”usemtl”来指定新的材质。”</p>
<p>.obj的一些基本内容格式描述： </p>
<pre><code><span class="string">'#'</span> 这个就相当于<span class="keyword">C</span>++代码里面的//，如果一行开始时#，那么就可以理解为这一行完全是注释，解析的时候可以无视

g 这个应该是geometry的缩写，代表一个网格，后面的是网格的名字。

v v是Vertex的缩写，很简单，代表一个顶点的局部坐标系中的坐标，可以有三个到四个分量。我之分析了三个分量，因为对于正常的三角形的网格来说，第四个分量是<span class="number">1</span>，可以作为默认情况忽略。如果不是<span class="number">1</span>，那可能这个顶点是自由曲面的参数顶点，这个我们这里就不分析了，因为大部分的程序都是用三角形的。

vn 这个是Vertex <span class="keyword">Normal</span>，就是代表法线，这些向量都是单位的，我们可以默认为生成这个obj文件的软件帮我们做了单位化。

vt  这个是Vertex <span class="keyword">Texture</span> Coordinate，就是纹理坐标了，一般是两个，当然也可能是一个或者三个，这里我之分析两个的情况。

mtllib &lt;matFileName&gt; 这个代表后面的名字是一个材质描述文件的名字，可以根据后面的名字去找相应的文件然后解析材质。

usemtl &lt;matName&gt; 这里是说应用名字为matName的材质，后面所有描述的面都是用这个材质，直到下一个usemtl。

f 这里就是face了，真正描述面的关键字。后面会跟一些索引。一般索引的数量是三个，也可能是四个（OpenGL里面可以直接渲染四边形，Dx的话只能分成两个三角形来渲染了）。每个索引数据中可能会有顶点索引，法线索引，纹理坐标索引，以/分隔。
</code></pre><p>.mtl文件（Material Library File）是材质库文件，描述的是物体的材质信息，ASCII存储，任何文本编辑器可以将其打开和编辑。一个.mtl文件可以包含一个或多个材质定义，对于每个材质都有其颜色，纹理和反射贴图的描述，应用于物体的表面和顶点。”<br>.mtl的一些基本内容格式描述：</p>
<pre><code>以下是一个材质库文件的基本结构：
newmtl mymtl_1
材质颜色光照定义
纹理贴图定义
反射贴图定义
……

注释：每个材质库可含多个材质定义，每个材质都有一个材质名。用newmtl mtlName来定义一个材质。对于每个材质，可定义它的颜色光照纹理反射等描述特征。主要的定义格式如下文所示：

<span class="comment">////////////////////////////////////////////////</span>
材质颜色光照
1。环境反射有以下三种描述格式，三者是互斥的，不能同时使用。
Ka r <span class="keyword">g</span> b ——用RGB颜色值来表示，<span class="keyword">g</span>和b两参数是可选的，如果只指定了r的值，则<span class="keyword">g</span>和b的值都等于r的值。三个参数一般取值范围为0.0~1.0，在此范围外的值则相应的增加或减少反射率;
Ka spectral <span class="keyword">file</span>.rfl <span class="keyword">factor</span> ——用一个rfl文件来表示。<span class="keyword">factor</span>是一个可选参数，表示.rfl文件中值的乘数，默认为1.0;
Ka xyz x y z ——用CIEXYZ值来表示，x，y，z是CIEXYZ颜色空间的各分量值。y和z两参数是可选的，如果只指定了x的值，则y和z的值都等于r的值。三个参数一般取值范围为0~1。

2。漫反射描述的三种格式：
Kd r <span class="keyword">g</span> b
Kd spectral <span class="keyword">file</span>.rfl <span class="keyword">factor</span>
Kd xyz x y z

3。镜反射描述的三种格式:
Ks r <span class="keyword">g</span> b
Ks spectral <span class="keyword">file</span>.rfl <span class="keyword">factor</span>
Ks xyz x y z

4。滤光透射率描述的三种格式：
Tf r <span class="keyword">g</span> b
Tf spectral <span class="keyword">file</span>.rfl <span class="keyword">factor</span>
Tf xyz x y z

5。光照模型描述格式：

illum illum_#
指定材质的光照模型。illum后面可接0~10范围内的数字参数。各个参数代表的光照模
</code></pre><p>从上面的内容可以看出，.obj是描述关于顶点，法线，面，纹理坐标和材质引用等相关的数据的集合，而.mtl是用于定义实际材质信息的文件。</p>
<p>了解了.obj和.mtl文件里面的内容描述方式，让我们来看看在实际中.obj和.mtl文件内容来学习理解一下，以下内容来源于Modern OpenGL Tutorials — 3D Picking 的spider.obj和spider.mtl<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">spider.obj</span><br><span class="line"><span class="preprocessor"># Wavefront OBJ exported by MilkShape <span class="number">3</span>D</span></span><br><span class="line">mtllib spider.mtl</span><br><span class="line"></span><br><span class="line">v <span class="number">1.160379</span> <span class="number">4.512684</span> <span class="number">6.449167</span></span><br><span class="line">.....</span><br><span class="line"><span class="preprocessor"># <span class="number">762</span> vertices</span></span><br><span class="line"></span><br><span class="line">vt <span class="number">0.186192</span> <span class="number">0.222718</span></span><br><span class="line">.....</span><br><span class="line"><span class="preprocessor"># <span class="number">302</span> texture coordinates</span></span><br><span class="line"></span><br><span class="line">vn -<span class="number">0.537588</span> -<span class="number">0.071798</span> <span class="number">0.840146</span></span><br><span class="line">......</span><br><span class="line"><span class="preprocessor"># <span class="number">747</span> normals</span></span><br><span class="line"></span><br><span class="line">g HLeib01</span><br><span class="line">usemtl HLeibTex</span><br><span class="line">s <span class="number">1</span></span><br><span class="line">f <span class="number">1</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">2</span>/<span class="number">2</span>/<span class="number">2</span> <span class="number">3</span>/<span class="number">3</span>/<span class="number">3</span></span><br><span class="line">......</span><br><span class="line"><span class="preprocessor"># <span class="number">80</span> triangles in group</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># <span class="number">1368</span> triangles total</span></span><br></pre></td></tr></table></figure></p>
<p>从第二行mtllib spider.mtl可以看出spider.obj指定了纹理材质的描述文件是spider.mtl。<br>后续的v, vn, vt, f, g描述了所有的关于顶点，顶点法线，顶点纹理坐标，face， geometry相关的数据信息。<br>而紧跟着g后面usemtl Augentex则描述了该geometry所使用的材质名字是Augentex（这里的材质的具体信息在前面指定的spider.mtl文件中）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># spider.mtl</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"></span><br><span class="line">newmtl Skin</span><br><span class="line">Ka <span class="number">0.200000</span> <span class="number">0.200000</span> <span class="number">0.200000</span></span><br><span class="line">Kd <span class="number">0.827451</span> <span class="number">0.792157</span> <span class="number">0.772549</span></span><br><span class="line">Ks <span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line">Ns <span class="number">0.000000</span></span><br><span class="line">map_Kd .\wal67ar_small.jpg</span><br><span class="line"></span><br><span class="line">newmtl Brusttex</span><br><span class="line">Ka <span class="number">0.200000</span> <span class="number">0.200000</span> <span class="number">0.200000</span></span><br><span class="line">Kd <span class="number">0.800000</span> <span class="number">0.800000</span> <span class="number">0.800000</span></span><br><span class="line">Ks <span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line">Ns <span class="number">0.000000</span></span><br><span class="line">map_Kd .\wal69ar_small.jpg</span><br><span class="line"></span><br><span class="line">newmtl HLeibTex</span><br><span class="line">Ka <span class="number">0.200000</span> <span class="number">0.200000</span> <span class="number">0.200000</span></span><br><span class="line">Kd <span class="number">0.690196</span> <span class="number">0.639216</span> <span class="number">0.615686</span></span><br><span class="line">Ks <span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line">Ns <span class="number">0.000000</span></span><br><span class="line">map_Kd .\SpiderTex.jpg</span><br><span class="line"></span><br><span class="line">newmtl BeinTex</span><br><span class="line">Ka <span class="number">0.200000</span> <span class="number">0.200000</span> <span class="number">0.200000</span></span><br><span class="line">Kd <span class="number">0.800000</span> <span class="number">0.800000</span> <span class="number">0.800000</span></span><br><span class="line">Ks <span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line">Ns <span class="number">0.000000</span></span><br><span class="line">map_Kd .\drkwood2.jpg</span><br><span class="line"></span><br><span class="line">newmtl Augentex</span><br><span class="line">Ka <span class="number">0.200000</span> <span class="number">0.200000</span> <span class="number">0.200000</span></span><br><span class="line">Kd <span class="number">0.800000</span> <span class="number">0.800000</span> <span class="number">0.800000</span></span><br><span class="line">Ks <span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">0.000000</span></span><br><span class="line">Ns <span class="number">0.000000</span></span><br><span class="line">map_Kd .\engineflare1.jpg</span><br></pre></td></tr></table></figure>
<p>第五行newmtl Skin定义了一个材质的名字，后面Ka, Kd, Ks, Ns， map_Kd分别是对该材质的环境反射，漫反射，镜面反射，高光系数，纹理图片的配置。</p>
<p>综合上述的理解，可以看出，当我们通过assimp引用加载spider.obj这个文件的时候，我们会去使用spider.mtl作为材质配置文件去作为读取到的材质相关的信息，从而我们知道了我们需要spider.obj,spider.mtl,wal67ar_small.jpg,wal69ar_small.jpg,SpiderTex.jpg,drkwood2.jpg,engineflare1.jpg这些文件提供我们完整的mesh渲染相关的数据。</p>
<h2 id="OpenGL_learning_journal">OpenGL learning journal</h2><h3 id="API">API</h3><ol>
<li><p>查看哪些错误标志位被设置<br>了解：<br>  OpenGL在内部保留了一组错误标志位(共4个),其中每一个标志位代表一种不同类型的错误。当错误一个发生时，与这个错误对应的标志就会被设置。如果被设置的标志不止一个，glGetError仍然只返回一个唯一的值。当glGetError函数被调用时，这个值随后被清除，然后在glGetError再次被调用时将返回一个错误标志或GL_NO_ERROR为止<br>函数：<br>Glenum glGetError(void); </p>
</li>
<li><p>查询OpenGL的渲染引擎（OpenGL驱动程序）的生产商和版本号<br>了解：<br> OpenGL允许提供商通过它的扩展机制进行创新。为了使用特定供应商所提供的一些特定扩展功能，我们希望限制这个特定供应商所提供驱动程序的最低版本号。<br>函数：<br>const Glubyte *glGetString(GLenum name);</p>
</li>
<li><p>设置和查询管线的状态<br>了解：<br>  OpenGL使用状态模型来跟踪所有的OpenGL状态变量来实现对OpenGL渲染状态的控制<br>函数：<br>void glEnable(GLenum capability);<br>void glDisable(GLenum capability);<br>void glGet<em>(Type)v(GLenum pname, GLboolean </em>params);</p>
</li>
<li><p>查询program的一些相关信息和一些错误信息<br>了解：<br> OpenGL的pragram链接可能由于GLSL里面的一些错误导致出错，我们需要知道关于program object的一些相关错误信息，同时我们也想知道我们现有的program相关的一些信息<br>函数：<br>void glGetProgramiv(GLuint program, GLenum pname, GLint *params);</p>
</li>
<li><p>得到shader链接出错的log信息<br>了解：<br> OpenGL的shader object可能链接失败，我们需要知道shader里面出错的信息<br>函数：<br>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei <em>length, GLchar </em>infoLog);</p>
</li>
</ol>
<p>注意:<br>可以通过glGetProgramiv()去得到program的一些log相关信息，比如GL_INFO_LOG_LENGTH</p>
<h3 id="OpenGL_Knowledge:">OpenGL Knowledge:</h3><ol>
<li><p>“OpenGL Execute Model:<br> The model for interpretation of OpenGL commands is client-server. An application (the client) issues commands, which are interpreted and processed by OpenGL (the server). The server may or may not operate on the same computer as the client. In this sense, OpenGL is network-transparent. “</p>
</li>
<li><p>“client-server 模式:<br> OpenGL 是一种 client-server 模式，当你的应用程序调用 OpenGL 函数时， 它将告诉OpenGL client， 然后 client 将渲染命令传送给 server. 这里client 和 server可能是不同的计算机，或是同一台计算机上的不同进程。一般来说 server 是在 GPU上处理的， 而 client 是在 CPU 上处理的，这样分担了 CPU 的负担， 同时高效利用了GPU.”</p>
</li>
</ol>
<p>但如果Client和Server没在同一个机器上，我们就需要一种一种网络传输协议框架来实现他们之间的交流：<br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a></p>
<p>但X Window System里的client和server与传统的C/S模式相反，client是负责运算的，server是负责显示的。<br>但OpenGL的client和server的交流原理是与X Window System相似的</p>
<h2 id="OpenGL_Practice">OpenGL Practice</h2><h3 id="Check_supported_OpenGL_version">Check supported OpenGL version</h3><ol>
<li>Install the appropriate graphic driver which enables usage of the functionality provided.<br> check the graphic drive update.(更新显卡驱动获得最新的OpenGL版本支持)</li>
<li>Using OpenGL extensions viewer to check which OpenGL version is supported(查看当前硬件所支持的OpenGL版本)<br> <a href="http://www.realtech-vr.com/glview/download.php" target="_blank" rel="external">download website</a></li>
</ol>
<p><img src="/img/OpenGL/GLViewer.PNG" alt="OpenGL_Viewer_Info"><br>从上图可以看出我当前的电脑和显卡驱动支持最高4.4，所以在使用学习OpenGL之前一定要确认好自己电脑所能支持的版本，避免后续不必要的问题。</p>
<p>检查完所支持的OpenGL版本后，下面我们需要介绍两个在学习OpenGL时为了帮助快速学习使用OpenGL的两个重要库（Glut &amp; Glew）</p>
<h3 id="Know_what_Glut_and_Glew_are,_and_how_to_use_them">Know what Glut and Glew are, and how to use them</h3><ol>
<li><p><a href="http://zh.wikipedia.org/wiki/GLUT" target="_blank" rel="external">Glut (OpenGL Utility Toolkit)</a><br> GLUT（英文全写：OpenGL Utility Toolkit）是一个处理OpenGL程式的工具库，负责处理和底层操作系统的呼叫以及I/O，并包括了以下常见的功能：</p>
<ol>
<li>定义以及控制视窗</li>
<li>侦测并处理键盘及鼠标的事件</li>
<li>以一个函数呼叫绘制某些常用的立体图形，例如长方体、球、以及犹他茶壶（实心或只有骨架，如glutWireTeapot()）</li>
<li><p>提供了简单选单列的实现</p>
<p>GLUT是由Mark J. Kilgard在Silicon Graphics工作时所写，此人同时也是OpenGL Programming for the X Window System以及The Cg Tutorial: The Definitive Guide to Programmable Real-Time Graphics两书的作者。</p>
<p>GLUT的两个主要目的是建立一个跨平台的函式库（事实上GLUT就是跨平台的），以及简化学习OpenGL的条件。透过GLUT编写OpenGL通常只需要增加几行额外GLUT的程式码，而且不需要知道每个不同操作系统处理视窗的API。</p>
<p>所有的GLUT函数都以glut作为开头，例如glutPostRedisplay()。</p>
</li>
</ol>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/OpenGL_Extension_Wrangler_Library" target="_blank" rel="external">Glew ( OpenGL Extension Wrangler Library)</a><br> The OpenGL Extension Wrangler Library (GLEW) is a cross-platform C/C++ library that helps in querying and loading OpenGL extensions. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.(Glew是一个支持跨平台的C/C++库，用于运行时鉴别OpenGL扩展所支持的版本)<br> <a href="http://www.opengl.org/sdk/tools/" target="_blank" rel="external">more info for extention tools</a></p>
<p> How to use Glu &amp; Glew?</p>
<ol>
<li>add glu.lib &amp; glew.lib into additional dependencies</li>
<li>add the directory that includes glu.h &amp; glew.h into include dirctory</li>
<li><p>Include GL/freeglut.h &amp; GL/glew.h in source file<br>Note:<br>if you use static link, #define FREEGLUT_STATIC before you include GL/freeglut.h, otherwise it will look for freeglut.lib. #define GLEW_STATIC for Glew.</p>
<p>include GL/glew.h before GL/freeglut.h, otherwise, it will through “fatal error C1189: #error :  gl.h included before glew.h”</p>
</li>
</ol>
</li>
</ol>
<p>Note:<br>后续的学习都是基于<a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">Modern OpenGL Tutorials</a>,后续提到的一些库的源码从该网站下载</p>
<h3 id="Open_a_Window">Open a Window</h3><p>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>OpenGLWindow.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"OpenGLWindow"</span>);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/OpenGLWindow.PNG" alt="OpenGL_Window"></p>
<p>从上面可以看出我们主要是通过调用glut来初始化创建windows窗口<br>通过glut里的API我们可以去设置回调，去实现我们在渲染时期需要设置的OpenGL状态<br>上述主要有四个重要的glut API：</p>
<ol>
<li>glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA) — GLUT_DOULBE开启了双buffer渲染，这样效率更高，一个buffer用于渲染，一个buffer用于填充下一帧数据</li>
<li>glutDisplayFunc — 设置glut里的渲染回调</li>
<li>glutMainLoop — 开启glut里的window event监听</li>
<li>glutCreateWindow — 设定完相关参数后，通过此方法我们能够创建出我们想要的Windows窗口，同时OpenGL Context也在这时候被创建出来</li>
</ol>
<p>Glut还提供了更多的关于Window的功能，后续会学习使用到</p>
<h3 id="Using_OpenGL">Using OpenGL</h3><p>上一章节只是用到了glut去初始化我们最基本的Window窗口，还没真正大量用到OpenGL里API，在使用OpenGL API之前我们需要通过Glew这个工具去检查当前所支持的OpenGL版本，然后才能正确的调用对应的API。</p>
<p>使用Glew的准备工作在How to use Glu &amp; Glew?时已经提到，这里不重述了</p>
<p>因为Glew需要通过context去查找对应所支持的OpenGL版本调用，所以初始化Glew必须在创建OpenGL Context之后。</p>
<p>Note:<br>Call glewInit after glutCreateWindow call successfully</p>
<p>那这里就不得不先了解一下什么是OpenGL Context了？<br>“”OpenGL Context””<br><a href="https://open.gl/context" target="_blank" rel="external">OpenGL context, which is essentially a state machine that stores all data related to the rendering of your application. When your application closes, the OpenGL context is destroyed and everything is cleaned up.</a></p>
<p>结合wiki<a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a>的介绍，这里我理解的不是很清晰，大概是OpenGL的Context相当于Device Context(DC)相对于Windows的概念一样。Context会设定很多跟渲染相关的状态(比如是否使用双buffer，depthbuffer占多少字节，颜色模式，窗口大小等渲染需要的信息)</p>
<p>这里我们只需要知道初始化Glut和调用glutCreateWindow创建窗口后，我们的OpenGL Context就生成了.</p>
<p>这也就是为什么在初始化glew之前必须先初始化Glut和创建Windows窗口的原因。</p>
<p>进一步了解参考：<br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a></p>
<p>Using Glew<br>接下来回到Glew的使用去绘制我们的第一个OpenGL圆点<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>UsingOpenGL.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_POINTS, <span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">1</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，我们初始化glew只是调用了glewInit()方法，但主要一定要在OpenGL context创建完成后调用(即glutCreateWindow窗口创建之后)</p>
<p>我们创建并使用vertext buffer主要由5个步骤：</p>
<ol>
<li>glGenBuffers() — 创建一个可用的buffer obejct</li>
<li>glBindBuffer() — 绑定buffer object到指定的target类型，target类型代表我们的buffer object包含什么样的数据用于什么样的用途</li>
<li>glBufferData() — 填充buffer数据</li>
<li>glVertexAttribPointer() — 指明如何去解析buffer里的数据，同时这里也指明了如何在shader里面访问这些数据(至于如何编写，编译，链接和使用Shader，后续会讲到。)</li>
<li>glDrawArrays() — 调用draw指明如何使用并绘制buffer里面的数据</li>
</ol>
<p>Note：<br>这里需要注意的一点，要想在Shader里访问buffer里面的attribute数据，我们需要在调用draw之前调用glEnableVertexAttribArray()来激活特定的attribute</p>
<p>final result:<br><img src="/img/OpenGL/UsingOpenGL.PNG" alt="OpenGL_Window"></p>
<h3 id="Using_Shader">Using Shader</h3><p><a href="https://en.wikipedia.org/wiki/Shader" target="_blank" rel="external">In the field of computer graphics, a shader is a computer program that is used to do shading: the production of appropriate levels of color within an image, or, in the modern era, also to produce special effects or do video post-processing.</a></p>
<p>上述是Wiki上Shader的定义。Shader是在可编程管线出现后，以程序的形式对渲染的各个阶段进行图形图像上的处理，使渲染变得更加灵活，主要作用于GPU上。</p>
<p>Shader作用于渲染的各个阶段：<br>之前在“Understand OpenGL render pipeline”有讲到各个渲染管线，这里就不再重述。可见Shader作用于大部分管线，比如：Vertex Shader（负责vertex数据处理），Tessellation Shader（负责以图形patch为单位的处理，用于描述物体形状数据，LOD就是在这个阶段实现的），Geometry Shader（以整个图形原件数据作为输入做处理，好比batch rendering可在这个阶段实现），Fragment Shading（以fragment(片元)数据作为输入做处理）</p>
<p>Shader Language在前面的“Understand OpenGL Shader Language”有讲到，这里就不重述了。</p>
<p>从上可见Shader在可编程管线的今天有着多么重要的作用。<br>接下来让我们看看在OpenGL中如何使用Shader吧。</p>
<p>使用Shader主要有下列几个步骤：</p>
<ol>
<li>Create a shader object – glCreateShader(GLenum type)（创建shader对象）</li>
<li>Compile your shader source into the object – glShaderSource(<strong>**</strong>)  glCompileShader(<em>*</em>)（编译shader文件，存储到shader对象中）</li>
<li>Verify that your shader compiled successfully – glGetShaderInfoLog(<em>*</em>)（检查shader编译是否成功并获取错误信息）</li>
<li>Create a shader program – glCreateProgram(void)（创建shader程序）</li>
<li>Attach the appropriate shader objects to the shader program – glAttachShader(GLuint program, Gluint shader)（附加多个shader对象到shader程序中）</li>
<li>Link the shader program – glLinkProgram(GLuint program)（链接shader程序）</li>
<li>Verify that the shader link phase completed successfully – glGetProgramiv() &amp; glGetProgramInfoLog(<em>**</em>)（检查shader程序链接是否成功并获取错误信息）</li>
<li>Use the shader for vertex or fragment processing – glUseProgram(GLuint program)（使用shader程序做顶点处理或片元处理）</li>
</ol>
<p>Shader出错后因为我们快速退出了程序，所以很难看到console的错误信息，所以最好的方式是把错误信息写入文本文件以供后续查看。Utils.h是关于编译和使用Shader并打印错误信息到文本的实现。<br>IncludeFiles.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glew part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Glut part</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FREEGLUT_STATIC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GL/freeglut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_util.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_math_3d.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>Utils.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serializationShaderCompileLog</span><span class="params">(GLuint prog, GLuint shader, GLenum type, <span class="keyword">char</span> *<span class="built_in">log</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *stage_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">switch</span>(type)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_VERTEX_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_GEOMETRY_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_GEOMETRY_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		<span class="built_in">sprintf</span>(temp, <span class="string">"program%d-shader%d-%s"</span>, prog, shader, <span class="string">"GL_FRAGMENT_SHADER"</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(stage_name,temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//strcpy(stage_name,"program:" + prog + "shader:" + shader + "stage:" + "GL_FRAGMENT_SHADER");</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"program:"</span>&lt;&lt;prog&lt;&lt;<span class="string">"-shader:"</span>&lt;&lt;shader&lt;&lt;<span class="string">"-stage:"</span>&lt;&lt;stage_name&lt;&lt;<span class="string">" compile log:"</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">log</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *file_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(file_name,stage_name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(file_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(file_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;stage_name;</span><br><span class="line">	write_to_file&lt;&lt;<span class="string">" compiled log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;<span class="built_in">log</span>;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []stage_name;</span><br><span class="line">	<span class="keyword">delete</span> []file_name;</span><br><span class="line"></span><br><span class="line">	stage_name = <span class="literal">nullptr</span>;</span><br><span class="line">	file_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">program_log_serialization</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> program,<span class="keyword">char</span> <span class="keyword">const</span> *program_name,<span class="keyword">bool</span> is_console_print)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLchar *program_linked_log = <span class="literal">NULL</span>;</span><br><span class="line">	GLint log_length = <span class="number">0</span>;</span><br><span class="line">	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;log_length);</span><br><span class="line">	program_linked_log = <span class="keyword">new</span> <span class="keyword">char</span>[log_length];</span><br><span class="line"></span><br><span class="line">	GLsizei program_linked_log_real_length;</span><br><span class="line">	glGetProgramInfoLog(program, log_length, &amp;program_linked_log_real_length, program_linked_log);</span><br><span class="line">	<span class="keyword">if</span>(is_console_print)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_name&lt;&lt;<span class="string">" linked log info:"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;program_linked_log&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> file_name_length = <span class="built_in">strlen</span>(program_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *log_file_whole_name = <span class="keyword">new</span> <span class="keyword">char</span>[file_name_length + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(log_file_whole_name,<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(program_name));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(log_file_whole_name,<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">	ofstream write_to_file;</span><br><span class="line">	write_to_file.open(log_file_whole_name,ios::out);</span><br><span class="line"></span><br><span class="line">	write_to_file&lt;&lt;*program_name + <span class="string">" linked log info;\n"</span>;</span><br><span class="line">	write_to_file&lt;&lt;program_linked_log;</span><br><span class="line">	write_to_file.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []program_linked_log;</span><br><span class="line">	<span class="keyword">delete</span> []log_file_whole_name;</span><br><span class="line"></span><br><span class="line">	program_linked_log = <span class="literal">nullptr</span>;</span><br><span class="line">	log_file_whole_name = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* pshadertext, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLuint shaderobj = glCreateShader(shadertype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(shaderobj == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error create shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> GLchar *p[<span class="number">1</span>];</span><br><span class="line">	p[<span class="number">0</span>] = pshadertext;</span><br><span class="line">	GLint lengths[<span class="number">1</span>];</span><br><span class="line">	lengths[<span class="number">0</span>] = <span class="built_in">strlen</span>(pshadertext);</span><br><span class="line"></span><br><span class="line">	glShaderSource(shaderobj, <span class="number">1</span>, p, lengths);</span><br><span class="line">	glCompileShader(shaderobj);</span><br><span class="line"></span><br><span class="line">	GLint success;</span><br><span class="line">	glGetShaderiv(shaderobj, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		GLchar infolog[<span class="number">1024</span>];</span><br><span class="line">		glGetShaderInfoLog(shaderobj, <span class="number">1024</span>, <span class="literal">NULL</span>, infolog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error compiling shader type "</span>&lt;&lt;shadertype&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">		serializationShaderCompileLog(shaderprogram, shaderobj, shadertype, infolog);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glAttachShader(shaderprogram, shaderobj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CompileShader</span><span class="params">(GLuint shaderprogram, <span class="keyword">const</span> <span class="keyword">char</span>* psfilename, GLenum shadertype)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(shaderprogram == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error creating shader program"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!ReadFile(psfilename, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;psfilename&lt;&lt;<span class="string">" is not exit"</span>&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(shadertype)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B31</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_VERTEX_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8DD9</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_GEOMETRY_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x8B30</span>:</span><br><span class="line">		AddShader(shaderprogram, s.c_str(), GL_FRAGMENT_SHADER);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LinkAndUseShaderProgram</span><span class="params">(GLuint shaderprogram)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GLint success = <span class="number">0</span>;</span><br><span class="line">	GLchar errorlog[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	glLinkProgram(shaderprogram);</span><br><span class="line"></span><br><span class="line">	glGetProgramiv(shaderprogram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(success == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error linking shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		program_log_serialization(shaderprogram, <span class="string">"LinkStatus"</span>, <span class="literal">true</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glValidateProgram(shaderprogram);</span><br><span class="line">	glGetProgramiv(shaderprogram, GL_VALIDATE_STATUS, &amp;success);</span><br><span class="line">	<span class="keyword">if</span>(!success)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramInfoLog(shaderprogram, <span class="keyword">sizeof</span>(errorlog), <span class="literal">NULL</span>, errorlog);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Invalid shader program "</span>&lt;&lt;errorlog&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glUseProgram(shaderprogram);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UsingShader.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IncludeFiles.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Utils.h"</span></span></span><br><span class="line"></span><br><span class="line">GLuint VBO;</span><br><span class="line"></span><br><span class="line">GLuint ShaderProgram;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pVSFileName = <span class="string">"vsshader.vs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pFSFileName = <span class="string">"fsshader.fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="comment">//Tells the how to interpret the data inside the buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Draw call</span></span><br><span class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Disable the vertex that is not used anymore after draw call</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallback</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//sets the display callback for the current window</span></span><br><span class="line">	glutDisplayFunc(&amp;RenderCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateVertexBuffer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Vector3f vertices[<span class="number">3</span>];</span><br><span class="line">	vertices[<span class="number">0</span>] = Vector3f(-<span class="number">1.0f</span>,-<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">1</span>] = Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	vertices[<span class="number">2</span>] = Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 / Apply a buffer handles</span><br><span class="line">	 / Bind buffer handle to specific buffer target</span><br><span class="line">	 / Filling the data for buffer target</span><br><span class="line">	*/</span></span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutAndWindow</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>* windowsname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//Initializes GLUT</span></span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//GLUT_DOUBLE -- double buffer rendering</span></span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initializa Windows info</span></span><br><span class="line">	glutInitWindowSize(<span class="number">1024</span>, <span class="number">768</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	glutCreateWindow(windowsname);</span><br><span class="line"></span><br><span class="line">	InitializeGlutCallback();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize glew</span></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span>(res != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error: "</span>&lt;&lt;glewGetErrorString(res)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Clear framebuffer before new draw call</span></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	CreateVertexBuffer();</span><br><span class="line"></span><br><span class="line">	ShaderProgram = glCreateProgram();</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pVSFileName, GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line">	CompileShader(ShaderProgram, pFSFileName, GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">	LinkAndUseShaderProgram(ShaderProgram);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//enable program to enter the window event loop</span></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	InitializeGlutAndWindow(argc, argv, <span class="string">"UsingOpenGL"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(Position.x,Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final effect:<br><img src="/img/OpenGL/UsingShader.PNG" alt="UsingShader"></p>
<p>上述只使用到了Vertex Shader和Framgment Shader, 后续还会讲到其他Shader的使用。</p>
<h3 id="Uniform_Variables">Uniform Variables</h3><p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are used to communicate with your vertex or fragment shader from “outside”.</a></p>
<p><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/uniform.php" target="_blank" rel="external">Uniform variables are read-only and have the same value among all processed vertices. You can only change them within your C++ program.</a></p>
<p>从上面可以看出Uniform变量主要用于Vertex和Fragment Shader,并且对于所有传入的顶点值都不变，只能通过C++一侧去改变Uniform Variable的值。</p>
<p>接下来我们看看Uniform Variable是如何应用在Shader中的：<br>使用Uniform Variable主要有以下几个步骤：</p>
<ol>
<li><p>Obtain uniform variable location after Link Shader Program</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScaleLocation = glGetUniformLocation(ShaderProgram, <span class="string">"gScale"</span>);</span><br><span class="line"></span><br><span class="line">assert(gScaleLocation != <span class="number">0xFFFFFFFF</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set uniform variable value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gScale += <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">glUniform1f(gScaleLocation, sinf(gScale));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Define uniform variable in Shader</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final result:<br><img src="/img/OpenGL/UniformVariable.PNG" alt="UniformVariable"></p>
<h3 id="Interpolation">Interpolation</h3><p><a href="http://ogldev.atspace.co.uk/www/tutorial09/tutorial09.html" target="_blank" rel="external">the interpolation that the rasterizer performs on variables that come out of the vertex shader. </a></p>
<p>在OpenGL的渲染管线里，在Fragment Shader执行之前会进行rasterizer，rasterizer会计算出各个三角形顶点之间的像素颜色数据，然后我们可以通过Fragment Shader对于光栅化的后颜色数据做进一步的处理。</p>
<p>这一章节主要看看我们是如何在Vertex Shader和Fragment Shader中如何对顶点数据和各像素信息做处理和数据传递的。(这里我们直接在VS中算出颜色信息直接传递到FS中去做处理)<br>要想从VS传递数据到FS，我们需要在Vertex Shader中定义关键词out的变量，并在Fragment Shader定义对应的关键词in的变量。</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> gScale;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">out vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = vec4(gScale * Position.x,gScale * Position.y,Position.z, <span class="number">1.0</span>);</span><br><span class="line">	</span><br><span class="line">	Color = <span class="built_in">abs</span>(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 Color;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/Interpolation.PNG" alt="Interpolation"></p>
<p>从上面可以看出在VS中算出颜色信息后，经过光栅化，三角形顶点之间的颜色信息被计算出来，最终传到FS中并作为最终颜色信息输出到屏幕上。</p>
<h3 id="Coordinate_Transformations_&amp;_Perspective_Projection">Coordinate Transformations &amp; Perspective Projection</h3><p>这一章主要是学习矩阵在3D图形中的使用和了解物体时怎样被显示到正确的屏幕位置的。<br>Note:<br>下列推导是基于OpenGL的列向量而非DX的行向量</p>
<p>在解释如何使用矩阵去进行向量变换之前，我们先来看看为什么矩阵可以实现向量变换？<br>下列学习参考《3D 数学基础：图形与游戏开发》<br>一个3维向量可以解释成3个基向量上平移后的组合(p,q,r为三个基向量)：<br>V = x × p + y × q + z × r;</p>
<p>当一个向量乘以矩阵的时候：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    [ p ]   [px  py  pz]</span><br><span class="line">M = [ q ] = [qx  qy  qz]</span><br><span class="line">    [ r ]   [rx  ry  rz]</span><br><span class="line"></span><br><span class="line">V = [x y z]</span><br><span class="line"></span><br><span class="line">                [px  py  pz]</span><br><span class="line">V * M = [x y z] [qx  qy  qz] = [x*px + y*qx + z*rx   x*py + y*qy + z*ry  x*pz + y*qz + z*rz] = x*p + y*q + z*r</span><br><span class="line">                [rx  ry  rz]</span><br></pre></td></tr></table></figure></p>
<p>“如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”</p>
<p>从上面我们可以看出矩阵是如何做到对于向量的坐标系转换的。</p>
<p>那么为什么我们后面用到的矩阵都是4×4而不是3×3的了？<br>4<em>4的矩阵我们叫做齐次矩阵。齐次矩阵出现的原因主要是除了记法方便，更重要的是因为3</em>3的变换矩阵只能表示线性变换，而4*4齐次矩阵能够表示线性变换和非线性变换。</p>
<p>那么这里我们来了解下什么是线性变换？<br>线性变换的满足下列公式：<br>F(a+b) = F(a) + F(b)<br>F(ka) = k × F(a)</p>
<p>因为线性变换不包含平移，所以这也是4×4齐次矩阵的出现的原因。</p>
<p>了解了使用矩阵的原因和为什么使用4×4齐次矩阵的原因后，让我们来看看，我们是如何通过矩阵来实现3D图形里的实现物体的坐标系变换的。<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)</p>
<p>因为矩阵乘法满足结合律<br>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × (M(m-w) × M(w-v) × M(v-p)) = V * N<br>所以我们只需要求出所有坐标系变换矩阵的乘积后再对V进行操作即可。</p>
<p>因为单个矩阵存储着一系列的变换，而这些变换可以通过多个单个变换组合而成，所以下列式子是成立的<br>M = S(scale) × R(rotation) × T(translation)</p>
<p>但这里有个比较关键的点，S,R,T直接的乘法顺序，矩阵是不满足交换律的，我们必须按S <em> R </em> T的顺序，原因参考下面：<br><a href="https://msdn.microsoft.com/en-us/library/eews39w7%28v=vs.110%29.aspx" target="_blank" rel="external">One reason order is significant is that transformations like rotation and scaling are done with respect to the origin of the coordinate system. Scaling an object that is centered at the origin produces a different result than scaling an object that has been moved away from the origin. Similarly, rotating an object that is centered at the origin produces a different result than rotating an object that has been moved away from the origin.</a></p>
<p>从上面可以看出，之所必须按S <em> R </em> T的顺序是因为S和R都是针对坐标系原点进行的，一旦先执行T，那么相对于坐标系原点的位置就会有所变化，这之后再做S和R就会出现不一样的表现。</p>
<p>因为OpenGL是列向量是左乘，所以在OpenGL中顺序如下：<br>V’ = T × R × S × V</p>
<p>DX中顺序如下：<br>V’ = V × S × R × T</p>
<p>获取最终的M(m-w)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetWorldTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f ScaleTrans, RotateTrans, TranslationTrans;</span><br><span class="line"></span><br><span class="line">    ScaleTrans.InitScaleTransform(m_scale.x, m_scale.y, m_scale.z);</span><br><span class="line">    RotateTrans.InitRotateTransform(m_rotateInfo.x, m_rotateInfo.y, m_rotateInfo.z);</span><br><span class="line">    TranslationTrans.InitTranslationTransform(m_worldPos.x, m_worldPos.y, m_worldPos.z);</span><br><span class="line"></span><br><span class="line">    m_Wtransformation = TranslationTrans * RotateTrans * ScaleTrans;</span><br><span class="line">    <span class="keyword">return</span> m_Wtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>V’ = V × M(m-w) × M(w-v) × M(v-p)<br>我们知道了M(m-w)是如何计算出来的了，接下来我们要了解M(w-v) — 世界坐标系到观察坐标系<br>在了解如何从世界坐标系转换到观察坐标系之前我们先来看看摄像机的定义：<br>位置 — (x,y,z)<br>N — The vector from the camera to its target.（look at 朝向）<br>V — When standing upright this is the vector from your head to the sky.(垂直于N向上的向量)<br>U — This vector points from the camera to its “right” side”.(在N和V定了之后可以算出Camera的向右的向量)</p>
<p>摄像机坐标系和世界坐标系：<br><img src="/img/OpenGL/CameraCoordinateTranslation.PNG" alt="CameraCoordinateTranslation"></p>
<p>要想得到物体从世界坐标系转换到摄像机坐标系，其实就是个坐标系转换的问题。<br>我们首先把摄像机移动到世界坐标原点(移动摄像机位置即可)：<br>[ 1 0 0 -x ]<br>[ 0 1 0 -y ]<br>[ 0 0 1 -z ]<br>[ 0 0 0  1 ]</p>
<p>这样一来考虑如何变化坐标系即可：<br><img src="/img/OpenGL/CameraCoordinate2.PNG" alt="CameraCoordinate2"><br>通过N,V,U，我们已经能够得出X(camera),Y(camera),Z(camera)3个基向量了。<br>还记得我们之前说的 — “如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标系转换。若有a*M = b，我们就可以说，M将a转换到b。”<br>所以：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ Ux Uy Uz <span class="number">0</span> ]    [X(world)]    [X(camera)]</span><br><span class="line">[ Vx Vy Vz <span class="number">0</span> ]    [Y(world)]    [Y(camera)]</span><br><span class="line">[ Nx Ny Nz <span class="number">0</span> ] *  [Z(world)] =  [Z(camera)]</span><br><span class="line">[ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]    [    <span class="number">1</span>   ]    [     <span class="number">1</span>   ]</span><br></pre></td></tr></table></figure></p>
<p>结合前面提到的先把摄像机移动到世界原点，得出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         [ Ux Uy Uz <span class="number">0</span> ]   [ <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> -x ]</span><br><span class="line">M(w-v) = [ Vx Vy Vz <span class="number">0</span> ] * [ <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> -y ]</span><br><span class="line">         [ Nx Ny Nz <span class="number">0</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> -z ]</span><br><span class="line">         [ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> ]   [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>  <span class="number">1</span> ]</span><br></pre></td></tr></table></figure></p>
<p>M(w-v)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitTranslationTransform(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">&#123;</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>; m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">0</span>][<span class="number">3</span>] = x;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">1</span>][<span class="number">3</span>] = y;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>; m[<span class="number">2</span>][<span class="number">3</span>] = z;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>; m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Matrix4f::InitCameraTransform(<span class="keyword">const</span> Vector3f&amp; Target, <span class="keyword">const</span> Vector3f&amp; Up)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f N = Target;</span><br><span class="line">    N.Normalize();</span><br><span class="line">    Vector3f U = Up;</span><br><span class="line">    U.Normalize();</span><br><span class="line">    U = U.Cross(N);</span><br><span class="line">    Vector3f V = N.Cross(U);</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = U.x;   m[<span class="number">0</span>][<span class="number">1</span>] = U.y;   m[<span class="number">0</span>][<span class="number">2</span>] = U.z;   m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = V.x;   m[<span class="number">1</span>][<span class="number">1</span>] = V.y;   m[<span class="number">1</span>][<span class="number">2</span>] = V.z;   m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = N.x;   m[<span class="number">2</span>][<span class="number">1</span>] = N.y;   m[<span class="number">2</span>][<span class="number">2</span>] = N.z;   m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;  m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Matrix4f&amp; Pipeline::GetViewTrans()</span><br><span class="line">&#123;</span><br><span class="line">    Matrix4f CameraTranslationTrans, CameraRotateTrans;</span><br><span class="line"></span><br><span class="line">    CameraTranslationTrans.InitTranslationTransform(-m_camera.Pos.x, -m_camera.Pos.y, -m_camera.Pos.z);</span><br><span class="line">    CameraRotateTrans.InitCameraTransform(m_camera.Target, m_camera.Up);</span><br><span class="line">    </span><br><span class="line">    m_Vtransformation = CameraRotateTrans * CameraTranslationTrans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Vtransformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来M(w-v)也就实现了，接下来让我们看看M(v-p)是如何计算出来的吧。<br>M(v-p)这的p有多种投影方式，这里我只以Perspective Projection为例。<br>在转换到Camera坐标系后，我们还需要通过透视投影才能将3D物体映射到2D平面上。<br>Perspective Projection主要由下列四部分决定：</p>
<ol>
<li>The aspect ratio - the ratio between the width and the height of the rectangular area which will be the target of projection.</li>
<li>The vertical field of view.</li>
<li>The location of the near Z plane.</li>
<li>The location of the far Z plane.</li>
</ol>
<p>这一章的推导可以参考<a href="http://www.cnblogs.com/graphics/archive/2012/07/25/2582119.html" target="_blank" rel="external">透视投影详解</a><br>一开始推导过程中不明白的一点是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           1</span><br><span class="line">Z'' = a * --- + b</span><br><span class="line">           Pz</span><br></pre></td></tr></table></figure></p>
<p>后来看了《Mathematics for 3D Game Programming and Computer Grahpics 3rd section》的5.4.1 Depth Interpolation后明白了，光栅化的时候对于深度的运算证明了是对Z的倒数进行插值来得到Z的值的。<br>所以上述公式是成立的。</p>
<p>经过一系列推导后，我们得出了：<br><img src="/img/OpenGL/PerspectiveProject1.PNG" alt="PerspectiveProject1"><br><img src="/img/OpenGL/PerspectiveProject2.PNG" alt="PerspectiveProject2"><br><img src="/img/OpenGL/PerspectiveProject3.PNG" alt="PerspectiveProject3"><br><img src="/img/OpenGL/PerspectiveProject4.PNG" alt="PerspectiveProject4"></p>
<p>Note:<br><strong>上述推导是针对DX而言的，DX和OpenGL在透视投影矩阵推导上面有一个很重要的不同，那就是DX变换后z坐标范围是[0,1]，而OpenGL的z坐标范围是[-1,1]</strong></p>
<p>所以如果我们把z坐标[-1,1]带入下式推导：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           1</span><br><span class="line">Z'' = a * --- + b</span><br><span class="line">           Pz</span><br></pre></td></tr></table></figure></p>
<p>我们将得出OpenGL的透视投影矩阵如下(下面的θ = FOV/2)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    [cotθ/Aspect        <span class="number">0</span>               <span class="number">0</span>                  <span class="number">0</span>     ]</span><br><span class="line">    [    <span class="number">0</span>            cotθ              <span class="number">0</span>                  <span class="number">0</span>     ]</span><br><span class="line">M = [    <span class="number">0</span>              <span class="number">0</span>          (-n-f)/(n-f)       <span class="number">2</span>*f*n/(n-f)]</span><br><span class="line">    [    <span class="number">0</span>              <span class="number">0</span>               <span class="number">1</span>                  <span class="number">0</span>     ]</span><br></pre></td></tr></table></figure></p>
<p>所以OpenGL里M(v-p)的代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Matrix4f::InitPersProjTransform(<span class="keyword">const</span> PersProjInfo&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ar         = p.Width / p.Height;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> zRange     = p.zNear - p.zFar;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> tanHalfFOV = tanf(ToRadian(p.FOV / <span class="number">2.0f</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span>/(tanHalfFOV * ar); m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span>/tanHalfFOV; m[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;            m[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">2</span>][<span class="number">2</span>] = (-p.zNear - p.zFar)/zRange ; m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2.0f</span>*p.zFar*p.zNear/zRange;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;                   m[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;            m[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;            m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0.0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Keyboard_&amp;&amp;_Mouse_Control">Keyboard &amp;&amp; Mouse Control</h3><p>这一章节主要是讲通过Glut提供的API如何去响应键盘和鼠标的控制。<br>本章节里面主要用到了两个类：</p>
<ol>
<li>Pipeline</li>
<li>Camera</li>
</ol>
<p>Pipeline主要是针对上一章节我们对于如何通过矩阵变化把物体显示到2D平面上的抽象：<br>M(m-w) — 物体坐标系到世界坐标系<br>M(w-v) — 世界坐标系到观察坐标系<br>M(v-p) — 投影变换</p>
<p>N = M(m-w) × M(w-v) × M(v-p)<br>V’ = V × M(m-w) × M(w-v) × M(v-p) = V × N</p>
<p>Pipeline只要知道了物体S,R,T信息就可以得出M(m-w)，知道了Camera信息就可以得出M(w-v),知道了透视投影信息就可以得出M(v-p)。</p>
<p>我们通过修改摄像机的相关信息得出在移动摄像机后的N,并作用于物体，这样一来就能使物体显示在正确位置了。</p>
<p>而Camera类是对摄像机的抽象。</p>
<p>Pipeline和Camera的源代码可在<a href="http://ogldev.atspace.co.uk/" target="_blank" rel="external">Modern OpenGL Tutorials</a>下载</p>
<p>这里我只关心针对键盘和鼠标的响应的相关代码：<br>Glut里针对键盘和鼠标的API主要是下列几个：</p>
<ol>
<li>glutSpecialFunc() — 主要是针对特殊按键比如F1</li>
<li>glutKeyboardFunc() — 主要是针对普通按键比如A,B,C……</li>
<li>glutPassiveMotionFunc() — 主要是针对在没有鼠标按键被按下的情况下，鼠标在窗口内移动的情况</li>
<li>glutMotionFunc() — 主要是针对在鼠标按键被按下的情况下，鼠标在窗口内移动的情况</li>
</ol>
<p>相关代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecialKeyboardCB</span><span class="params">(<span class="keyword">int</span> Key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    OGLDEV_KEY OgldevKey = GLUTKeyToOGLDEVKey(Key);</span><br><span class="line">    pGameCamera-&gt;OnKeyboard(OgldevKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">KeyboardCB</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> Key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">            glutLeaveMainLoop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PassiveMouseCB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pGameCamera-&gt;OnMouse(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeGlutCallbacks</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">    glutSpecialFunc(SpecialKeyboardCB);</span><br><span class="line">    glutPassiveMotionFunc(PassiveMouseCB);</span><br><span class="line">    glutKeyboardFunc(KeyboardCB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>final result:<br><img src="/img/OpenGL/MouseAndKeyboardStudy.PNG" alt="MouseAndKeyboardStudy"></p>
<h3 id="Texture_Mapping">Texture Mapping</h3><p>“Textures are composed of texels, which often contain color values.”</p>
<p>“Textures are bound to the OpenGL context via texture units, which are represented as binding points named GL_TEXTURE0 through GL_TEXTUREi where i is one less than the number of texture units supported by the implementation.”</p>
<p>The textures are accessed via sampler variables which were declared with dimensionality that matches the texture in shader</p>
<p>在真正接触Texutre之前，让我们理解下下列几个重要的概念：</p>
<ol>
<li><p>Texture object – contains the data of the texture image itself, i.e. the texels（可以看出Texture object才是含有原始数据信息的对象）</p>
</li>
<li><p>Texture unit – texture object bind to a ‘texture unit’ whose index is passed to the shader. So the shader reaches the texture object by going through the texture unit.（我们访问texture数据信息并不是通过texture object，而是在shader里通过访问特定索引的texture unit去访问texture object里的数据）</p>
</li>
<li><p>Sampler Object – configure it with a sampling state and bind it to the texture unit. When you do that the sampler object will override any sampling state defined in the texture object.（Sampler Object一些sampling的配置信息，当用于texture object时会覆盖texture object里的原始sampler设定）</p>
</li>
<li><p>Sampler uniform – corresponding to handle of texture unit(用于在Shader里访问texture unit，texture unit和texture object绑定，也就间接的访问了texture的原始数据)</p>
</li>
</ol>
<p>Relationship between texture object, texture unit, sampler object and sampler uniform<br><img src="/img/OpenGL/TextureConcepts.png" alt="RelationshipBetweenThem"></p>
<p>因为OpenGL没有提供从图片加载texture的API，所以这里我们需要使用第三方库来完成这项工作，这里教程上使用的是ImageMagick。<br>ImageMagick主要是为了从多种格式的资源文件中读取原始数据，在我们指定glTexImage2D()的原始数据的时候提供所在内存地址。</p>
<p>Steps to use texture mapping:</p>
<ol>
<li><p>Create a texture object and load texel data into it<br>glGenTextures() — gen texture object<br>glBindTexture() — Tells OpenGL the texture object we refer to in all the following texture related calls, until a new texture object is bound.<br>glTexImage2D() — load texel data into texture object</p>
</li>
<li><p>Include texture coordinates with your vertices</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vertex Vertices[<span class="number">4</span>] = &#123; Vertex(Vector3f(-<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.5773f</span>), Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">0.0f</span>, -<span class="number">1.0f</span>, -<span class="number">1.15475f</span>), Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">1.0f</span>, -<span class="number">1.0f</span>, <span class="number">0.5773f</span>),  Vector2f(<span class="number">0.0f</span>, <span class="number">0.0f</span>)),</span><br><span class="line">                       Vertex(Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),      Vector2f(<span class="number">0.5f</span>, <span class="number">1.0f</span>)) &#125;;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把顶点对应的纹理坐标信息写到vertex数据里</span></span><br><span class="line"><span class="comment">//说道纹理坐标就不得不提一下Texture UV纹理坐标了，Texture的图片被映射到0-1的二维坐标，图见后面：</span></span><br><span class="line"></span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), <span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">const</span> GLvoid*)<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后通过指定如何解析顶点数据里面的的数据在Shader里访问vertex的texture纹理坐标信息去sample出texture数据信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Associate a texture sampler with each texture map you intend to use in your shader<br>glTexParameterf() — Texture采样方式的配置<br>还记得我们之前讲到的Sampler object吗？这里的配置就好比我们在sampler object里配置后再作用于特定的texture object<br>这里我就不说关于采样方式配置相关的内容了（采样方式会决定最终像素的计算方式），这里值得一提的是mipmap的概念。<br>mipmap主要是由于物体在场景中因为距离的缘故会在屏幕显示的大小有变化，如果我们在物体很远，只需要显示很小一块的时候还依然采用很大的纹理贴图，最终显示在屏幕上的纹理会很不清晰（失真）。为了解决这个问题，mipmap应运而生，通过事先生成或指定多个级别的同一纹理贴图，然后在程序运作的过程中通过计算算出应该使用哪一个等级的纹理贴图来避免大纹理小色块失真的问题。<br>我们可以手动通过：<br>glTexStorage2D() &amp;&amp; glTexSubImage2D() 去手动指定各级纹理贴图<br>也可以通过：<br>glGenerateMipmap() — 自动去生成对应的mipmap纹理贴图<br>而程序在实际运作过程中如何去计算Mipmap Level这里就不做介绍了，详细参考《OpenGL Programming Guide 8th Edition》的Calculating the Mipmap章节<br>相关函数：<br>textureLod()<br>textureGrad()</p>
</li>
<li><p>Active texture unit and bind texture object to it<br>glActiveTexture() — 激活特定的texture unit然后绑定特定texture object到特定texture unit上<br>glBindTexture() — 绑定特定的texture object到texture unit上</p>
</li>
<li><p>Retrieve the texel values through the texture sampler from your shader<br>首先我们在程序中指定了我们即将访问的Texture unit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gSampler = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler"</span>);</span><br><span class="line">assert(gSampler != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">glUniform1i(gSampler, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Note:<br>“The important thing to note here is that the actual index of the texture unit is used here, and not the OpenGL enum GL_TEXTURE0 (which has a different value).”</p>
<p>vsshader.vs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	TexCoord0 = TexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = texture2D(gSampler, TexCoord0.xy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出我们在fragment shader里，通过传入的gSampler确认了使用哪一个texture unit，通过传入的TexCoord0确认了对应的纹理坐标信息去获取对应的texture信息，然后最终通过texture2D从texture里取得了特定的颜色信息作为输出，就这样纹理图片的信息就作用在了三角形上并显示出来。</p>
<p><img src="/img/OpenGL/TextureCoordinate.PNG" alt="TextureCoordinate"></p>
<p>final result:<br><img src="/img/OpenGL/BasicTexture.PNG" alt="BasicTexture"></p>
<p>下面我简单测试了下两个Texture计算出最终纹理信息：<br>TextureStudy.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitializeTextureInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gSampler = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler"</span>);</span><br><span class="line">	assert(gSampler != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">	gSampler2 = glGetUniformLocation(ShaderProgram, <span class="string">"gSampler2"</span>);</span><br><span class="line">	assert(gSampler2 != <span class="number">0xFFFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Specify the inder of texture unit we will use in shader</span></span><br><span class="line">	glUniform1i(gSampler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glUniform1i(gSampler2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	pTexture = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/texture1.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pTexture-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pTexture2 = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/texture2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pTexture2-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallbackCB</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	pTexture-&gt;Bind(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	pTexture2-&gt;Bind(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gSampler2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FragColor = <span class="number">0.5</span> * texture2D(gSampler, TexCoord0.xy) + <span class="number">0.5</span> * texture2D(gSampler2, TexCoord0.xy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始图片分别为：<br><img src="/img/OpenGL/texture1.png" alt="Texture1"><br><img src="/img/OpenGL/texture2.jpg" alt="Texture2"></p>
<p>final result:<br><img src="/img/OpenGL/MultipleTexture.PNG" alt="MultipleTexture"></p>
<p>Point Sprites:<br>待理解学习……</p>
<p>Rendering to Texture Maps:<br>待理解学习……</p>
<p>Sumary：</p>
<ol>
<li><p>Use immutable texture storage for textures wherever possible – When a texture is marked as immutable, the OpenGL implementation can make certain assumptions about the validity of a texture object （尽量使用不可变的texture storage， 这样OpenGL可以确保texture的有效性）</p>
</li>
<li><p>Create and initialize the mipmap chain for textures unless you have a good reason not to – improve the image quality of your program’s rendering, but also will make more efficient use of the caches in the graphics processor （为了渲染效率，减轻GPU负担，尽可能为texture创建mipmap）</p>
</li>
<li><p>Use an integer sampler in your shader when your texture data is an unnormalized integer and you intend to use the integer values it contains directly in the shader （尽量在shader里使用integer类型的sampler）</p>
</li>
</ol>
<p>Note:<br>“The maximum number of texture units supported by OpenGL<br>can be determined by retrieving the value of the GL<em>MAX_COMBINED</em><br>TEXTURE_IMAGE_UNITS constant, which is guaranteed to be at least 80 as<br>of OpenGL 4.0.”</p>
<p>Proxy texture – used to test the capabilities of the OpenGL implementation when certain limits are used in combination with each other.</p>
<h3 id="Light_and_Shadow">Light and Shadow</h3><p>光源类型：</p>
<ol>
<li>Ambient Light (环境光) — 环境光只影响ambient</li>
<li>Directional Light (方向光) — 方向光会影响diffuse &amp; specular</li>
<li>Point Light (点光源) — 与方向光的区别是有attenuation(衰弱)而且点光源照射物体的表面的方向不一样，同样会影响diffuse &amp; specular</li>
</ol>
<p>传统的光照组成：<br>Ambient (环境光) — 与光照的方向无关<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FragColor = texture2D(gSampler, TexCoord0.xy) *</span><br><span class="line">        vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *</span><br><span class="line">        gDirectionalLight.AmbientIntensity;</span><br></pre></td></tr></table></figure></p>
<p>因为环境光与光照方向无关，只需考虑方向光的颜色和方向光所占比重，所以基本上主要计算归结于上述运算。</p>
<p>final effect:<br><img src="/img/OpenGL/Ambient.PNG" alt="Ambient"></p>
<p>Note:<br>这里源代码里有个错误，在子类重写虚函数的KeyboardCB的时候，由于参数写的不对，没能正确重写该虚函数而没有被调到。<br>错误：<br>virtual void KeyboardCB(OGLDEV_KEY OgldevKey);<br>正确：<br>virtual void KeyboardCB(OGLDEV_KEY OgldevKey, OGLDEV_KEY_STATE OgldevKeyState = OGLDEV_KEY_STATE_PRESS)</p>
<p>Diffuse (漫反射光) — 与光照的方向和顶点normal有关<br>因为漫反射光要考虑光照的方向和物体的顶点法线，所以我们需要在shader里进行计算之前要把顶点的法线算出来然后传入Shader进行计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcNormals</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* pIndices, <span class="keyword">unsigned</span> <span class="keyword">int</span> IndexCount, Vertex* pVertices, <span class="keyword">unsigned</span> <span class="keyword">int</span> VertexCount)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; IndexCount ; i += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index0 = pIndices[i];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index1 = pIndices[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> Index2 = pIndices[i + <span class="number">2</span>];</span><br><span class="line">        Vector3f v1 = pVertices[Index1].m_pos - pVertices[Index0].m_pos;</span><br><span class="line">        Vector3f v2 = pVertices[Index2].m_pos - pVertices[Index0].m_pos;</span><br><span class="line">        Vector3f Normal = v1.Cross(v2);</span><br><span class="line">        Normal.Normalize();</span><br><span class="line"></span><br><span class="line">        pVertices[Index0].m_normal += Normal;</span><br><span class="line">        pVertices[Index1].m_normal += Normal;</span><br><span class="line">        pVertices[Index2].m_normal += Normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; VertexCount ; i++) &#123;</span><br><span class="line">        pVertices[i].m_normal.Normalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vsshader.vs<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#version 330</span><br><span class="line"></span><br><span class="line">layout (location = 0) in vec3 Position;</span><br><span class="line">layout (location = 1) in vec2 TexCoord;</span><br><span class="line">layout (location = 2) in vec3 Normal;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line">uniform mat4 gWorld;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line">out vec3 Normal0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = gWVP * vec4(Position, 1.0);</span><br><span class="line">    TexCoord0 = TexCoord;</span><br><span class="line">    Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意“Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;” — 因为我们对于顶点法线的计算是基于物体没有移动变化之前的，所以我们真正计算所用的顶点法线需要通过世界坐标系矩阵的转换。</p>
<p>fsshader.fs<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec2 TexCoord0;</span><br><span class="line">in vec3 Normal0;                                                                    </span><br><span class="line">                                                                                    </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">struct</span> DirectionalLight                                                             </span><br><span class="line">&#123;                                                                                   </span><br><span class="line">    vec3 Color;                                                                     </span><br><span class="line">    <span class="keyword">float</span> AmbientIntensity;                                                         </span><br><span class="line">    <span class="keyword">float</span> DiffuseIntensity;                                                         </span><br><span class="line">    vec3 Direction;                                                                 </span><br><span class="line">&#125;;                                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line">uniform DirectionalLight gDirectionalLight;                                         </span><br><span class="line">uniform sampler2D gSampler;                                                         </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    vec4 AmbientColor = vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *                       </span><br><span class="line">                        gDirectionalLight.AmbientIntensity;                         </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">float</span> DiffuseFactor = dot(normalize(Normal0), -gDirectionalLight.Direction);    </span><br><span class="line">                                                                                    </span><br><span class="line">    vec4 DiffuseColor;                                                              </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (DiffuseFactor &gt; <span class="number">0</span>) &#123;                                                        </span><br><span class="line">        DiffuseColor = vec4(gDirectionalLight.Color, <span class="number">1.0f</span>) *                        </span><br><span class="line">                       gDirectionalLight.DiffuseIntensity *                         </span><br><span class="line">                       DiffuseFactor;                                               </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                          </span><br><span class="line">        DiffuseColor = vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                                            </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    FragColor = texture2D(gSampler, TexCoord0.xy) *                                 </span><br><span class="line">                (AmbientColor + DiffuseColor);                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从“float DiffuseFactor = dot(normalize(Normal0), -gDirectionalLight.Direction);”可以看出，光照的方向和顶点法线之间的角度直接决定了漫反射光所占的比重。<br>参见<a href="https://en.wikipedia.org/wiki/Lambert&#39;s_cosine_law" target="_blank" rel="external">Lambert’s cosine law</a></p>
<p>final effect:<br><img src="/img/OpenGL/Diffuse.PNG" alt="Diffuse"></p>
<p>Note:<br>这里我按照官网和源代码的方式按自己的方式写了，但不知道为何DiffuseFactor得出的值当我去做if else判断等，无论是&gt;0,&lt;0,==0都不会进去，都只会进入最终的else。<br>我通过gDEBugger查看了uniform的值没有问题，C++那一侧所有的相关计算的值也都正确，这里弄了半天也没有解决，本来准备用Nsight调试GLSL的，发现我的笔记本好像不被支持。<br>个人最终认为是顶点的法线在传递给Shader的时候出问题了，导致dot之后计算DiffuseFactor出问题，虽然在VS一侧下的断点查看normal是正确的，但不确定为什么shader一侧获得的值会有问题。（这一结论主要是因为同样的shader代码在加载现有模型的时候起作用发现的）</p>
<p>Specular (镜面反射光) — 与光照的方向和eye观察还有顶点normal有关<br>Specular在Diffuse的基础上，还要多考虑一个因素（观察者所在位置，如果观察者正好在反光处，那么该观察点就会比在其他位置的观察点观察同一位置的看起来更亮）。但现实中并不是所有物体都有这一特性，所以Specular更针对物体材质而言而非光线本身。</p>
<p>看一下下图：<br><img src="/img/OpenGL/SpecularModle.PNG" alt="SpecularModle"><br>I是光线入射方向<br>N是平面法线<br>R是完美反射后的光线<br>V是观察者观察方向<br>a是观察者方向与完美反射光线的夹角<br>从上图可以看出当观察者所在观察角度V与R越接近时，我们可以理解为观察者观察该点会达到最大量值</p>
<p>我们计算出R主要是通过I和N和-N之间的计算：<br>详情见下图：<br><img src="/img/OpenGL/SpecularModle2.PNG" alt="SpecularModle2"><br>R = I + V<br>V = 2 <em> N </em> dot(-N,I)<br>这里值得一提的是OpenGL里提供了reflect方法，通过光线和平面法线就能直接算出反射R</p>
<p>让我们直接看一下Specular的计算公式：<br><img src="/img/OpenGL/SpecularCalculation.PNG" alt="SpecularCalculation"><br>M — 是跟物体材质有关的，材质决定了specular的反光系数<br>     p<br>(R.V) — 是指观察者所在位置和完美反射光线之间夹角的P次方，P是shininess factor（発光系数之类的）<br>上述换成代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vec3 VertexToEye = normalize(gEyeWorldPos - WorldPos0);                     </span><br><span class="line">vec3 LightReflect = normalize(reflect(gDirectionalLight.Direction, Normal));</span><br><span class="line"><span class="keyword">float</span> SpecularFactor = dot(VertexToEye, LightReflect);                      </span><br><span class="line"><span class="keyword">if</span> (SpecularFactor &gt; <span class="number">0</span>) &#123;                                                   </span><br><span class="line">    SpecularFactor = <span class="built_in">pow</span>(SpecularFactor, gSpecularPower);</span><br><span class="line">    SpecularColor = vec4(gDirectionalLight.Color * gMatSpecularIntensity * SpecularFactor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">FragColor = texture2D(gSampler, TexCoord0.xy) *                                 </span><br><span class="line">            (AmbientColor + DiffuseColor + SpecularColor);</span><br></pre></td></tr></table></figure></p>
<p>Limitations of the Classic Lighting Model: （传统光源的不足之处）<br>Big Missing:</p>
<ol>
<li>Assume no other objects blocking the path of the lights to the surface （假设光不会被物体遮挡）</li>
<li>Accurate ambient lighting （统一固定精确的环境光，现实中是由削弱的（attenuation））</li>
</ol>
<p>了解了光源的三个组成，也了解了传统光源的不足，让我们来看看另一种光照Point Light：<br>Point Light是有伴随距离而削弱（attenuation）的光源<br>公式如下：<br><img src="/img/OpenGL/PointLightFormulation.PNG" alt="PointLightFormulation"></p>
<p>在实现Point Light的计算的时候，我们只需要把光照的方向根据Point Light位置算一下，并在最后除以根据物体位置与Point Light的光源位置算出的attenuation即可、<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">CalcPointLight</span><span class="params">(<span class="keyword">int</span> Index, vec3 Normal)</span>                                                 </span><br><span class="line"></span>&#123;                                                                                           </span><br><span class="line">    vec3 LightDirection = WorldPos0 - gPointLights[Index].Position;                         </span><br><span class="line">    <span class="keyword">float</span> Distance = length(LightDirection);                                                </span><br><span class="line">    LightDirection = normalize(LightDirection);                                             </span><br><span class="line">                                                                                            </span><br><span class="line">    vec4 Color = CalcLightInternal(gPointLights[Index].Base, LightDirection, Normal);       </span><br><span class="line">    <span class="keyword">float</span> Attenuation =  gPointLights[Index].Atten.Constant +                               </span><br><span class="line">                         gPointLights[Index].Atten.Linear * Distance +                      </span><br><span class="line">                         gPointLights[Index].Atten.Exp * Distance * Distance;               </span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="keyword">return</span> Color / Attenuation;                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看一下Spot Light:<br>Spot Light和Point Light的主要区别在于，Spot Light定义了一个可影响的范围Cone和其垂直照射的方向。<br>而这个Cone通过Cutoff来定义：<br>Cutoff — “ The cutoff value represents the maximum angle between the light direction and the light to pixel vector for pixels that are under the influence of the spot light.”<br>见下图：<br><img src="/img/OpenGL/SpotLight.PNG" alt="SpotLight"></p>
<p>通过计算出所在点是否在Spot Light的Cone里去决定是否影响该颜色值。<br>这里需要关注的一点是关于如何映射Cutoff值到[0，1]，因为一般来说Cutoff的值不可能设置到0（即90度），所以我们要想计算边缘化削弱效果，我们需要对Cutoff的值进行线性插值。<br>推导见如下（来源之OpenGL Tutorial 21）：<br><img src="/img/OpenGL/SpotLightCutoffMapping.PNG" alt="SpotLightCutoffMapping"></p>
<p>知道了怎么确认是否影响该点颜色，以及如何插值获取影响值，那么最终归结代码见如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec4 <span class="title">CalcSpotLight</span><span class="params">(<span class="keyword">struct</span> SpotLight l, vec3 Normal)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec3 LightToPixel = normalize(WorldPos0 - l.Base.Position);</span><br><span class="line">    <span class="keyword">float</span> SpotFactor = dot(LightToPixel, l.Direction);</span><br><span class="line">    <span class="comment">//计算所在点是否在Spot Light的Cone里去决定是否影响该颜色值。</span></span><br><span class="line">    <span class="keyword">if</span> (SpotFactor &gt; l.Cutoff) &#123;</span><br><span class="line">        vec4 Color = CalcPointLight(l.Base, Normal);</span><br><span class="line">        <span class="comment">//插值计算影响值</span></span><br><span class="line">        <span class="keyword">return</span> Color * (<span class="number">1.0</span> - (<span class="number">1.0</span> - SpotFactor) * <span class="number">1.0</span>/(<span class="number">1.0</span> - l.Cutoff));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vec4(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>More Advanced Lighting Model:<br>Hemisphere Lighting:<br>The idea behind hemisphere lighting is that we model the illumination as two hemispheres. The upper hemisphere represents the sky and the lower hemisphere represents the ground</p>
<p>Imaged-Based Lighting:<br>“It is often easier and much more efficient to sample the lighting in such environments and store the results in one or more environment maps”</p>
<p>Lighting with Spherical Harmonics:<br>“This method reproduces accurate diffuse reflection, based on the content of a light probe image, without accessing the light probe image at runtime”</p>
<p><a href="www.debevec.org">详情参考</a> </p>
<p>总结:<br>Ambient (环境光) — 与光照的方向无关<br>环境光不会削弱不考虑方向，所以只需考虑光照颜色和平面颜色即可<br>Diffuse (漫反射光) — 与光照的方向和顶点normal有关<br>光照的方向和顶点法线之间的角度直接决定了漫反射光所占的比重。<br>Specular (镜面反射光) — 与光照的方向和eye观察还有顶点normal有关<br>观察者所在位置和光照方向和法线会决定观察者所在位置的Specular反射比例，物体材质会决定Specular反射系数。<br>最终通过计算环境中所有光源对物体的ambient, diffuse, specular影响计算出物体的最终color</p>
<p>接下来我们看一个真实渲染过程中比较重要的技术 — Shadow Mapping<br>Shadow Mapping — Uses a depth texture to determine whether a point is lit or not.</p>
<p>Shadow mapping is a multipass technique that uses depth textures to provide a solution to rendering shadows (核心思想是通过比较通过光源点观察保存的深度信息（depth texture）和从观察点观察的深度信息来判断哪些点是shadowed，哪些是unshadowed — 注意比较的是通过映射到2D depth texture后的信息)<br>A key pass is to view the scene from the shadow-casting light source rather than from the final viewpoint<br>Two passes:</p>
<ul>
<li><em>First Pass</em><br>Shadow map — by rendering the scene’s depth from the point of the light into a depth texture, we can obtain a map of the shadowed and unshadowed points in the scene<br>在第一个pass中，我按照事例代码中写了，但发现最后显示的是纯白色的图像。<br>后来就不断去查问题。<br><img src="/img/OpenGL/ShaowMapFirstPass.PNG" alt="ShaowMapFirstPassFailed"><br>首先，我怀疑depth texture是不是没有生成成功？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the FBO</span></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the depth buffer</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;m_shadowMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_shadowMap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable writes to the color buffer</span></span><br><span class="line">glDrawBuffer(GL_NONE);</span><br><span class="line">glReadBuffer(GL_NONE);</span><br><span class="line"></span><br><span class="line">GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但上述代码没有报任何错误，通过gDebugger查看Texture的时候发现depth texture是生成成功了的。<br><img src="/img/OpenGL/ShaowMapFirstPassCreate.PNG" alt="ShaowMapFirstPassCreate"><br>从上图仔细看，模型的深度信息时被生成到了FBO 1所绑定的Depth Texture中了的。</p>
<p>那么接下来，我就怀疑是不是我激活的Texture unit有错误？<br>以下是将Depth Texture渲染到一个平面上的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ShadowMapFBO::BindForReading(GLenum TextureUnit)</span><br><span class="line">&#123;</span><br><span class="line">    glActiveTexture(TextureUnit);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glUniform1i(gTextureLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	gShadowMapFBO.BindForReading(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">5.0f</span>, <span class="number">5.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">	p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">	p.SetCamera(pGameCamera-&gt;GetPos(), pGameCamera-&gt;GetTarget(), pGameCamera-&gt;GetUp());</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	glUniformMatrix4fv(gWVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)p.GetWVPTrans());</span><br><span class="line"></span><br><span class="line">	gPQuade-&gt;Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/OpenGL/MyTextureList.PNG" alt="MyTextureList"><br><img src="/img/OpenGL/DemoTextureList.PNG" alt="DemoTextureList"><br>通过上图，我发现我自己的代码有三个Texture被生成，但Demo只有两个，并且我自己写的代码Enable的并非FBO 1绑定生成的Texture而是第三个Texture，所以这是我怀疑我在加载Mesh的时候加载了第三个Texture并将其绑定在了Texture unit 0，而我碰巧激活了这一个Texture unit。</p>
<p>由于我的mesh.cpp是沿用上一个tutorial的代码，所以我没有更新到最新教程的mesh代码。<br>下面是我所用的mesh.cpp的一个加载Texture的方法和Texture源代码加载的时候的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Mesh::InitMaterials(<span class="keyword">const</span> aiScene* pScene, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load a white texture in case the model does not include its own texture</span></span><br><span class="line">    <span class="keyword">if</span> (!m_Textures[i]) &#123;</span><br><span class="line">        m_Textures[i] = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/white.png"</span>);</span><br><span class="line"></span><br><span class="line">        Ret = m_Textures[i]-&gt;Load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Mesh::Render()</span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MaterialIndex &lt; m_Textures.size() &amp;&amp; m_Textures[MaterialIndex]) &#123;</span><br><span class="line">        m_Textures[MaterialIndex]-&gt;Bind(GL_TEXTURE0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Texture::Load()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m_image.read(m_fileName);</span><br><span class="line">        m_image.write(&amp;m_blob, <span class="string">"RGBA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Magick::Error&amp; Error) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error loading texture '"</span> &lt;&lt; m_fileName &lt;&lt; <span class="string">"': "</span> &lt;&lt; Error.what() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_textureObj);</span><br><span class="line">    glBindTexture(m_textureTarget, m_textureObj);</span><br><span class="line">    glTexImage2D(m_textureTarget, <span class="number">0</span>, GL_RGBA, m_image.columns(), m_image.rows(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, m_blob.data());</span><br><span class="line">    glTexParameterf(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    </span><br><span class="line">    glBindTexture(m_textureTarget, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Texture::Bind(GLenum TextureUnit)</span><br><span class="line">&#123;</span><br><span class="line">    glActiveTexture(TextureUnit);</span><br><span class="line">    glBindTexture(m_textureTarget, m_textureObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出如果我加载的mesh没有含有贴图的话，我会指定他去默认加载white.png作为贴图，并且渲染的时候激活Texture unit 0并将该纹理绑定到Texture unit 0</p>
<p>这也就是为什么我后来调用下列代码出现了Active错误的texture的原因。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniform1i(gTextureLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">gShadowMapFBO.BindForReading(GL_TEXTURE0);</span><br></pre></td></tr></table></figure></p>
<p>所以在不改Texture和Mesh源代码的情况下，我只需要将生成的Texture unit绑定到GL_TEXTURE2并指定Shader去访问Texture unit 2即可。<br>将上述代码改为如下即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniform1i(gTextureLocation, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">gShadowMapFBO.BindForReading(GL_TEXTURE2);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/OpenGL/ShadowMapFirstPassSuccessful.PNG" alt="ShadowMapFirstPassSuccessful"></p>
<p>在渲染到Depth Texture的时候，主要是通过以下步骤：</p>
<ol>
<li><p>创建新的FBO和Texture object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the FBO</span></span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the depth texture</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;m_shadowMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, m_shadowMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活新的FBO并绑定Texture object到FBO的Depth buffer上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line">glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_shadowMap, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭颜色写入到新的FBO。因为我们只需要Depth信息，所以我们不需要写入颜色信息到新的FBO里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawBuffer(GL_NONE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查新的FBO的状态是否完整</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活新的FBO并清除Depth信息后以光线来源的角度draw call写入depth信息到新的FBO和绑定的depth texture里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShadowMapPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gShadowMapFBO.BindForWriting();</span><br><span class="line"></span><br><span class="line">	glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">	p.Rotate(<span class="number">0.0f</span>, gScale, <span class="number">0.0f</span>);</span><br><span class="line">	p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line">	p.SetCamera(gSpotLight.Position, gSpotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set uniform variable value</span></span><br><span class="line">	glUniformMatrix4fv(gWVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)p.GetWVPTrans());</span><br><span class="line"></span><br><span class="line">	gPTank-&gt;Render();</span><br><span class="line"></span><br><span class="line">	glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><em>Second Pass</em><br>Rendering the scene from the point of view of the viewer. Project the surface coordinates into the light’s reference frame and compare their depths to the depth recorded into the light’s depth texture. Fragments that are further from the light than the recorded depth value were not visible to the light, and hence in shadow</li>
</ul>
<p>第二个pass的关键有下列几个点：</p>
<ol>
<li><p>正常方式渲染时，通过传递Light的MVP去计算每一个顶点在光源角度观察时的投影位置信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    m_pLightingEffect-&gt;Enable();</span><br><span class="line"></span><br><span class="line">    m_pLightingEffect-&gt;SetEyeWorldPos(m_pGameCamera-&gt;GetPos());</span><br><span class="line">   </span><br><span class="line">    m_shadowMapFBO.BindForReading(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line">    Pipeline p;</span><br><span class="line">    p.SetPerspectiveProj(m_persProjInfo);</span><br><span class="line"></span><br><span class="line">    p.Scale(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    p.Rotate(<span class="number">90.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    m_pLightingEffect-&gt;SetWVP(p.GetWVPTrans());</span><br><span class="line">    m_pLightingEffect-&gt;SetWorldMatrix(p.GetWorldTrans());        </span><br><span class="line">    p.SetCamera(m_spotLight.Position, m_spotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    m_pLightingEffect-&gt;SetLightWVP(p.GetWVPTrans());</span><br><span class="line">    m_pGroundTex-&gt;Bind(GL_TEXTURE0);</span><br><span class="line">    m_pQuad-&gt;Render();</span><br><span class="line"></span><br><span class="line">    p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">    p.Rotate(<span class="number">0.0f</span>, m_scale, <span class="number">0.0f</span>);</span><br><span class="line">    p.WorldPos(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    m_pLightingEffect-&gt;SetWVP(p.GetWVPTrans());</span><br><span class="line">    m_pLightingEffect-&gt;SetWorldMatrix(p.GetWorldTrans());</span><br><span class="line">    p.SetCamera(m_spotLight.Position, m_spotLight.Direction, Vector3f(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    m_pLightingEffect-&gt;SetLightWVP(p.GetWVPTrans());</span><br><span class="line">    m_pMesh-&gt;Render();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lighting.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 TexCoord;                                             </span><br><span class="line">layout (location = <span class="number">2</span>) in vec3 Normal;                                               </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gWVP;                                                                  </span><br><span class="line">uniform mat4 gLightWVP;                                                             </span><br><span class="line">uniform mat4 gWorld;                                                                </span><br><span class="line">                                                                                    </span><br><span class="line">out vec4 LightSpacePos;                                                             </span><br><span class="line">out vec2 TexCoord0;                                                                 </span><br><span class="line">out vec3 Normal0;                                                                   </span><br><span class="line">out vec3 WorldPos0;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//这里就是转换到以光源为摄像机角度的透视投影后的坐标信息</span></span><br><span class="line">    LightSpacePos = <span class="function">gLightWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;                                 </span><br><span class="line">	......                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过把光源角度下投影的位置信息转换到NDC space(设备坐标系，光栅化后xyz都映射到[-1,1])，这时就得到了顶点在光源角度下NDC的坐标信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lighting.fs                                                 </span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcShadowFactor</span><span class="params">(vec4 LightSpacePos)</span>                                                 </span><br><span class="line"></span>&#123;      </span><br><span class="line">	<span class="comment">//通过除以w我们可以得到NDC space的信息</span></span><br><span class="line">    vec3 ProjCoords = LightSpacePos.xyz / LightSpacePos.w;                    </span><br><span class="line">	......                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后通过转换纹理坐标映射到[0,1]去查询Depth texture中的深度信息和自身的z深度信息作比较，如果depth texture中值更小说明改点处于被遮挡区域应该是阴影部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcShadowFactor</span><span class="params">(vec4 LightSpacePos)</span>                                                 </span><br><span class="line"></span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    vec2 UVCoords;                                                                         </span><br><span class="line">    UVCoords.x = <span class="number">0.5</span> * ProjCoords.x + <span class="number">0.5</span>;                                                 </span><br><span class="line">    UVCoords.y = <span class="number">0.5</span> * ProjCoords.y + <span class="number">0.5</span>;                                                 </span><br><span class="line">    <span class="keyword">float</span> z = <span class="number">0.5</span> * ProjCoords.z + <span class="number">0.5</span>;                                                    </span><br><span class="line">    <span class="keyword">float</span> Depth = texture(gShadowMap, UVCoords).x;                                         </span><br><span class="line">    <span class="keyword">if</span> (Depth &lt; z + <span class="number">0.00001</span>)                                                               </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>;                                                                        </span><br><span class="line">    <span class="keyword">else</span>                                                                                   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为原本x，y，z在NDC space下是[-1,1]，为了映射到[0,1]，我们只需要按上述方法即可。<br>这样一来就得到NDC space下的纹理坐标信息和深度z信息，然后通过查询depth texture获取光源角度的深度信息和现有顶点在光源角度的深度信息做比较得出是否处于阴影的结论。</p>
<p>这里实现相当复杂就没有自己再去写一遍，具体参考Tutorial 24的源代码。<br>最终效果：<br><img src="/img/OpenGL/ShadowMapFinal.PNG" alt="ShadowMap"></p>
<h3 id="Skybox">Skybox</h3><p>A skybox is a method of creating backgrounds to make a computer and video games level look bigger than it really is. When a skybox is used, the level is enclosed in a cuboid. (From wiki)<br><img src="/img/OpenGL/SkyboxTexture.PNG" alt="SkyboxTexture"></p>
<p>在OpenGL中实现Skybox是通过Cubemap。</p>
<p>In order to sample from the cubemap we will use a 3D texture coordinate instead of the 2D coordinate</p>
<p>Skydome —  A skybox which uses a sphere is sometimes called a skydome.</p>
<p>实现skybox主要有下列几点需要注意：</p>
<ol>
<li><p>生成Cubemap texture,分别指定6个对应skybox的六个面类型的纹理数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLenum types[<span class="number">6</span>] = &#123;  GL_TEXTURE_CUBE_MAP_POSITIVE_X,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_NEGATIVE_X,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_POSITIVE_Y,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_POSITIVE_Z,</span><br><span class="line">                                  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> CubemapTexture::Load()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//生成cubemap texture</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_textureObj);</span><br><span class="line">    glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureObj);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定对应skybox六个面类型的纹理数据</span></span><br><span class="line">    glTexImage2D(types[i], <span class="number">0</span>, GL_RGB, pImage-&gt;columns(), pImage-&gt;rows(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, blob.data());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染skybox的时候，需要把glCullFace和glDepthFunc设置成GL_FRONT和GL_LEQUAL（因为camera是放在skybox sphere内部的，而sphere的triangle是front face, 所以针对skybox sphere我们需要cull的是front而非back。为了使得skybox永远不会被clip掉，我们需要修改默认的glDepthFunc到GL_LEQUAL来确保在Z = 1的far平面也不会被clip。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SkyBox::Render()</span><br><span class="line">&#123;</span><br><span class="line">    m_pSkyboxTechnique-&gt;Enable();</span><br><span class="line"></span><br><span class="line">    GLint OldCullFaceMode;</span><br><span class="line">    glGetIntegerv(GL_CULL_FACE_MODE, &amp;OldCullFaceMode);</span><br><span class="line">    GLint OldDepthFuncMode;</span><br><span class="line">    glGetIntegerv(GL_DEPTH_FUNC, &amp;OldDepthFuncMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确保skybox sphere不被clip掉并且显示出正确的一面</span></span><br><span class="line">    glCullFace(GL_FRONT);</span><br><span class="line">    glDepthFunc(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line"></span><br><span class="line">    m_pMesh-&gt;Render();</span><br><span class="line"></span><br><span class="line">    glCullFace(OldCullFaceMode);</span><br><span class="line">    glDepthFunc(OldDepthFuncMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保skybox深度检测时值永远在Z = 1的far平面（这样一来确保skybox深度检测永远失败，因为我们吧glDepthFunc设置成了GL_LEQUAL）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">skybox.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">out vec3 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec4 WVP_Pos = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//通过把gl_Position的z设置成w，在光栅化进入fragment shader之前，skybox的z值会永远映射到1(即远平面)，确保skybox深度检测永远fail但永远不被clip（因为我们吧glDepthFunc设置成了GL_LEQUAL）</span></span><br><span class="line">    gl_Position = WVP_Pos.xyww;</span><br><span class="line">    TexCoord0 = Position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把object space的3D坐标当做3D texture坐标的索引值去查询纹理信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">skybox.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line">out vec3 TexCoord0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//因为cubemap这里默认cube和sphere都是以自身中心作为基准（个人认为这里的基准是可变的（建模工具可设定）），这样一来把object space的坐标信息通过光栅化后传递到fs中就可以作为texture coordinate来查询纹理信息</span></span><br><span class="line">    TexCoord0 = Position;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">skybox.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">in vec3 TexCoord0;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform samplerCube gCubemapTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这里的TexCoord0是经过光栅化后映射到了[-1,1]</span></span><br><span class="line">    FragColor = texture(gCubemapTexture, TexCoord0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/img/OpenGL/Skybox.PNG" alt="Skybox"></p>
<p>Note:<br>“An interesting performance tip is to always render the skybox last (after all the other models). The reason is that we know that it will always be behind the other objects in the scene.”</p>
<h3 id="Normal_Mapping">Normal Mapping</h3><p>在了解Normal Mapping之前不得不提Bump Mapping<br>下列关于Bump Mapping大部分内容来源:<br><a href="http://blog.csdn.net/pizi0475/article/details/48547329" target="_blank" rel="external">OpenGL 法线贴图 切线空间 整理</a><br><a href="https://en.wikipedia.org/wiki/Bump_mapping" target="_blank" rel="external">Bump mapping</a><br><a href="http://demo.netfoucs.com/zangle260/article/details/44156795" target="_blank" rel="external">关于法线贴图, 法线, 副法线, 切线 的东东,看了很容易理解</a></p>
<p>What is Bump Mapping?<br><a href="https://en.wikipedia.org/wiki/Bump_mapping" target="_blank" rel="external">Bump mapping[1] is a technique in computer graphics for simulating bumps and wrinkles on the surface of an object. This is achieved by perturbing the surface normals of the object and using the perturbed normal during lighting calculations.</a></p>
<p>可以看出Bump Mapping是通过改变物体顶点法线来影响光照的效果，最终看起来有凹凸的效果（而非顶点之间真实的深度差），是一种欺骗眼睛的技术。</p>
<p>“Jim Blinn在1978发表了一篇名为：“Simulation of Wrinkled Surfaces”，提出了Bump Mapping这个东东。Bump Mapping通过一张Height Map记录各象素点的高度信息，有了高度信息，就可以计算HeightMap中当前象素与周围象素的高度差，这个高度差就代表了各象素的坡度，用这个坡度信息去绕动法向量，得到最终法向量，用于光照计算。坡度越陡，绕动就越大。”</p>
<p>Why Bump Mapping?<br>“如果要在几何体表面表现出凹凸不平的细节，那么在建模的时候就会需要很多的三角面，如果用这样的模型去实时渲染，出来的效果是非常好，只是性能上很有可能无法忍受。Bump Mapping不需要增加额外的几何信息,就可以达到增强被渲染物体的表面细节的效果，可以大大地提高渲染速度，因此得到了广泛的应用。”</p>
<p>What is Normal Mapping?<br>“Normal Mapping也叫做Dot3 Bump Mapping,它也是Bump Mapping的一种，区别在于Normal Mapping技术直接把Normal存到一张NormalMap里面，从NormalMap里面采回来的值就是Normal，不需要像HeightMap那样再经过额外的计算。”</p>
<p>“值得注意的是，NormalMap存的Normal是基于切线空间的，因此要进行光照计算时，需要把Normal,Light Direction,View direction统一到同一坐标空间中。”</p>
<p>这里不得不提的一个点就是切线空间(tangent space)<br>What is tangent space?<br>“ Tangent Space与World Space，View Space其实是同样的概念，均代表三维坐标系。在这个坐标系中，X轴对应纹理坐标的U方向，沿着该轴纹理坐标U线性增大。Y轴对应纹理坐标的V方向，沿着该轴纹理坐标V线性增大。Z轴则是UXV，垂直于纹理平面。”</p>
<p>Why do we need tangent space?<br>“为什么normal map里面存的法线信息是基于tangent sapce而不是基于local space呢?基于local space理论上也是可以的，但是这样的normal map只能用于一个模型，不同把这个normal map用于其他模型。比如说建模了一个人，并且生成了该模型基于local space的normal map， 如果我们建模同一个人，但是放的位置和角度和之前的不一样，那么之前的normal map就不能用了，因为local Space并不一样，但如果我们normal map里存的是tangent space的normal的话，就不存在这个问题，因为只要模型一样，模型上每个点的tangent space就是一样的，所谓以不变应万变。”</p>
<p>可以看出tangent space是针对顶点而言的。</p>
<p>How to get tangent space?<br>让我们看一下下图：<br><img src="/img/OpenGL/TangentSpaceCaculation.PNG" alt="TangentSpaceCaculation"><br>以下推导来源于:<br><a href="http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html" target="_blank" rel="external">Tutorial 26:Normal Mapping</a><br><img src="/img/OpenGL/TangentSpaceDeduce.PNG" alt="TangentSpaceDeduce"><br><img src="/img/OpenGL/TangentSpaceDeduce2.PNG" alt="TangentSpaceDeduce2"><br>从上面而已看出通过三角形的顶点和纹理信息可以算出T和B</p>
<p>Note:<br>在实际开发中我们并非一定要手动写代码运算，比如”Open Asset Import Library就支持flag called ‘aiProcess_CalcTangentSpace’ which does exactly that and calculates the tangent vectors for us”</p>
<p>Normal Map也通过工具可以生成，比如3D Max， Maya， 教程里用的GNU Image Manipulation Program (GIMP)…….</p>
<p>当我们通过Normap Map获取得到normal值时，因为该normal值时位于tangent space下，所以我们必须对其进行坐标系转换，必须转换到world space后才参与光照计算。</p>
<p>而这个变换到世界坐标系的矩阵，可以通过tangent这个向量和顶点法线信息推导出来。</p>
<ol>
<li>加载mesh时生成tangent数据，渲染时指定tangent数据位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Mesh::LoadMesh(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Assimp::Importer Importer;</span><br><span class="line">    <span class="comment">//aiProcess_CalcTangentSpace指定生成tangent数据</span></span><br><span class="line">    <span class="keyword">const</span> aiScene* pScene = Importer.ReadFile(Filename.c_str(), aiProcess_Triangulate |</span><br><span class="line">                                                                aiProcess_GenSmoothNormals |</span><br><span class="line">                                                                aiProcess_FlipUVs |</span><br><span class="line">                                                                aiProcess_CalcTangentSpace);    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::Render()</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">//指定tangent数据读取方式</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">3</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">const</span> GLvoid*)<span class="number">32</span>); <span class="comment">// tangent</span></span><br><span class="line">     </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将tangent和顶点法线转换到世界坐标系</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">layout (location = 0) in vec3 Position;</span><br><span class="line">layout (location = 1) in vec2 TexCoord;</span><br><span class="line">layout (location = 2) in vec3 Normal;</span><br><span class="line">layout (location = 3) in vec3 Tangent;</span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line">uniform mat4 gLightWVP;</span><br><span class="line">uniform mat4 gWorld;</span><br><span class="line"></span><br><span class="line">out vec4 LightSpacePos;</span><br><span class="line">out vec2 TexCoord0;</span><br><span class="line">out vec3 Normal0;</span><br><span class="line">out vec3 WorldPos0;</span><br><span class="line">out vec3 Tangent0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	//将tangent和顶点法线转换到世界坐标系</span><br><span class="line">    Normal0 = (gWorld * vec4(Normal, 0.0)).xyz;</span><br><span class="line">    Tangent0 = (gWorld * vec4(Tangent, 0.0)).xyz;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过转换到世界坐标系的tangent和normal计算出bitangent（转换到世界坐标系后的B）（下面T代表tangent， N代表normal， B代表bitangent）</p>
</li>
<li><p>逆算出tangent space下normal map里的顶点法线值</p>
</li>
<li><p>通过算出的位于世界坐标系的TBN去转换tangent space下逆算后的normal map的顶点法线值，最终得到位于世界坐标的顶点法线</p>
</li>
<li><p>算出位于世界坐标系的顶点法线后，最后正常参与diffuse光照计算即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(lighting.fs:<span class="number">132</span>)</span><br><span class="line"><span class="function">vec3 <span class="title">CalcBumpedNormal</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec3 Normal = normalize(Normal0);</span><br><span class="line">    vec3 Tangent = normalize(Tangent0);</span><br><span class="line">    <span class="comment">//得到位于TN平面且垂直于N的向量</span></span><br><span class="line">    Tangent = normalize(Tangent - dot(Tangent, Normal) * Normal);</span><br><span class="line">    <span class="comment">//通过叉乘得出垂直于T和N的B</span></span><br><span class="line">    vec3 Bitangent = cross(Tangent, Normal);</span><br><span class="line">    vec3 BumpMapNormal = texture(gNormalMap, TexCoord0).xyz;</span><br><span class="line">    <span class="comment">//这里需要注意一点：</span></span><br><span class="line">    <span class="comment">//"我们在描述色彩的时候，RGB三个通道的取值范围都是从零开始的。可是当我们尝试把一个任意的法线保存在一张纹理中的时候，会面临取负值的问题。因此我们要把法线做压缩。方法很简单，把XYZ每个轴上的法线投影长度进行N＋1/2的运算。这样就把所有的法线压缩到了0和1的范围里。"</span></span><br><span class="line">    <span class="comment">//所以这里通过列方法算回原有的顶点法线值</span></span><br><span class="line">    BumpMapNormal = <span class="number">2.0</span> * BumpMapNormal - vec3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    vec3 NewNormal;</span><br><span class="line">    <span class="comment">//由于位于世界坐标系的T,N,B都算出来了，所以可以构建一个TBN的矩阵去把normal map里的法线值转换到世界坐标系</span></span><br><span class="line">    mat3 TBN = mat3(Tangent, Bitangent, Normal);</span><br><span class="line">    NewNormal = TBN * BumpMapNormal;</span><br><span class="line">    <span class="comment">//最后归一化算出来的顶点法线既得到了我们需要的位于世界坐标系的顶点法线，最后正常参与diffuse光照计算即可</span></span><br><span class="line">    NewNormal = normalize(NewNormal);</span><br><span class="line">    <span class="keyword">return</span> NewNormal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>让我们看看Normal Map Texture<br><img src="/img/OpenGL/NormalMapTexture.PNG" alt="NormalMapTexture"></p>
<p>See Normal Mapping(left) and Regular Mapping(right)<br><img src="/img/OpenGL/NormalMappingAndRegularMapping.PNG" alt="NormalMappingAndRegularMapping"></p>
<p>Note:<br><a href="https://en.wikipedia.org/wiki/Normal_mapping" target="_blank" rel="external">A common use of this(normal mapping) technique is to greatly enhance the appearance and details of a low polygon model by generating a normal map from a high polygon model or height map.</a></p>
<p>高模normal map用于低模模型上，即不增加渲染负担又能增加渲染细节。</p>
<p>More：<br><a href="http://blog.csdn.net/pizi0475/article/details/48547329" target="_blank" rel="external">下面内容来源</a><br>Parallax Mapping<br>当使用Normal Mapping技术时，并没有把视线方向考滤进去。在真实世界中，如果物体表面高低不平，当视线方向不同时，看到的效果也不相同。Parallax Mapping就是为了解决此问题而提出的。</p>
<p>Parallax Mapping首先在一篇名为“Detailed Shape Representation with Parallax Mapping”的文章中提出。它的基本思想如下图示（本图来自Parallax Mapping with Offset Limiting: A PerPixel Approximation of Uneven Surfaces）。在图示的视线方向，如果表面是真正的凹凸不平的，如real surfacer所示，那么能看到的是B点，因此用于采样法线的正确纹理坐是TB而不是TA。<br><img src="/img/OpenGL/ParallaxMappinge.PNG" alt="ParallaxMappinge"><br>因此，我们需要对纹理坐标作偏移，为了满足实时渲染的要求，采用了取近似偏移的方法（如下图示），这种近似的算法已经可以达到比较好的效果。具体的offset计算可以参考：“Parallax Mapping with Offset Limiting: A PerPixel Approximation of Uneven Surface”，里面有详细的讲解。<br><img src="/img/OpenGL/ParallaxMappinge2.PNG" alt="ParallaxMappinge2"></p>
<p>Parallax Occlusion Mapping<br>Parallax Occlusion Mapping是对Parallax Mapping的改进，DirectX SDK中有个Sample专门讲这个，相关细节可以参看此Sample. Parallax Occlusion Mapping中实现了Self Shadow，还计算了比较精确的offset，复杂度比Parallax Mapping大，但是实现效果更好。</p>
<h3 id="BillBoard_And_Geometry_Shader">BillBoard And Geometry Shader</h3><p>Geometry shader(Optional)<br>“The geometry shader sits logically right before primitive assembly and fragment shading.”</p>
<p>Receives as its input complete primitives as a collection of vertices, and these inputs are represented as array (Geometry shader接收完整图形的顶点集合，这些顶点集合在geometry shader中通过gl_in[]数组的方式访问)</p>
<p>gl_in的声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in gl_PerVertex &#123;</span><br><span class="line">vec4 gl_Position;</span><br><span class="line"><span class="keyword">float</span> gl_PointSize;</span><br><span class="line"><span class="keyword">float</span> gl_ClipDistance[];</span><br><span class="line">&#125;gl_in[];</span><br></pre></td></tr></table></figure></p>
<p>Geometry Features:</p>
<ol>
<li><p>Producing Primitives<br>They can have a different primitive type for their output than they do for their input. (EG: wireframe rendering, billboards and even interesting instancing effects)(Billboard效果见后面)</p>
</li>
<li><p>Culling Geometry<br>Selective culling （geometry shader通过对特定的gl_PrimitiveIDIn进行生成特定的primitive实现selective culling）<br>“gl_PrimitiveIDIn is a geometry language input variable that holds the number of primitives processed by the shader since the current set of rendering primitives was started.”</p>
</li>
<li><p>Geometry Amplification<br>Produces more primitives on its output than it accepts on its input<br>(can be used to implement fur shells or moderate tessellation — 因为可以对传入的primitive数据进行处理并生成多个primitive，所以能通过复制并改变primitive的信息数据来实现毛发等效果)<br>Gl_MaxGeometryOutputVertices &amp; glGetIntegerv(GL_MAX_GEOMETRY_OUTPUT_VERTICES)<br>毛发效果(来源OpenGL红宝书第八版)：<br><img src="/img/OpenGL/Geometry_Shader_Fur.PNG" alt="Geometry_Shader_Fur"></p>
</li>
<li><p>Geometry Shader Instance<br>Only runs the geometry shader and subsequent stages (rasterization) multiple times, rather than the whole pipeline (Geometry shader instancing draw call是通过运行多次geometry和rasterization和fragment来实现的)<br>Geometry shader instancing is enabled in the shader by specifying the invocations layout qualifier</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gl_InvocationID identifies the invocation number assigned to the geometry shader invocation.</span></span><br><span class="line">layout (triangles, invocations = <span class="number">4</span>) in;  <span class="comment">//invocations = 4 indicates that the geometry shader will be called 4 times for each input primitives</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Multiple Viewport Rendering<br>gl_ViewportIndex (output variables available in the geometry shader that can redirect rendering into different regions of the framebuffer)<br>gl_ViewportIndex is used to specify which set of viewport parameters will be used to perform the viewport transformation by OpenGL<br>“ (Multiple viewport concept （多个视图窗口） — 这里主要是通过gl_ViewportIndex访问多个viewport，然后在geometry shader中通过指定primitive输出到特定的viewport来实现多个视图窗口)<br>glViewportIndexedf() or glViewportIndexedfv() – specify how window x and y coordinates are generated from clip coordinates<br>glDepthRangeIndexed() – specify how the window z coordinate is generated<br>效果展示(这里展示的OpenGL红宝书第八版的例子)：<br><img src="/img/OpenGL/Multiple_Viewports.PNG" alt="Multiple_Viewports"></p>
</li>
<li><p>Layer Rendering<br>It is also possible to use a 2D array texture as a color attachment and render into the slices of the array using a geometry shader (传入2D的纹理数组数据当做color attachment，通过geometry shader把传入的2D纹理数组信息去渲染多个slices)<br>A restriction exits when using layered attachments to framebuffer: (使用layered attachment到framebuffer的规则):<br>All the attachments of that framebuffer must be layered (framebuffer的所有attachment都必须是layered)<br>Also, all attachments of a layered framebuffer must be of the same type (所有attach到layered framebuffer的attachment必须是同样类型)<br>gl_Layer – built in variable in geometry shader – that is used to specify the zero-based index of the layer into which rendering will be directed<br>可实现的效果好比:<br>Cube-Map<br>添加cube_map texture为color attachment到framebuffer中<br>cube-map texture(2D texture)这里会被划分成六个layer的array texture<br>通过instanced geometry shader生成六个faces（对应六个layer），通过gl_InvocationID和gl_Layer访问六个faces并做相应的projection matrices运算实现Cube_Map Face的效果</p>
</li>
<li><p>Advanced Transform Feedback<br>这里首先要了解下什么是Transform Feeback？<br>Transform feedback can be considered a stage of the OpenGL pipeline that sits after all of the vertex-processing stages and directly before primitive assembly and rasterization. Transform feedback captures vertices as they are assembled into primitives and allow some or all of their attributes to be recorded into buffer objects. (Transform feedback发生在所有顶点运算阶段之后（所以如果geometry shader打开了，transform feedback就发生在geometry shader之后，相反是在vertex shader之后），在primitive assembly和光栅化之前。Transform feedback可以保存顶点的一些属性信息用于下一次的运算。)</p>
</li>
</ol>
<p>Why do we need transform feedback?<br>“DirectX10 introduced a new feature known as Stream Output that is very useful for implementing particle systems. OpenGL followed in version 3.0 with the same feature and named it Transform Feedback. The idea behind this feature is that we can connect a special type of buffer (called Transform Feedback Buffer right after the GS (or the VS if the GS is absent) and send our transformed primitives to it. In addition, we can decide whether the primitives will also continue on their regular route to the rasterizer. The same buffer can be connected as a vertex buffer in the next draw and provide the vertices that were output in the previous draw as input into the next draw. This loop enables the two steps above to take place entirely on the GPU with no application involvement (other than connecting the proper buffers for each draw and setting up some state).”</p>
<p>从上面可以看出，transform feedback可以帮助我们在构建primitive之前保存顶点相关的一些信息参与到下一次draw的运算且不用参与到Clipping，rasterizer和FS。最重要的是所有这一切都发生在GPU上，不需要从GPU上copy数据到CPU上做运算。</p>
<p>大致情况如下图：<br><img src="/img/OpenGL/TransformFeedbackFlowchart.PNG" alt="TransformFeedbackFlowchart"></p>
<p>了解一些相关概念：<br>Transform Feedback Objects:<br>“The state required to represent transform feedback is encapsulated into a<br>transform feedback object.”(transform feedback objects主要是存储跟transform feedback相关的一些状态。比如：哪一个buffer绑定到了transform feedback buffer的binding point)</p>
<p>Transform Feedback Buffer:<br>vertex shader或geometry shader中获取来的信息，这里的TFB是指通过glBindBufferBase之类方法后被绑定到Tansform Feedback Objects上的buffer</p>
<p>glBindBufferBase调用的时候需要指定index作为binding point，如果我们想要把Transform Feedback Buffer的数据存储在多个buffer的时候我们可以把多个buffer绑定到不同的binding point上，然后通过glTransformFeedbackVaryings传入的参数格式决定我们生成的数据是如何写入到各个buffer里的。</p>
<p>具体的glTransformFeedbackVaryings如何配置决定数据是如何写入到各个buffer的参见OpenGL红宝书Configuring Transform Feedback Varyings</p>
<p>因为粒子效果用到了Billboard来展示，所以在了解Particle System之前，我们先来看看Billboard是如何通过GS实现的：<br>Billboard - “A billboard is a quad which always faces the camera. “</p>
<ol>
<li><p>Before a geometry shader may be linked, the input primitive type, output primitive type, and the maximum number of vertices that is might produce must be specified (在链接geometry shader之前，我们必须先定义geometry shader的输入输出类型) </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version <span class="number">330</span>                                                                        </span><br><span class="line"><span class="comment">//指明GS中传入的数据是以点为单位                                                           layout(points) in;                                                                  </span></span><br><span class="line"><span class="comment">//指明GS将输出的primitive是triangle_strip</span></span><br><span class="line">layout(triangle_strip) out;              </span><br><span class="line"><span class="comment">//指明GS生成的最大顶点数量是4，因为这里我们只需4个顶点组成一个quad即可</span></span><br><span class="line">layout(max_vertices = <span class="number">4</span>) out;                                                       </span><br><span class="line">          </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                    </span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//e.g:</span></span><br><span class="line"><span class="comment">//layout (input primitive type) in;</span></span><br><span class="line"><span class="comment">//layout (output primitive type, max_vertices = number) out; (这里的max_//vertices会遇到一个硬件限制所支持的max_vertices的最大值--超出最大值后program //link会出错，通过在program link后调用glGetProgramiv() with GL_INFO_LOG_LENGTH //parameter可以得program link的出错信息，shader compile的log同理)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用传递进来的顶点primitive数据生成新的面向camera的primitive数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#version 330                                                                        </span><br><span class="line">                                                                                    </span><br><span class="line">layout(points) in;                                                                  </span><br><span class="line">layout(triangle_strip) out;                                                         </span><br><span class="line">layout(max_vertices = 4) out;                                                       </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gVP;                                                                   </span><br><span class="line">uniform vec3 gCameraPos;                                                            </span><br><span class="line">                                                                                    </span><br><span class="line">out vec2 TexCoord;                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line">void main()                                                                         </span><br><span class="line">&#123;  </span><br><span class="line">    //通过gl_in我们可以在GS中访问传入的primitive的顶点数据，这里因为我们指定了传入的layout(points) in，所以这里只需访问gl_in[0]即可                                        </span><br><span class="line">    //通过计算出面向camera时quad所在的物体坐标系信息，我们在这基础上对顶点数据做偏移，这样算出来的顶点数据生成的primitive始终面向Camera                              </span><br><span class="line">    vec3 Pos = gl_in[0].gl_Position.xyz;                                            </span><br><span class="line">    vec3 toCamera = normalize(gCameraPos - Pos);                                    </span><br><span class="line">    vec3 up = vec3(0.0, 1.0, 0.0);                                                  </span><br><span class="line">    vec3 right = cross(toCamera, up);                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos -= (right * 0.5);</span><br><span class="line">    //这里之所以只传gVP而非gMVP是因为我们在创建顶点数据的时候就是传递的世界坐标信息</span><br><span class="line">    gl_Position = gVP * vec4(Pos, 1.0);                                             </span><br><span class="line">    TexCoord = vec2(0.0, 0.0);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += 1.0;                                                                   </span><br><span class="line">    gl_Position = gVP * vec4(Pos, 1.0);                                             </span><br><span class="line">    TexCoord = vec2(0.0, 1.0);                                                      </span><br><span class="line">    //通过调用EmitVertex指定利用上面的数据生成新的vertex加入到最终的primitive构造中</span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y -= 1.0;                                                                   </span><br><span class="line">    Pos += right;                                                                   </span><br><span class="line">    gl_Position = gVP * vec4(Pos, 1.0);                                             </span><br><span class="line">    TexCoord = vec2(1.0, 0.0);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += 1.0;                                                                   </span><br><span class="line">    gl_Position = gVP * vec4(Pos, 1.0);                                             </span><br><span class="line">    TexCoord = vec2(1.0, 1.0);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">    //通过调用EndPrimitive指定前面生成的顶点数据作为一个新的primitive  </span><br><span class="line">    EndPrimitive();                                                                 </span><br><span class="line">&#125;           </span><br><span class="line"></span><br><span class="line">void BillboardList::CreatePositionBuffer()</span><br><span class="line">&#123;    </span><br><span class="line">    Vector3f Positions[NUM_ROWS * NUM_COLUMNS];</span><br><span class="line">    //创建顶点数据的时候即传递的世界坐标</span><br><span class="line">    for (unsigned int j = 0 ; j &lt; NUM_ROWS ; j++) &#123;</span><br><span class="line">        for (unsigned int i = 0 ; i &lt; NUM_COLUMNS ; i++) &#123;</span><br><span class="line">            Vector3f Pos((float)i, 0.0f, (float)j);            </span><br><span class="line">            Positions[j * NUM_COLUMNS + i] = Pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> EmitVertex() - produces a new vertex at the output of the geometry shader. Each time it is called, a vertex is appended to the end of the current strip (将新的vertex加入到primitive的队列)<br> EndPrimitive() - breaks the current strip and signals OpenGL that a new strip should be started the next time EmitVertex() is called (将之前所加入的vertex算作一个primitive的信息，通知OpenGL开始下一个primitive的构造)<br> Note:<br> When the geometry shader exits, the current primitive is ended implicitly (如果geometry shader结束了，那么当前还没有调用EndPrimitive()的primitive将视作结束)<br> When EndPrimitive() is called, any incomplete primitives will simply be discarded (当EndPrimitive()被调用的时候，数据不完全的primitive将被抛弃 — 不调用这个方法的primitive相当于culling掉)</p>
</li>
<li><p>在FS中利用GS中生成的纹理坐标映射纹理信息并Cull掉纹理图片中黑色的部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">uniform sampler2D gColorMap;                                                        </span><br><span class="line">                                                                                    </span><br><span class="line">in vec2 TexCoord;                                                                   </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    FragColor = texture2D(gColorMap, TexCoord);                                     </span><br><span class="line">    <span class="comment">//Cull掉纹理图片中黑色的部分</span></span><br><span class="line">    <span class="keyword">if</span> (FragColor.r == <span class="number">0</span> &amp;&amp; FragColor.g == <span class="number">0</span> &amp;&amp; FragColor.b == <span class="number">0</span>) &#123;</span><br><span class="line">        discard;                                                                    </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Final Effect:<br><img src="/img/OpenGL/GSBillboard.PNG" alt="GSBillboard"></p>
<p>接下来我们看看通过Transform Feedback实现Particle System的步骤：</p>
<ol>
<li><p>生成Transform Feedback Objets和用于存储数据的buffer,并将buffer绑定到特定Transform Feedback Objects上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ParticleSystem::InitParticleSystem(<span class="keyword">const</span> Vector3f&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    Particle Particles[MAX_PARTICLES];</span><br><span class="line">	ZERO_MEM(Particles);</span><br><span class="line">    <span class="comment">//Particle System最初的那个发射点信息</span></span><br><span class="line">	Particles[<span class="number">0</span>].Type = PARTICLE_TYPE_LAUCHER;</span><br><span class="line">	Particles[<span class="number">0</span>].Pos = pos;</span><br><span class="line">	Particles[<span class="number">0</span>].Vel = Vector3f(<span class="number">0.0f</span>, <span class="number">0.0001f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	Particles[<span class="number">0</span>].LifetimeMillis = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//生成2个transform feedback object和两个buffer</span></span><br><span class="line">    <span class="comment">//"OpenGL enforces a general limitation that the same resource cannot be bound for both input and output in the same draw call. //This means that if we want to update the particles in a vertex buffer we actually need two transform feedback buffers and toggle between them. //On frame 0 we will update the particles in buffer A and render the particles from buffer B and on frame 1 we will update the particles in buffer B and render the particles from buffer "</span></span><br><span class="line">    <span class="comment">//从上面可以看出我们之所以生成两个Transform Feedback Object和两个buffer是因为OpenGL要求我们不能在一次draw call里把同一个resource(这里指TFB和buffer)即作为输入也作为输出</span></span><br><span class="line">    <span class="comment">//所以我们想要通过fist pass去记录一些数据信息，然后再将其渲染到屏幕上，我们必须通过切换两个TFO和buffer来实现</span></span><br><span class="line">    <span class="comment">//记录到A的时候用B数据渲染，记录到B的时候通过A数据来渲染</span></span><br><span class="line">	glGenTransformFeedbacks(<span class="number">2</span>, m_TransformFeedback);</span><br><span class="line"></span><br><span class="line">	glGenBuffers(<span class="number">2</span>, m_ParticleBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//绑定TFO，使得接下来在TFB上的操作是跟特定TFO(transform feedback object)挂钩的</span></span><br><span class="line">		glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, m_TransformFeedback[i]);</span><br><span class="line">		glBindBuffer(GL_ARRAY_BUFFER, m_ParticleBuffer[i]);</span><br><span class="line">		glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Particles), Particles, GL_DYNAMIC_DRAW);</span><br><span class="line">		<span class="comment">//绑定对应buffer的对应的TFO上</span></span><br><span class="line">		glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, m_ParticleBuffer[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Transform Feedback Varyings(指定我们会如何在GS中去如何记录和存储哪些信息)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PSUpdateTechnique::Init()</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> GLchar* Varyings[<span class="number">4</span>];    </span><br><span class="line">    Varyings[<span class="number">0</span>] = <span class="string">"Type1"</span>;</span><br><span class="line">    Varyings[<span class="number">1</span>] = <span class="string">"Position1"</span>;</span><br><span class="line">    Varyings[<span class="number">2</span>] = <span class="string">"Velocity1"</span>;    </span><br><span class="line">    Varyings[<span class="number">3</span>] = <span class="string">"Age1"</span>;</span><br><span class="line">    <span class="comment">//在链接Update Shader之前，我们需要指明TFB会如何去记录和存储数据信息</span></span><br><span class="line">    <span class="comment">//这里指明了我们会在GS中去记录Varyings中四个变量的数据信息到TFB中</span></span><br><span class="line">    <span class="comment">//GL_INTERLEAVED_ATTRIBS表示我们会把所有的attribute数据都记录到一个buffer里   </span></span><br><span class="line">    glTransformFeedbackVaryings(m_shaderProg, <span class="number">4</span>, Varyings, GL_INTERLEAVED_ATTRIBS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Finalize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置设定一些Update Shader和Billboard Shader的一些数据信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ParticleSystem::InitParticleSystem(<span class="keyword">const</span> Vector3f&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_UpdateTechnique.Init())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_UpdateTechnique.Enable();</span><br><span class="line"></span><br><span class="line">	m_UpdateTechnique.SetRandomTextureUnit(RANDOM_TEXTURE_UNIT_INDEX);</span><br><span class="line">	m_UpdateTechnique.SetLauncherLifetime(<span class="number">100.0f</span>);</span><br><span class="line">	m_UpdateTechnique.SetShellLifetime(<span class="number">10000.0f</span>);</span><br><span class="line">	m_UpdateTechnique.SetSecondaryShellLifetime(<span class="number">2500.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_RandomTexture.InitRandomTexture(<span class="number">1000</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_RandomTexture.Bind(RANDOM_TEXTURE_UNIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_BillboardTechnique.Init())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_BillboardTechnique.Enable();</span><br><span class="line"></span><br><span class="line">	m_BillboardTechnique.SetColorTextureUnit(COLOR_TEXTURE_UNIT_INDEX);</span><br><span class="line"></span><br><span class="line">	m_BillboardTechnique.SetBillboardSize(<span class="number">0.01f</span>);</span><br><span class="line"></span><br><span class="line">	m_PTexture = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/fireworks_red.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!m_PTexture-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GLCheckError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次Draw Call，两个Pass，一个Pass去更新TFB里的数据，一个Pass去渲染TFB里的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	gParticleSystem.Render(deltatimemillis, p.GetVPTrans(), pGameCamera-&gt;GetPos());</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ParticleSystem::Render(<span class="keyword">int</span> deltatimemillis, <span class="keyword">const</span> Matrix4f&amp; vp, <span class="keyword">const</span> Vector3f&amp; camerapos)</span><br><span class="line">&#123;</span><br><span class="line">	m_Time += deltatimemillis;</span><br><span class="line">	<span class="comment">//因为Shader里会去模拟真实重力和粒子移动效果，所以Update的时候需要delta time</span></span><br><span class="line">	UpdateParticles(deltatimemillis);</span><br><span class="line"></span><br><span class="line">	RenderParticles(vp, camerapos);</span><br><span class="line">	<span class="comment">//这里就是我们之前说的通过切换两个TFO和buffer来实现一边更新TFB一边渲染TFB的效果</span></span><br><span class="line">	m_CurrVB = m_CurrTFB;</span><br><span class="line">	m_CurrTFB = (m_CurrTFB + <span class="number">1</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ParticleSystem::UpdateParticles(<span class="keyword">int</span> deltamillis)</span><br><span class="line">&#123;</span><br><span class="line">	m_UpdateTechnique.Enable();</span><br><span class="line">	m_UpdateTechnique.SetTime(m_Time);</span><br><span class="line">	m_UpdateTechnique.SetDeltaTimeMillis(deltamillis);</span><br><span class="line"></span><br><span class="line">	m_RandomTexture.Bind(RANDOM_TEXTURE_UNIT);</span><br><span class="line">    <span class="comment">//这里之所以调用glEnable(GL_RASTERIZER_DISCARD)是因为在Update Pass时，我们不需要进入RS阶段，所以这里关闭了Rasterizer</span></span><br><span class="line">	glEnable(GL_RASTERIZER_DISCARD);</span><br><span class="line">    <span class="comment">//Update Pass的时候，我们把m_ParticleBuffer[m_CurrVB]作为数据输入</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, m_ParticleBuffer[m_CurrVB]);</span><br><span class="line">	<span class="comment">//通过绑定m_TransformFeedback[m_CurrTFB]到GL_TRANSFORM_FEEDBACK，我们把GS里生成的数据存储到绑定了m_TransformFeedback[m_CurrTFB]的m_ParticleBuffer[m_CurrTFB] buffer里</span></span><br><span class="line">	<span class="comment">//这里就是我们说的A作为输入，B作为输出</span></span><br><span class="line">	glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, m_TransformFeedback[m_CurrTFB]);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">	glEnableVertexAttribArray(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">1</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), <span class="number">0</span>);                          <span class="comment">// type</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">4</span>);         <span class="comment">// position</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">2</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">16</span>);        <span class="comment">// velocity</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">3</span>, <span class="number">1</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">28</span>);          <span class="comment">// lifetime</span></span><br><span class="line">    <span class="comment">//激活Transform Feedback，指明GS输出的primitive type</span></span><br><span class="line">	glBeginTransformFeedback(GL_POINTS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_IsFirst)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//只有第一次我们是知道我们会draw的Point数量（因为particle发射器只有一个）</span></span><br><span class="line">		glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		m_IsFirst = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//第二次以后，顶点数量是未知的，因为GS是可以生成多个顶点数据的。</span></span><br><span class="line">		<span class="comment">//"The system automatically tracks the number of vertices for us for each buffer and later uses that number internally when the buffer is used for input. "</span></span><br><span class="line">		<span class="comment">//从上面可知，transfor feedback buffer里的顶点数量系统会自己去track</span></span><br><span class="line">		<span class="comment">//我们只需通知用哪一个TFB绑定的buffer作为数据输入即可</span></span><br><span class="line">		glDrawTransformFeedback(GL_POINTS, m_TransformFeedback[m_CurrVB]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glEndTransformFeedback();</span><br><span class="line"></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">	glDisableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">	glDisableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">	glDisableVertexAttribArray(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ParticleSystem::RenderParticles(<span class="keyword">const</span> Matrix4f&amp; vp, <span class="keyword">const</span> Vector3f&amp; camerapos)</span><br><span class="line">&#123;</span><br><span class="line">	m_BillboardTechnique.Enable();</span><br><span class="line">	m_BillboardTechnique.SetCameraPosition(camerapos);</span><br><span class="line">	m_BillboardTechnique.SetVP(vp);</span><br><span class="line">	m_PTexture-&gt;Bind(COLOR_TEXTURE_UNIT);</span><br><span class="line">    <span class="comment">//第二Pass的时候，我们需要渲染出图像，所以需要开启Rasterizer</span></span><br><span class="line">	glDisable(GL_RASTERIZER_DISCARD);</span><br><span class="line">    <span class="comment">//这里通过使用之前记录到m_ParticleBuffer[m_CurrTFB]的数据作为输入进行渲染</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, m_ParticleBuffer[m_CurrTFB]);</span><br><span class="line"></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Particle), (<span class="keyword">const</span> GLvoid*)<span class="number">4</span>);  <span class="comment">// position</span></span><br><span class="line">    <span class="comment">//绘制并渲染m_TransformFeedback[m_CurrTFB]所绑定的m_ParticleBuffer[m_CurrTFB]里的数据</span></span><br><span class="line">	glDrawTransformFeedback(GL_POINTS, m_TransformFeedback[m_CurrTFB]);</span><br><span class="line"></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是看Update Shader是如何去更新模拟粒子的生成和重力效果的,billboard Shader是如何将生成的顶点粒子数据渲染到屏幕上的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">ps_update.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in <span class="keyword">float</span> Type;                                                </span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 Position;                                             </span><br><span class="line">layout (location = <span class="number">2</span>) in vec3 Velocity;                                             </span><br><span class="line">layout (location = <span class="number">3</span>) in <span class="keyword">float</span> Age;                                                 </span><br><span class="line">                                                                                    </span><br><span class="line">out <span class="keyword">float</span> Type0;                                                                    </span><br><span class="line">out vec3 Position0;                                                                 </span><br><span class="line">out vec3 Velocity0;                                                                 </span><br><span class="line">out <span class="keyword">float</span> Age0;                                                                     </span><br><span class="line"></span><br><span class="line"><span class="comment">//VS里我们只是正常获取传入的顶点相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    Type0 = Type;                                                                   </span><br><span class="line">    Position0 = Position;                                                           </span><br><span class="line">    Velocity0 = Velocity;                                                           </span><br><span class="line">    Age0 = Age;                                                                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps_update.gs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout(points) in;                                                                  </span><br><span class="line">layout(points) out;                                                                 </span><br><span class="line">layout(max_vertices = <span class="number">30</span>) out;                                                      </span><br><span class="line">                                                                                    </span><br><span class="line">in <span class="keyword">float</span> Type0[];                                                                   </span><br><span class="line">in vec3 Position0[];                                                                </span><br><span class="line">in vec3 Velocity0[];                                                                </span><br><span class="line">in <span class="keyword">float</span> Age0[];                                                                    </span><br><span class="line">                                                                                    </span><br><span class="line">out <span class="keyword">float</span> Type1;                                                                    </span><br><span class="line">out vec3 Position1;                                                                 </span><br><span class="line">out vec3 Velocity1;                                                                 </span><br><span class="line">out <span class="keyword">float</span> Age1;                                                                     </span><br><span class="line">                                                                                    </span><br><span class="line">uniform <span class="keyword">float</span> gDeltaTimeMillis;                                                     </span><br><span class="line">uniform <span class="keyword">float</span> gTime;                                                                </span><br><span class="line">uniform sampler1D gRandomTexture;                                                   </span><br><span class="line">uniform <span class="keyword">float</span> gLauncherLifetime;                                                    </span><br><span class="line">uniform <span class="keyword">float</span> gShellLifetime;                                                       </span><br><span class="line">uniform <span class="keyword">float</span> gSecondaryShellLifetime;                                              </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PARTICLE_TYPE_LAUNCHER <span class="number">0.0f</span>                                                 </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PARTICLE_TYPE_SHELL <span class="number">1.0f</span>                                                    </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PARTICLE_TYPE_SECONDARY_SHELL <span class="number">2.0f</span>                                          </span></span><br><span class="line">       </span><br><span class="line"><span class="comment">//获取随机方向的方法，我们在gRandomTexture里随机写入了1D的数据信息</span></span><br><span class="line"><span class="function">vec3 <span class="title">GetRandomDir</span><span class="params">(<span class="keyword">float</span> TexCoord)</span>                                                   </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">     vec3 Dir = texture(gRandomTexture, TexCoord).xyz;                              </span><br><span class="line">     Dir -= vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);                                                    </span><br><span class="line">     <span class="keyword">return</span> Dir;                                                                    </span><br><span class="line">&#125;                                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    <span class="keyword">float</span> Age = Age0[<span class="number">0</span>] + gDeltaTimeMillis;                                         </span><br><span class="line">                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (Type0[<span class="number">0</span>] == PARTICLE_TYPE_LAUNCHER) &#123;</span><br><span class="line">        <span class="comment">//如果粒子发射器life time达到，我们在粒子发射器的位置生成新的粒子（随机方向）                                       </span></span><br><span class="line">        <span class="keyword">if</span> (Age &gt;= gLauncherLifetime) &#123;                                             </span><br><span class="line">            Type1 = PARTICLE_TYPE_SHELL;                                            </span><br><span class="line">            Position1 = Position0[<span class="number">0</span>];                                               </span><br><span class="line">            vec3 Dir = GetRandomDir(gTime/<span class="number">1000.0</span>);                                  </span><br><span class="line">            Dir.y = max(Dir.y, <span class="number">0.5</span>);                                                </span><br><span class="line">            Velocity1 = normalize(Dir) / <span class="number">20.0</span>;                                      </span><br><span class="line">            Age1 = <span class="number">0.0</span>;                                                             </span><br><span class="line">            EmitVertex();                                                           </span><br><span class="line">            EndPrimitive();                                                         </span><br><span class="line">            Age = <span class="number">0.0</span>;                                                              </span><br><span class="line">        &#125;                                                                           </span><br><span class="line">        <span class="comment">//重置并生成新的粒子发射器使其持续生成粒子</span></span><br><span class="line">        Type1 = PARTICLE_TYPE_LAUNCHER;                                             </span><br><span class="line">        Position1 = Position0[<span class="number">0</span>];                                                   </span><br><span class="line">        Velocity1 = Velocity0[<span class="number">0</span>];                                                   </span><br><span class="line">        Age1 = Age;                                                                 </span><br><span class="line">        EmitVertex();                                                               </span><br><span class="line">        EndPrimitive();                                                             </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        <span class="comment">//当当前粒子不是粒子发射器的时候，我们通过传入的delta time去更新粒子的位置持续时间等相关信息</span></span><br><span class="line">        <span class="keyword">float</span> DeltaTimeSecs = gDeltaTimeMillis / <span class="number">1000.0f</span>;                           </span><br><span class="line">        <span class="keyword">float</span> t1 = Age0[<span class="number">0</span>] / <span class="number">1000.0</span>;                                                </span><br><span class="line">        <span class="keyword">float</span> t2 = Age / <span class="number">1000.0</span>;                                                    </span><br><span class="line">        vec3 DeltaP = DeltaTimeSecs * Velocity0[<span class="number">0</span>];                                 </span><br><span class="line">        vec3 DeltaV = vec3(DeltaTimeSecs) * (<span class="number">0.0</span>, -<span class="number">9.81</span>, <span class="number">0.0</span>);                      </span><br><span class="line">        <span class="keyword">if</span> (Type0[<span class="number">0</span>] == PARTICLE_TYPE_SHELL)  &#123;                                     </span><br><span class="line">            <span class="comment">//若当前粒子是第一次粒子发射器发散出的粒子</span></span><br><span class="line">            <span class="comment">//我们通过粒子的持续时间决定是否进入第二次粒子炸裂阶段</span></span><br><span class="line">	        <span class="keyword">if</span> (Age &lt; gShellLifetime) &#123;</span><br><span class="line">	            <span class="comment">//还没达到炸裂时间点，我们仅仅更新该粒子的位置持续时间等相关信息</span></span><br><span class="line">	            Type1 = PARTICLE_TYPE_SHELL;                                        </span><br><span class="line">	            Position1 = Position0[<span class="number">0</span>] + DeltaP;                                  </span><br><span class="line">	            Velocity1 = Velocity0[<span class="number">0</span>] + DeltaV;                                  </span><br><span class="line">	            Age1 = Age;                                                         </span><br><span class="line">	            EmitVertex();                                                       </span><br><span class="line">	            EndPrimitive();                                                     </span><br><span class="line">	        &#125;                                                                       </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当由粒子发射器发散出的粒子达到炸裂时间点的时候，我们通过该粒子所在位置随机生成10个随机方向的粒子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;                                    </span><br><span class="line">                     Type1 = PARTICLE_TYPE_SECONDARY_SHELL;                         </span><br><span class="line">                     Position1 = Position0[<span class="number">0</span>];                                      </span><br><span class="line">                     vec3 Dir = GetRandomDir((gTime + i)/<span class="number">1000.0</span>);                   </span><br><span class="line">                     Velocity1 = normalize(Dir) / <span class="number">20.0</span>;                             </span><br><span class="line">                     Age1 = <span class="number">0.0f</span>;                                                   </span><br><span class="line">                     EmitVertex();                                                  </span><br><span class="line">                     EndPrimitive();                                                </span><br><span class="line">                &#125;                                                                   </span><br><span class="line">            &#125;                                                                       </span><br><span class="line">        &#125;                                                                           </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进入到第二次发散阶段的粒子，如果还在生命时间内，我们就更新起位置持续时间等相关信息，否则直接略过该粒子(即粒子消亡)                                </span></span><br><span class="line">            <span class="keyword">if</span> (Age &lt; gSecondaryShellLifetime) &#123;                                    </span><br><span class="line">                Type1 = PARTICLE_TYPE_SECONDARY_SHELL;                              </span><br><span class="line">                Position1 = Position0[<span class="number">0</span>] + DeltaP;                                  </span><br><span class="line">                Velocity1 = Velocity0[<span class="number">0</span>] + DeltaV;                                  </span><br><span class="line">                Age1 = Age;                                                         </span><br><span class="line">                EmitVertex();                                                       </span><br><span class="line">                EndPrimitive();                                                     </span><br><span class="line">            &#125;                                                                       </span><br><span class="line">        &#125;                                                                           </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">&#125;                                                                                   </span><br><span class="line"></span><br><span class="line">ps_update.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"><span class="comment">//因为Update Shader只负责update粒子信息，不许要渲染，所以这里ps_update.fs为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终的通过transform feedback生成的粒子信息会通过billboard一一渲染出来</span></span><br><span class="line">billboard.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line"><span class="comment">//这里只需要粒子的位置信息即可                                                         </span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    gl_Position = vec4(Position, <span class="number">1.0</span>);                                              </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">billboard.gs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout(points) in;                                                                  </span><br><span class="line">layout(triangle_strip) out;                                                         </span><br><span class="line">layout(max_vertices = <span class="number">4</span>) out;                                                       </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gVP;                                                                   </span><br><span class="line">uniform vec3 gCameraPos;                                                            </span><br><span class="line">uniform <span class="keyword">float</span> gBillboardSize;                                                       </span><br><span class="line">                                                                                    </span><br><span class="line">out vec2 TexCoord;                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    vec3 Pos = gl_in[<span class="number">0</span>].gl_Position.xyz;                                            </span><br><span class="line">    vec3 toCamera = normalize(gCameraPos - Pos);                                    </span><br><span class="line">    vec3 up = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);                                                  </span><br><span class="line">    vec3 right = cross(toCamera, up) * gBillboardSize;                              </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos -= right;                                                                   </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">0.0</span>, <span class="number">0.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += gBillboardSize;                                                        </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">0.0</span>, <span class="number">1.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y -= gBillboardSize;                                                        </span><br><span class="line">    Pos += right;                                                                   </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">1.0</span>, <span class="number">0.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    Pos.y += gBillboardSize;                                                        </span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(Pos, <span class="number">1.0</span>)</span></span>;                                             </span><br><span class="line">    TexCoord = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>);                                                      </span><br><span class="line">    EmitVertex();                                                                   </span><br><span class="line">                                                                                    </span><br><span class="line">    EndPrimitive();                                                                 </span><br><span class="line">&#125;                                                                                   </span><br><span class="line"></span><br><span class="line">billboard.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">uniform sampler2D gColorMap;                                                        </span><br><span class="line">                                                                                    </span><br><span class="line">in vec2 TexCoord;                                                                   </span><br><span class="line">out vec4 FragColor;                                                                 </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    FragColor = texture2D(gColorMap, TexCoord);                                     </span><br><span class="line">    <span class="comment">//过滤掉粒子纹理图片里较白的部分                                                </span></span><br><span class="line">    <span class="keyword">if</span> (FragColor.r &gt;= <span class="number">0.9</span> &amp;&amp; FragColor.g &gt;= <span class="number">0.9</span> &amp;&amp; FragColor.b &gt;= <span class="number">0.9</span>) &#123;           </span><br><span class="line">        discard;                                                                    </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过glDEBugger我们可以查看到Transform Feedback生成的数据信息：<br><img src="/img/OpenGL/TransformFeedbackBufferData.PNG" alt="TransformFeedbackBufferData"></p>
<p>Final Effect:<br><img src="/img/OpenGL/ParticleSystem.PNG" alt="ParticleSystem"></p>
<p>接下来让我们来看看Transform Feedback的更多高级使用：<br><strong>Multiple Output Steams</strong><br>Multiple streams of vertices can be declared as outputs in the geometry shader （通过stream我们可以把一些额外需要保存的信息保存到特定的stream里便于transform feedback buffer去访问并进行进一步的处理）</p>
<p>Using the stream layout qualifier – this layout qualifier may be applied globally, to an interface block, or to a single output declaration</p>
<p>Each stream is numbered, starting from zero, max number of streams – GL_MAX_VERTEX_STREAMS</p>
<p>When the stream number is given at global scope, all subsequently declared geometry shader outputs become members of that stream until another output stream layout qualifier is specified<br>See how to declaration stream:<br><img src="/img/OpenGL/StreamDeclaration.PNG" alt="StreamDeclaration"></p>
<p>Multiple output stream’s built in GLSL functions:<br>EmitStreamVertex(int stream)<br>EndStreamVertex(int stream)</p>
<p>glTransformFeedbackVaryings() – tell OpenGL how those streams are mapped into transform feedback buffer （告诉OpenGL各个stream是怎么映射到transform feedback buffer的）</p>
<p>When multiple streams are active, it is required that variables associated with a single stream are not written into the same buffer binding point as those associated with any other stream(当多个stream声明激活的时候，我们必须将每一个stream写到不同的buffer binding point里)</p>
<p>gl_NextBuffer is used to signal that the following output variables are to be recorded into the buffer object bound to the next transform feedback binding point （gl_NexBuffer告诉OpenGL后面的数据将绑定到下一个transform feedback buffer）</p>
<p>if rasterization  &amp; fragment shader are enabled, the output variables belonging to stream 0 will be used to form primitives for rasterization and will be passed into the fragment shader. Output variables belonging to other streams will not be visible in the fragment shader and if transform feedback is not active, they will be discarded （这里需要注意，一旦rasterization 和 fragment shader被开启或者transform feedback没有被开启，那么geometry shader里面指定的out变量只有属于stream 0的才会被进行处理，其他都会被抛弃）</p>
<p>Note:<br>When multiple output streams are used in a geometry shader, they must all have points as the primitive type （注意，当multiple output streams被开启时，geometry shader必须指定输出类型为point，当first pass的时候geometry shader指定输出类型为point，second pass的时候geometry shader可以针对第一次transform feedback记录的point数据进行处理输出triangle等）</p>
<p><strong>Primitive Queries</strong><br>Reason:<br>Geometry shader can emit a variable number of vertices per invocation （因为geometry shader会扩展出很多primitive和vertices，我们在访问一些跟transform feedback buffer相关的数据的时候就不那么直接 — 这里要提一下没有geometry shader，vertex shader结合transform feeback buffer的使用是一对一的输出，而geometry shader不一样，会有一堆多的primitive，vertices的输出）</p>
<p>Problem:<br>The number of vertices recorded into transform feedback buffers when a geometry shader is present may not be easy to infer</p>
<p>Solution:<br>Two types of queries are available to count both the number of primitives the geometry shader generates, and the number of primitives actually written into the transform feedback buffers（通过Primitive Queries我们可以得知geometry shader的primitives，vertices生成数量和实际被写入transform feedback buffer的primitive，vertices数量）</p>
<p>GL_PRIMITIVES_GENERATED  — query counts the number of vertices output by the geometry shader – valid at any time<br>&amp;<br>GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN – query counts the number of vertices actually written into a transform feedback buffer – only valid when transform feedback is active</p>
<p>Due to geometry shader supports multiple transform feedback streams, primitive queries are indexed （因为geometry shader支持multiple transform feedback streams，所以primitive queries也是indexed的）</p>
<h3 id="3D_Picking">3D Picking</h3><p>“The ability to match a mouse click on a window showing a 3D scene to the primitive (let’s assume a triangle) who was fortunate enough to be projected to the exact same pixel where the mouse hit is called 3D Picking.”</p>
<p>3D Picking实现的关键在于通过类似Shadow map的方式，把所有的primitive信息写入到一张picking texture里，当mouse点击的时候我们去查询所点击的primitive信息然后把该primitive渲染成我们想要的颜色即可。</p>
<p>实现步骤：<br><strong>First pass(picking pass)</strong> — 利用gDrawIndex, gObjectIndex, Primitive Index生成picking texture<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PickingTexture::Init(<span class="keyword">unsigned</span> <span class="keyword">int</span> WindowWidth, <span class="keyword">unsigned</span> <span class="keyword">int</span> WindowHeight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the FBO</span></span><br><span class="line">    glGenFramebuffers(<span class="number">1</span>, &amp;m_fbo);</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the texture object for the primitive information buffer</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_pickingTexture);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_pickingTexture);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB32F, WindowWidth, WindowHeight,</span><br><span class="line">                <span class="number">0</span>, GL_RGB, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,</span><br><span class="line">                m_pickingTexture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the texture object for the depth buffer</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;m_depthTexture);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_depthTexture);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, WindowWidth, WindowHeight,</span><br><span class="line">                <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,</span><br><span class="line">                m_depthTexture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable reading to avoid problems with older GPUs</span></span><br><span class="line">    glReadBuffer(GL_NONE);</span><br><span class="line"></span><br><span class="line">    glDrawBuffer(GL_COLOR_ATTACHMENT0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that the FBO is correct</span></span><br><span class="line">    GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"FB error, status: 0x%x\n"</span>, Status);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the default framebuffer</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GLCheckError();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PickingTexture::EnableWriting()</span><br><span class="line">&#123;</span><br><span class="line">	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_FBO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过类似生成Shaow map的方式，我们生成一个FRAMEBUFFER m_fbo，然后通过分别attach m_depthTexture和m_pickingTexture到GL_COLOR_ATTACHMENT0和GL_DEPTH_COMPONENT上，紧接着我们通过指定绘制到m_fbo的GL_COLOR_ATTACHMENT0(即我们attach的那个)上，这样一来当我们渲染到m_fbo的时候，attach到GL_COLOR_ATTACHMENT0的那个color texture就会得到渲染的picking texture，最后在我们我们在渲染之前需要指定m_fbo作为渲染到的FRAMEBUFFER。这样一来我们通过Picking Technique就能得到Picking texture。<br>这里也会生成depth texture，但我们并不会用到，指定生成depth texture的原因如下：<br>“By combining a depth buffer in the process we guarantee that when several primitives are overlapping the same pixel we get the index of the top-most primitive (closest to the camera). “（注意我们需要结合depth buffer来保证我们生成的picking texture保存的primitive信息是离摄像机最近的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">picking_technique.cpp</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"picking_technique.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"ogldev_util.h"</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PickingTechnique::SetWVP(<span class="keyword">const</span> Matrix4f&amp; WVP)</span><br><span class="line">&#123;</span><br><span class="line">    glUniformMatrix4fv(m_WVPLocation, <span class="number">1</span>, GL_TRUE, (<span class="keyword">const</span> GLfloat*)WVP.m);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PickingTechnique::DrawStartCB(uint DrawIndex)</span><br><span class="line">&#123;</span><br><span class="line">    glUniform1ui(m_drawIndexLocation, DrawIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PickingTechnique::SetObjectIndex(uint ObjectIndex)</span><br><span class="line">&#123;</span><br><span class="line">    GLExitIfError;</span><br><span class="line">    glUniform1ui(m_objectIndexLocation, ObjectIndex);</span><br><span class="line"><span class="comment">//    GLExitIfError;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">picking.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gWVP;                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;                                       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">picking.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                                                                                                                                                                                        </span><br><span class="line">uniform uint gDrawIndex;                                                            </span><br><span class="line">uniform uint gObjectIndex;                                                          </span><br><span class="line">                                                                                    </span><br><span class="line">out vec3 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">   FragColor = vec3(<span class="keyword">float</span>(gObjectIndex), <span class="keyword">float</span>(gDrawIndex),<span class="keyword">float</span>(gl_PrimitiveID + <span class="number">1</span>));                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解上述代码，我们首先需要看看我们存储在picking texture里的信息组成。<br>从picking.fs中可以看出我们存储在piking texture里的颜色信息主要是由gObjectIndex，gDrawIndex，gl_PrimitiveID组成。<br>当我们去渲染spider mesh的时候，我们通过调用void Mesh::Render(IRenderCallbacks* pRenderCallbacks)传入了实现了DrawStartCB回调方法的类传入了shader里gObjectIndex的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::Render(IRenderCallbacks* pRenderCallbacks)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m_Entries.size() ; i++) &#123;</span><br><span class="line">        glBindBuffer(GL_ARRAY_BUFFER, m_Entries[i].VB);</span><br><span class="line">        .......</span><br><span class="line">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_Entries[i].IB);</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRenderCallbacks) &#123;</span><br><span class="line">            pRenderCallbacks-&gt;DrawStartCB(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GLExitIfError;        </span><br><span class="line">        glDrawElements(GL_TRIANGLES, m_Entries[i].NumIndices, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的是spider mesh count的索引，即gObjectIndex代表mesh count的索引(这里的spider由19个mesh组成，通过open3mod可以查看到)。<br><img src="/img/OpenGL/SpiderMeshTree.PNG" alt="SpiderMeshTree"><br>接下来当我们渲染两个spider的时候，我们把Object index(即这里spider的数量)作为了gDrawIndex传入了shader。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PickingPhase</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    .......</span><br><span class="line"></span><br><span class="line">	gPickingTexture.EnableWriting();</span><br><span class="line"></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	gPickingEffect.Enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span> ; i &lt; (<span class="keyword">int</span>)ARRAY_SIZE_IN_ELEMENTS(gWorldPos) ; i++) &#123;</span><br><span class="line">		p.WorldPos(gWorldPos[i]);</span><br><span class="line">		gPickingEffect.SetObjectIndex(i);</span><br><span class="line">		gPickingEffect.SetWVP(p.GetWVPTrans());    </span><br><span class="line">		gPSpider-&gt;Render(&amp;gPickingEffect);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gPickingTexture.DisableWriting();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后gl_PrimitiveID是OpenGL build-in的变量，”This is a running index of the primitives which is automatically maintained by the system.”(代表我们绘制的primitive索引值，每一次draw都会从0开始。)<br>这里就引出了一个问题。我们如何得知我们渲染到picking texture里的primitive值0是指background还是被object遮挡的primitive了。<br>这也就是为什么我们在写入picking texture的时候，gl_PrimitiveID + 1的原因了。这样一来凡是primitive为0的都是background。<br><img src="/img/OpenGL/PickingTexture.PNG" alt="PickingTexture"></p>
<p><strong>Render pass</strong> — 通过映射mouse click的pixel到picking texture，会得到鼠标点击到的gObjectIndex，gDrawIndex，gl_PrimitiveID信息，然后通过这些信息，我们把该点击的primitive通过simple color shader渲染成红色，然后再正常渲染两个spider即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::Render(<span class="keyword">unsigned</span> <span class="keyword">int</span> DrawIndex, <span class="keyword">unsigned</span> <span class="keyword">int</span> PrimID)</span><br><span class="line">&#123;</span><br><span class="line">    assert(DrawIndex &lt; m_Entries.size());</span><br><span class="line">    </span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Entries[DrawIndex].VB);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_Entries[DrawIndex].IB);</span><br><span class="line"></span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, (<span class="keyword">const</span> GLvoid*)(PrimID * <span class="number">3</span> * <span class="keyword">sizeof</span>(GLuint)));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PickingTexture::PixelInfo PickingTexture::ReadPixel(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	glBindFramebuffer(GL_READ_FRAMEBUFFER, m_FBO);</span><br><span class="line">	glReadBuffer(GL_COLOR_ATTACHMENT0);</span><br><span class="line">	PixelInfo pixel;</span><br><span class="line">	glReadPixels(x, y, <span class="number">1</span>, <span class="number">1</span>, GL_RGB, GL_FLOAT, &amp;pixel);</span><br><span class="line">	glReadBuffer(GL_NONE);</span><br><span class="line"></span><br><span class="line">	glBindFramebuffer(GL_READ_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pixel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderPhase</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    Pipeline p;</span><br><span class="line">    p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    p.SetPerspectiveProj(m_persProjInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the left mouse button is clicked check if it hit a triangle</span></span><br><span class="line">    <span class="comment">// and color it red</span></span><br><span class="line">    <span class="keyword">if</span> (m_leftMouseButton.IsPressed) &#123;</span><br><span class="line">        PickingTexture::PixelInfo Pixel = m_pickingTexture.ReadPixel(m_leftMouseButton.x,</span><br><span class="line">                                                WINDOW_HEIGHT - m_leftMouseButton.y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Pixel.PrimID != <span class="number">0</span>) &#123;</span><br><span class="line">            m_simpleColorEffect.Enable();</span><br><span class="line">            p.WorldPos(m_worldPos[(uint)Pixel.ObjectID]);</span><br><span class="line">            m_simpleColorEffect.SetWVP(p.GetWVPTrans());</span><br><span class="line">            <span class="comment">// Must compensate for the decrement in the FS!</span></span><br><span class="line">            m_pMesh-&gt;Render((uint)Pixel.DrawID, (uint)Pixel.PrimID - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render the objects as usual</span></span><br><span class="line">    m_lightingEffect.Enable();</span><br><span class="line">    m_lightingEffect.SetEyeWorldPos(m_pGameCamera-&gt;GetPos());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_worldPos) ; i++) &#123;</span><br><span class="line">        p.WorldPos(m_worldPos[i]);</span><br><span class="line">        m_lightingEffect.SetWVP(p.GetWVPTrans());</span><br><span class="line">        m_lightingEffect.SetWorldMatrix(p.GetWorldTrans());</span><br><span class="line">        m_pMesh-&gt;Render(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">simple_color.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position;                                             </span><br><span class="line">                                                                                    </span><br><span class="line">uniform mat4 gWVP;                                                                  </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;                                       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">simple_color.fs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line">                                                                                    </span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 FragColor;                                            </span><br><span class="line">                                                                                    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                         </span><br><span class="line"></span>&#123;                                                                                   </span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里去读取picking texture里的信息的时候，要注意的一点是，鼠标获取得到的坐标信息和我们去查询texture的坐标系是不一致的，这里需要转换。<br>一下来源于<a href="https://www.opengl.org/discussion_boards/showthread.php/165951-Glut-Mouse-Coordinates" target="_blank" rel="external">Glut Mouse Coordinates </a><br>“In “window” coordinate, the origin (0,0) is top left of the viewport.In OpenGL the origin is bottom left of the viewport. When you click glut give you the window coordinate. All you have to do is calculate this: y = height_of_viewport - y - 1.</p>
<p>Edit: Notice that you compare a screen coordinate (mouse click) with an object coordinate (your rectangle). This is fine if you use a perspective projection like this glOrtho(0,0,viewport_width,viewport_height). If not you need to call gluProject to map each corner of your rectangle in screen coordinate. “<br>从上面可以看出，glut获取的mouse坐标系是以左上角为(0,0)点。而OpenGL viewport的(0,0)点时左下角，所以我们需要通过下列方式去转换映射点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PickingTexture::PixelInfo Pixel = m_pickingTexture.ReadPixel(m_leftMouseButton.x, WINDOW_HEIGHT - m_leftMouseButton.y - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>在得到正确的映射值后，我们将查询到的gObjectIndex，gDrawIndex，gl_PrimitiveID当做信息传入void Mesh::Render(unsigned int DrawIndex, unsigned int PrimID)去指定渲染特定mesh的特定primitive成红色。这里要注意的一点是因为mesh里的primitive索引是从0开始的，但我们之前存储的primitive index是+1的，所以这里我们需要恢复原有正确的值去指定渲染正确的primitive。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must compensate for the decrement in the FS!</span></span><br><span class="line">m_pMesh-&gt;Render((uint)Pixel.DrawID, (uint)Pixel.PrimID - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里有一个疑问没有想通，写在这里，如果有人知道答案，希望不腻赐教。第一次把特定primitive渲染成红色后再通过正常渲染渲染两个spider，那么按理，那个特定的primitve会被再次绘制渲染（正常渲染的时候），那么深度信息应该是和前一次一致的，为什么最终却显示的红色而不是模型纹理的颜色了？<br><img src="/img/OpenGL/3DPicking.PNG" alt="3DPicking"></p>
<h3 id="Basic_Tessellation">Basic Tessellation</h3><p>The tessellation process doesn’t operate on OpenGL’s classic geometric primitives: points, lines, and triangles, but uses a new primitive called a patch （Tessellation shader就是针对patch来进行处理的而并非点，线，三角形）</p>
<p>Patch is just an ordered list of vertices (在tessellation shader里面比较重要的概念就是这个patch，patch是一系列的顶点，OpenGL规定patch的vertex数量必须至少大于等于3)。这里的Patch我们可以理解为一个包含了几何图形的所有Control Points(CP)的集合。Control Points会决定这个几何图形最终的形态。</p>
<p>让我们来看看Tessellation Shader在OpenGL Pipeline里的执行顺序（<a href="http://ogldev.atspace.co.uk/www/tutorial30/tutorial30.html" target="_blank" rel="external">下图来源</a>）<br><img src="/img/OpenGL/TessellationShaderProcess.PNG" alt="TessellationShaderProcess"></p>
<p>Two Shader Stage, One fixed function:</p>
<ol>
<li><p>Tessellation Control Shader(TCS)<br> “The control shader calculates a set of numbers called Tessellation Levels (TL). The TLs determine the Tessellation level of detail - how many triangles to generate for the patch.”<br>可以看出TCS并不是负责顶点的细分而是负责指定细分的规则(如何细分，细分程度)。</p>
<p> 上述Tessellation Levels(TL)的计算就比较灵活，可以根据摄像机距离也可以根据屏幕最终所在像素多少来决定细分方式。</p>
<p> Note:<br> “It is executed once per CP in the output patch”</p>
</li>
<li><p>Primitive Generator (Fixed function)<br> “OpenGL passes the output of the tessellation control shader to the primitive generator, which generates the mesh of geometric primitives and tessellation coordinates that the tessellation evaluation shader stage uses.”(PG之后会输出domain细分后的顶点和顶点纹理坐标信息，通过顶点纹理信息TES会算出对应的顶点位置信息)</p>
<p> 通过TCS指定的规则去细分。<br> 这里需要理解一个概念 - Domain<br> 细分的规则跟Domain的类型有关<br> 下面我们来看看Quad Domain和Triangle Domain：<br> <img src="/img/OpenGL/Domains.PNG" alt="Domains"></p>
<p> 不同类型的domain — 会决定我们inner和outer的具体含义：<br> Quad Tessellation:<br> ……</p>
<p> Isoline  Tessellation:<br> Use only two of the outer-tessellation levels to determine the amount of subdivision</p>
<p> Triangle Tessellation:<br> Triangular domains use barycentric coordinates to specify their Tessellation coordinates</p>
<p> 从上面可以看出三中不同的Domain有不同的细分规则。<br> 三角形是通过质心去做细分的。<br> 下面来看看三角形细分后的结果：<br> <img src="/img/OpenGL/TriangleDomainSubdivision.PNG" alt="TriangleDomainSubdivision"></p>
</li>
<li><p>Tessellation Evaluation Shader(TES)<br> The TES is executed on all generated domain locations.Positions each of the vertices in the final mesh （TES是针对从tessellation control shader和Primitive Generator通过细分后所有patch相关的顶点来进行运算，通过各顶点的gl_TessCoord(顶点在patch里的相对坐标信息)按不同Domain的纹理坐标计算方式计算出相应的纹理坐标，位置信息和法线信息，从而实现细分多边形和修改顶点信息效果）</p>
<p> 接下来让我们结合事例学习理解：<br> <a href="http://ogldev.atspace.co.uk/www/tutorial30/tutorial30.html" target="_blank" rel="external">Basic Tessellation Tutorial</a><br> 该Tutorial实现下列几个功能：</p>
<ol>
<li>根据quad.obj模型三角形边与camera的距离去决定LOD的细分程度</li>
<li>通过读取高度图去作为对应顶点的高度信息，且实现通过+-控制高度图的所占比例</li>
<li><p>可以通过z键开启wireframe模式查看细分情况</p>
<p> 接下来看看主要的实现步骤：</p>
<ol>
<li><p>加载并设置height map和color map作为高度图和纹理图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">InitializeTesselationInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//加载height map和color map</span></span><br><span class="line">	gPDisplacementMap = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/heightmap.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!gPDisplacementMap-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gPDisplacementMap-&gt;Bind(DISPLACEMENT_TEXTURE_UNIT);</span><br><span class="line"></span><br><span class="line">	glActiveTexture(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">	gPColorMap = <span class="keyword">new</span> Texture(GL_TEXTURE_2D, <span class="string">"../Content/diffuse.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!gPColorMap-&gt;Load())</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gPColorMap-&gt;Bind(COLOR_TEXTURE_UNIT);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">InitializeLight</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置之前加载的height map和color map作为高度图和纹理图</span></span><br><span class="line">	gLightingTechnique.Enable();</span><br><span class="line">	gLightingTechnique.SetDirectionalLight(gDirLight);</span><br><span class="line">	gLightingTechnique.SetColorTextureUnit(COLOR_TEXTURE_UNIT_INDEX);</span><br><span class="line">	gLightingTechnique.SetDisplacementMapTextureUnit(DISPLACEMENT_TEXTURE_UNIT_INDEX);</span><br><span class="line">	gLightingTechnique.SetDispFactor(gDisFactor);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译连接含TCS和TES的Shader</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> LightingTechnique::Init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Technique::Init()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AddShader(GL_VERTEX_SHADER, <span class="string">"lighting.vs"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AddShader(GL_TESS_CONTROL_SHADER, <span class="string">"lighting.cs"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AddShader(GL_TESS_EVALUATION_SHADER, <span class="string">"lighting.es"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AddShader(GL_FRAGMENT_SHADER, <span class="string">"lighting.fs"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!Finalize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以GL_PATCHES方式绘制quad，触发Tessellation Shader</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Mesh::Render(IRenderCallbacks* pRenderCallbacks)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//通过设置绘制类型是GL_PATCHES触发Tessellation Shader</span></span><br><span class="line">    glDrawElements(GL_PATCHES, m_Entries[i].NumIndices, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟VP坐标转换(因为Tessellation Shader会细分出更多的顶点，所以这一步从VS延迟到了TES)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lighting.vs</span><br><span class="line">#version 410 core                                                                                            </span><br><span class="line">layout (location = 0) in vec3 Position_VS_in;                                                   </span><br><span class="line">layout (location = 1) in vec2 TexCoord_VS_in;                                                   </span><br><span class="line">layout (location = 2) in vec3 Normal_VS_in;                                                                                                                                      </span><br><span class="line">uniform mat4 gWorld                                                                        </span><br><span class="line">                                                                                                </span><br><span class="line">out vec3 WorldPos_CS_in;                                                                        </span><br><span class="line">out vec2 TexCoord_CS_in;                                                                        </span><br><span class="line">out vec3 Normal_CS_in;                                              </span><br><span class="line">                                                                                                </span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    //注意这里我们没有像平时一样对世界坐标系下的顶点信息进行观察坐标系和投影转换</span><br><span class="line">	//因为Tessellation Shader会细分出更多的顶点，所以这一步从VS延迟到了TES</span><br><span class="line">    WorldPos_CS_in = (gWorld * vec4(Position_VS_in, 1.0)).xyz;                                  </span><br><span class="line">    TexCoord_CS_in = TexCoord_VS_in;                                                            </span><br><span class="line">    Normal_CS_in   = (gWorld * vec4(Normal_VS_in, 0.0)).xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCS，指定patch顶点数量和细分方式(这里实现了细分程度跟patch各顶点到camera的距离有关)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">lighting.cs</span><br><span class="line"><span class="preprocessor">#version <span class="number">410</span> core                                                </span></span><br><span class="line"><span class="comment">// 指定patch的顶点组成数</span></span><br><span class="line"><span class="comment">// 我们也可以通过在程序里调用glPatchParameteri() -- 告诉程序我们定义多少个顶点为一个patch</span></span><br><span class="line">layout (vertices = <span class="number">3</span>) out;                                                                                         </span><br><span class="line">uniform vec3 gEyeWorldPos;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// attributes of the input CPs                                         </span></span><br><span class="line">in vec3 WorldPos_CS_in[];                                                                       </span><br><span class="line">in vec2 TexCoord_CS_in[];                                                                       </span><br><span class="line">in vec3 Normal_CS_in[];                                          </span><br><span class="line">                                                                                                </span><br><span class="line"><span class="comment">// attributes of the output CPs         </span></span><br><span class="line">out vec3 WorldPos_ES_in[];                                                                      </span><br><span class="line">out vec2 TexCoord_ES_in[];                                                                      </span><br><span class="line">out vec3 Normal_ES_in[];                                                                              </span><br><span class="line"><span class="comment">// 根据patch各顶点到camera的距离决定patch的细分程度                                      </span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetTessLevel</span><span class="params">(<span class="keyword">float</span> Distance0, <span class="keyword">float</span> Distance1)</span></span><br><span class="line"></span>&#123;                                                      </span><br><span class="line">    <span class="keyword">float</span> AvgDistance = (Distance0 + Distance1) / <span class="number">2.0</span>;                                                                                            </span><br><span class="line">    <span class="keyword">if</span> (AvgDistance &lt;= <span class="number">2.0</span>) &#123;                                                                   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">10.0</span>;                                                                            </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (AvgDistance &lt;= <span class="number">5.0</span>) &#123;                                                              </span><br><span class="line">        <span class="keyword">return</span> <span class="number">7.0</span>;                                                                             </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                      </span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.0</span>;                                                                             </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;                                                                                               </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;      </span><br><span class="line">    <span class="comment">// Set the control points of the output patch</span></span><br><span class="line">    <span class="comment">// 记录下patch的control point的原始顶点信息，在TES中会参与就算，算出细分的顶点的位置信息</span></span><br><span class="line">    <span class="comment">// **gl_InvocationID** is used to access the specific vertex of a patch (gl_InvocationID 用于访问传入patch里的特定顶点)</span></span><br><span class="line">    <span class="comment">// 之前我们指定patch的顶点数量是3，TCS是针对patch的顶点来执行的，所以每一个patch会执行3次TCS</span></span><br><span class="line">    TexCoord_ES_in[gl_InvocationID] = TexCoord_CS_in[gl_InvocationID];                          </span><br><span class="line">    Normal_ES_in[gl_InvocationID]   = Normal_CS_in[gl_InvocationID];                            </span><br><span class="line">    WorldPos_ES_in[gl_InvocationID] = WorldPos_CS_in[gl_InvocationID];                          </span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="comment">// Calculate the distance from the camera to the three control points</span></span><br><span class="line">    <span class="comment">// 算出patch各顶点到camera的距离</span></span><br><span class="line">    <span class="keyword">float</span> EyeToVertexDistance0 = distance(gEyeWorldPos, WorldPos_ES_in[<span class="number">0</span>]);                     </span><br><span class="line">    <span class="keyword">float</span> EyeToVertexDistance1 = distance(gEyeWorldPos, WorldPos_ES_in[<span class="number">1</span>]);                     </span><br><span class="line">    <span class="keyword">float</span> EyeToVertexDistance2 = distance(gEyeWorldPos, WorldPos_ES_in[<span class="number">2</span>]);                     </span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="comment">// Calculate the tessellation levels</span></span><br><span class="line">    <span class="comment">// 根据patch各顶点到camera的距离设置细分方式和细分程度</span></span><br><span class="line">    <span class="comment">// **gl_TessLevelInner**</span></span><br><span class="line">    <span class="comment">// Specify how the interior of the domain is subdivided and stored in a two element array named gl_TessLevelInner（指定多边形内部如何细分）</span></span><br><span class="line">    <span class="comment">// **gl_TessLevelOuter**</span></span><br><span class="line">    <span class="comment">// Control how the perimeter of the domain is subdivided, and is stored in an implicitly declared four-element array named gl_TessLevelOuter（指定多边形边界上的边被如何细分）</span></span><br><span class="line">    <span class="comment">// gl_TessLevelInner &amp; gl_TessLevelOuter 根据Domain的类型不同会有不同的含义，参见前面提到的Domain</span></span><br><span class="line">    <span class="comment">// 我们也可以在程序里通过调用glPatchParameterfv()指定inner和outer的数值</span></span><br><span class="line">    gl_TessLevelOuter[<span class="number">0</span>] = GetTessLevel(EyeToVertexDistance1, EyeToVertexDistance2);            </span><br><span class="line">    gl_TessLevelOuter[<span class="number">1</span>] = GetTessLevel(EyeToVertexDistance2, EyeToVertexDistance0);            </span><br><span class="line">    gl_TessLevelOuter[<span class="number">2</span>] = GetTessLevel(EyeToVertexDistance0, EyeToVertexDistance1);            </span><br><span class="line">    gl_TessLevelInner[<span class="number">0</span>] = gl_TessLevelOuter[<span class="number">2</span>];                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TES，利用细分出的所有相关patch顶点的gl_TessCoord(顶点在patch里的相对位置信息)，算出各顶点的纹理坐标信息，位置信息，法线信息(这里通过读取高度图的值参与顶点的高度计算实现动态控制高度值运算)，然后转换所有patch相关的顶点位置信息到投影坐标系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">lighting.es</span><br><span class="line"><span class="preprocessor">#version <span class="number">410</span> core                                                                               </span></span><br><span class="line"><span class="comment">// layout (quads, equal_spacing, ccw) in; （指定新生成的多边形类型等相关信息）</span></span><br><span class="line">layout(triangles, equal_spacing, ccw) in;                                                       </span><br><span class="line">                                                                                                </span><br><span class="line">uniform mat4 gVP;                                                                               </span><br><span class="line">uniform sampler2D gDisplacementMap;                                                             </span><br><span class="line">uniform <span class="keyword">float</span> gDispFactor;                                                                      </span><br><span class="line">                                                                                                </span><br><span class="line">in vec3 WorldPos_ES_in[];                                                                       </span><br><span class="line">in vec2 TexCoord_ES_in[];                                                                       </span><br><span class="line">in vec3 Normal_ES_in[];                                                                         </span><br><span class="line">                                                                                                </span><br><span class="line">out vec3 WorldPos_FS_in;                                                                        </span><br><span class="line">out vec2 TexCoord_FS_in;                                                                        </span><br><span class="line">out vec3 Normal_FS_in;                                                                          </span><br><span class="line">                                                                                                </span><br><span class="line"><span class="function">vec2 <span class="title">interpolate2D</span><span class="params">(vec2 v0, vec2 v1, vec2 v2)</span>                                                   </span><br><span class="line"></span>&#123;                                                                                               </span><br><span class="line">    <span class="keyword">return</span> vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;   </span><br><span class="line">&#125;                                                                                               </span><br><span class="line">                                                                                                </span><br><span class="line"><span class="function">vec3 <span class="title">interpolate3D</span><span class="params">(vec3 v0, vec3 v1, vec3 v2)</span>                                                   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="comment">// 因为前面我们指定了生成的多边形类型是triangle，所以这里按照triangle domian的计算方式去计算位置信息</span></span><br><span class="line">    <span class="comment">// **gl_TessCoord**包含了当前顶点的在patch里的坐标信息</span></span><br><span class="line">    <span class="keyword">return</span> vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;   </span><br><span class="line">&#125;                                                                                               </span><br><span class="line">                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                                     </span><br><span class="line"></span>&#123;                                                                                               </span><br><span class="line">    <span class="comment">// Interpolate the attributes of the output vertex using the barycentric coordinates</span></span><br><span class="line">    <span class="comment">// 通过细分后得到的各patch顶点的相对坐标信息gl_TessCoord，用对应Domain的计算方式算出各顶点的位置，法线，纹理信息        </span></span><br><span class="line">    TexCoord_FS_in = interpolate2D(TexCoord_ES_in[<span class="number">0</span>], TexCoord_ES_in[<span class="number">1</span>], TexCoord_ES_in[<span class="number">2</span>]);    </span><br><span class="line">    Normal_FS_in = interpolate3D(Normal_ES_in[<span class="number">0</span>], Normal_ES_in[<span class="number">1</span>], Normal_ES_in[<span class="number">2</span>]);            </span><br><span class="line">    Normal_FS_in = normalize(Normal_FS_in);                                                     </span><br><span class="line">    WorldPos_FS_in = interpolate3D(WorldPos_ES_in[<span class="number">0</span>], WorldPos_ES_in[<span class="number">1</span>], WorldPos_ES_in[<span class="number">2</span>]);    </span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="comment">// Displace the vertex along the normal</span></span><br><span class="line">    <span class="comment">// 这里主要是读取之前加载的高度图信息，通过顶点法线方向运算作用于顶点位置信息，实现动态控制顶点高度信息                                  </span></span><br><span class="line">    <span class="keyword">float</span> Displacement = texture(gDisplacementMap, TexCoord_FS_in.xy).x;                        </span><br><span class="line">    WorldPos_FS_in += Normal_FS_in * Displacement * gDispFactor;                                </span><br><span class="line">    <span class="comment">// 最后针对所有的顶点做观察坐标系投影和透视投影，使其正确映射到屏幕位置</span></span><br><span class="line">    gl_Position = <span class="function">gVP * <span class="title">vec4</span><span class="params">(WorldPos_FS_in, <span class="number">1.0</span>)</span></span>;                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储所有细分的顶点位置信息(世界坐标系),顶点法线信息(世界坐标系)和顶点纹理坐标信息参与正常的光照计算得出最后的纹理颜色</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#version <span class="number">410</span> core                                                                           </span></span><br><span class="line">                                                                                            </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_POINT_LIGHTS = <span class="number">2</span>;                                                             </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SPOT_LIGHTS = <span class="number">2</span>;                                                              </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是在TES中存储下来的位于世界坐标系的顶点位置信息和顶点法线信息                          </span></span><br><span class="line">in vec2 TexCoord_FS_in;                                                                     </span><br><span class="line">in vec3 Normal_FS_in;                                                                       </span><br><span class="line">in vec3 WorldPos_FS_in;                                                                     </span><br><span class="line">                                                                                            </span><br><span class="line">out vec4 FragColor;</span><br><span class="line">......                                                                                  </span><br><span class="line">                                                                                            </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                                                                 </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="comment">// 用位于世界坐标系的顶点位置信息和法线信息参与光照运算，得出最后的纹理颜色信息             </span></span><br><span class="line">    vec3 Normal = normalize(Normal_FS_in);                                                  </span><br><span class="line">    vec4 TotalLight = CalcDirectionalLight(Normal);                                         </span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gNumPointLights ; i++) &#123;                                           </span><br><span class="line">        TotalLight += CalcPointLight(gPointLights[i], Normal);                              </span><br><span class="line">    &#125;                                                                                       </span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gNumSpotLights ; i++) &#123;                                            </span><br><span class="line">        TotalLight += CalcSpotLight(gSpotLights[i], Normal);                                </span><br><span class="line">    &#125;                                                                                       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里读取的是我们之前加载的color map</span></span><br><span class="line">    FragColor = texture(gColorMap, TexCoord_FS_in.xy) * TotalLight;                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关控制(高度图对顶点位置生成的控制，wireframe控制)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">KeyboardCB</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">			glutLeaveMainLoop();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> OGLDEV_KEY_PLUS:</span><br><span class="line">			gDisFactor += <span class="number">0.01f</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OGLDEV_KEY_MINUS:</span><br><span class="line">			<span class="keyword">if</span> (gDisFactor &gt;= <span class="number">0.01f</span>) &#123;</span><br><span class="line">				gDisFactor -= <span class="number">0.01f</span>;                    </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">'z'</span>:</span><br><span class="line">			gIsWireFrame = !gIsWireFrame;</span><br><span class="line">            <span class="comment">// 这里是wireframe的开关控制</span></span><br><span class="line">			<span class="keyword">if</span> (gIsWireFrame) &#123;</span><br><span class="line">				glPolygonMode(GL_FRONT, GL_LINE);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				glPolygonMode(GL_FRONT, GL_FILL);</span><br><span class="line">			&#125;  </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 这里就是我们动态控制高度图对生成顶点的位置信息的影响参数的传递</span></span><br><span class="line">    <span class="comment">// 具体运算参见lighting.es</span></span><br><span class="line">    <span class="comment">// WorldPos_FS_in += Normal_FS_in * Displacement * gDispFactor;   </span></span><br><span class="line">	gLightingTechnique.SetDispFactor(gDisFactor);</span><br><span class="line"></span><br><span class="line">	gQuad-&gt;Render(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Final Effect:<br><img src="/img/OpenGL/TessellationFill.PNG" alt="TessellationFill"><br><img src="/img/OpenGL/TessellationClose.PNG" alt="TessellationClose"><br><img src="/img/OpenGL/TessellationFar.PNG" alt="TessellationFar"><br><img src="/img/OpenGL/TessellationHeightMap.PNG" alt="TessellationHeightMap"></p>
<p>总结：<br>tessellation shader是可选的shader，不是必须的</p>
<p>tessellation shader与vertex shader不一样，tessellation shader是针对patch（一系列顶点）来处理而不是一个顶点 （因为tessellation shader需要通过传入的patch（一系列顶点）来生成新顶点的位置信息）</p>
<p>tessellation control shader负责对patch的细分设定(通过指定细分的计算方式可以实现LOD（level of detail — 根据与camera的距离不同而细分程度不同）等效果)</p>
<p>primitive generator负责对domian的细分</p>
<p>tessellation evaluation shader负责通过PG细分出来的顶点在patch里的坐标信息去计算顶点位置，纹理，法线信息</p>
<p>Bezier曲线在这里是一种细分后位置的计算方法来实现曲面的平滑效果</p>
<p>还有一个应用叫displacement mapping，在tessellation evaluation shader里面通过tessellation coordinate的值来映射纹理（sample a texture）</p>
<p>关于Bezier曲线学习，参考<a href="http://ogldev.atspace.co.uk/www/tutorial31/tutorial31.html" target="_blank" rel="external">PN Triangles Tessellation </a></p>
<h3 id="Vertex_Array_Objects">Vertex Array Objects</h3><p>“The Vertex Array Object (a.k.a VAO) is a special type of object that encapsulates all the data that is associated with the vertex processor. Instead of containing the actual data, it holds references to the vertex buffers, the index buffer and the layout specification of the vertex itself.”</p>
<p>“VAOs store all of the links between the attributes and your VBOs with raw vertex data.”</p>
<p>从上面的定义来看，可以看出，Vertex Array Object(VAO) 主要是用于存储关联的顶点buffer索引，顶点buffer定义的数据访问格式等信息而非真正的顶点数据。当我们需要去绘制某个特定的顶点buffer的时候，我们只需要指定好该顶点buffer的数据访问格式和数据内容，然后绑定到特定的VAO，最后激活该VAO并进行会绘制即可。</p>
<p>让我们来看看两种存储数据的格式AOS(Array Of Structure)，SOA(Structure Of Arrays)：<br><img src="/img/OpenGL/AOSAndSOA.PNG" alt="AOSAndSOA"></p>
<p>事例是采取了SOA的形式存储数据。</p>
<ol>
<li><p>在定义VBO之前，我们需要生成VAO，并绑定到该VAO上（这样一来后续的VBO操作都会绑定到该VAO上被记录下来(比如顶点buffer索引，buffer数据的访问方式等)）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> INDEX_BUFFER <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> POS_VB <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NORMAL_VB <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TEXCOORD_VB <span class="number">3</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BasicMesh::LoadMesh(<span class="keyword">const</span> <span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Release the previously loaded mesh (if it exists)</span></span><br><span class="line">    Clear();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create the VAO</span></span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;m_VAO);   </span><br><span class="line">    glBindVertexArray(m_VAO);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create the buffers for the vertices attributes</span></span><br><span class="line">    glGenBuffers(ARRAY_SIZE_IN_ELEMENTS(m_Buffers), m_Buffers);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the VAO is not changed from the outside</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>采取SOA的方式存储顶点相关数据(下面定义了4个vector用于存储Positions,Normals,TexCoords,Indices)，并绑定到Array Buffer，指明访问方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BasicMesh::InitFromScene(<span class="keyword">const</span> aiScene* pScene, <span class="keyword">const</span> <span class="built_in">string</span>&amp; Filename)</span><br><span class="line">&#123;  </span><br><span class="line">    m_Entries.resize(pScene-&gt;mNumMeshes);</span><br><span class="line">    m_Textures.resize(pScene-&gt;mNumMaterials);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector3f&gt; Positions;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector3f&gt; Normals;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector2f&gt; TexCoords;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; Indices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> NumVertices = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> NumIndices = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Count the number of vertices and indices</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m_Entries.size() ; i++) &#123;</span><br><span class="line">        m_Entries[i].MaterialIndex = pScene-&gt;mMeshes[i]-&gt;mMaterialIndex;        </span><br><span class="line">        m_Entries[i].NumIndices = pScene-&gt;mMeshes[i]-&gt;mNumFaces * <span class="number">3</span>;</span><br><span class="line">        m_Entries[i].BaseVertex = NumVertices;</span><br><span class="line">        m_Entries[i].BaseIndex = NumIndices;</span><br><span class="line">        </span><br><span class="line">        NumVertices += pScene-&gt;mMeshes[i]-&gt;mNumVertices;</span><br><span class="line">        NumIndices  += m_Entries[i].NumIndices;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Reserve space in the vectors for the vertex attributes and indices</span></span><br><span class="line">    Positions.reserve(NumVertices);</span><br><span class="line">    Normals.reserve(NumVertices);</span><br><span class="line">    TexCoords.reserve(NumVertices);</span><br><span class="line">    Indices.reserve(NumIndices);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the meshes in the scene one by one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m_Entries.size() ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> aiMesh* paiMesh = pScene-&gt;mMeshes[i];</span><br><span class="line">        InitMesh(paiMesh, Positions, Normals, TexCoords, Indices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!InitMaterials(pScene, Filename)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate and populate the buffers with vertex attributes and the indices</span></span><br><span class="line">    <span class="comment">// 下面就是存储成SOA的格式</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[POS_VB]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Positions[<span class="number">0</span>]) * Positions.size(), &amp;Positions[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glEnableVertexAttribArray(POSITION_LOCATION);</span><br><span class="line">    glVertexAttribPointer(POSITION_LOCATION, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);    </span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[TEXCOORD_VB]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(TexCoords[<span class="number">0</span>]) * TexCoords.size(), &amp;TexCoords[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glEnableVertexAttribArray(TEX_COORD_LOCATION);</span><br><span class="line">    glVertexAttribPointer(TEX_COORD_LOCATION, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[NORMAL_VB]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Normals[<span class="number">0</span>]) * Normals.size(), &amp;Normals[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glEnableVertexAttribArray(NORMAL_LOCATION);</span><br><span class="line">    glVertexAttribPointer(NORMAL_LOCATION, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_Buffers[INDEX_BUFFER]);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(Indices[<span class="number">0</span>]) * Indices.size(), &amp;Indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GLCheckError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BasicMesh::InitMesh(<span class="keyword">const</span> aiMesh* paiMesh,</span><br><span class="line">                    <span class="built_in">vector</span>&lt;Vector3f&gt;&amp; Positions,</span><br><span class="line">                    <span class="built_in">vector</span>&lt;Vector3f&gt;&amp; Normals,</span><br><span class="line">                    <span class="built_in">vector</span>&lt;Vector2f&gt;&amp; TexCoords,</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;&amp; Indices)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> aiVector3D <span class="title">Zero3D</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Populate the vertex attribute vectors</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; paiMesh-&gt;mNumVertices ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> aiVector3D* pPos      = &amp;(paiMesh-&gt;mVertices[i]);</span><br><span class="line">        <span class="keyword">const</span> aiVector3D* pNormal   = &amp;(paiMesh-&gt;mNormals[i]);</span><br><span class="line">        <span class="keyword">const</span> aiVector3D* pTexCoord = paiMesh-&gt;HasTextureCoords(<span class="number">0</span>) ? &amp;(paiMesh-&gt;mTextureCoords[<span class="number">0</span>][i]) : &amp;Zero3D;</span><br><span class="line"></span><br><span class="line">        Positions.push_back(Vector3f(pPos-&gt;x, pPos-&gt;y, pPos-&gt;z));</span><br><span class="line">        Normals.push_back(Vector3f(pNormal-&gt;x, pNormal-&gt;y, pNormal-&gt;z));</span><br><span class="line">        TexCoords.push_back(Vector2f(pTexCoord-&gt;x, pTexCoord-&gt;y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Populate the index buffer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; paiMesh-&gt;mNumFaces ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> aiFace&amp; Face = paiMesh-&gt;mFaces[i];</span><br><span class="line">        assert(Face.mNumIndices == <span class="number">3</span>);</span><br><span class="line">        Indices.push_back(Face.mIndices[<span class="number">0</span>]);</span><br><span class="line">        Indices.push_back(Face.mIndices[<span class="number">1</span>]);</span><br><span class="line">        Indices.push_back(Face.mIndices[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后绘制的时候，调用glBindVertexArray绑定到特定VAO上，然后调用glDrawElementsBaseVertex指明如何利用VAO绑定的buffer去绘制即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BasicMesh::Render()</span><br><span class="line">&#123;</span><br><span class="line">    glBindVertexArray(m_VAO);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m_Entries.size() ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> MaterialIndex = m_Entries[i].MaterialIndex;</span><br><span class="line"></span><br><span class="line">        assert(MaterialIndex &lt; m_Textures.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_Textures[MaterialIndex]) &#123;</span><br><span class="line">            m_Textures[MaterialIndex]-&gt;Bind(COLOR_TEXTURE_UNIT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里绘制的参数需要理解一下</span></span><br><span class="line">        <span class="comment">/* </span><br><span class="line">           // Count the number of vertices and indices</span><br><span class="line">           for (unsigned int i = 0 ; i &lt; m_Entries.size() ; i++) &#123;</span><br><span class="line">               m_Entries[i].MaterialIndex = pScene-&gt;mMeshes[i]-&gt;mMaterialIndex;        </span><br><span class="line">               m_Entries[i].NumIndices = pScene-&gt;mMeshes[i]-&gt;mNumFaces * 3;</span><br><span class="line">               m_Entries[i].BaseVertex = NumVertices;</span><br><span class="line">               m_Entries[i].BaseIndex = NumIndices;</span><br><span class="line">        </span><br><span class="line">               NumVertices += pScene-&gt;mMeshes[i]-&gt;mNumVertices;</span><br><span class="line">               NumIndices  += m_Entries[i].NumIndices;</span><br><span class="line">           &#125;</span><br><span class="line">        */</span></span><br><span class="line">        <span class="comment">// 因为我们在array buffer里存储数据是采用了SOA的格式，所以在调用glDrawElementsBaseVertex的时候，我们需要指明正确的indices和basevertex索引才能正确绘制</span></span><br><span class="line">        <span class="comment">// 在前面的代码我们m_Entries[i].BaseIndex记录下了到该Entries时所有Indices累加数量，</span></span><br><span class="line">        <span class="comment">// 这里因为Assimp提供的indice索引是从0开始的，但我们存储了所有Entries的indices到index buffer里，</span></span><br><span class="line">        <span class="comment">// 所以我们需要存储的是绘制该Entries时所累加的indices值作为正确索引</span></span><br><span class="line">        <span class="comment">// m_Entries[i].BaseVertex记录下了到该Entries时所有已绘制的顶点累加的数量，</span></span><br><span class="line">        <span class="comment">// 这里同理，为了找到正确的base index，我们需要指明累加后的顶点数量作为offset</span></span><br><span class="line">        <span class="comment">// 调用glDrawElementsBaseVertex绘制每一个Entries时，我们需要指明正确的indices索引才能正确绘制</span></span><br><span class="line">        glDrawElementsBaseVertex(GL_TRIANGLES, </span><br><span class="line">                         m_Entries[i].NumIndices, </span><br><span class="line">                         GL_UNSIGNED_INT, </span><br><span class="line">                         (<span class="keyword">void</span>*)(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * m_Entries[i].BaseIndex), </span><br><span class="line">                         m_Entries[i].BaseVertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the VAO is not changed from the outside    </span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Final Effect(由于第三个模型数据加载出了问题，这里只加载显示了两个):<br><img src="/img/OpenGL/VAOFinalEffect.PNG" alt="VAOFinalEffect"></p>
<p>更多学习参考<a href="https://open.gl/drawing" target="_blank" rel="external">Drawing polygons</a> &amp; <a href="http://blog.sina.com.cn/s/blog_8c7d49f20102uytr.html" target="_blank" rel="external">OpenGL-Draw-Call-Code-Study-Analysis</a></p>
<h3 id="Instanced_Rendering">Instanced Rendering</h3><p>“Instanced rendering means that we can render multiple instances in a single draw call and provide each instance with some unique attributes.”(在一次draw call里绘制多个同一个instance)</p>
<p>Using the Instance Counter in Shaders:<br>The index of the current instance is available to the vertex shader in the built-in variable gl_InstanceID. This variable is implicitly declared as an integer. It starts counting from zero and counts up one each time an instance is rendered.</p>
<p>Instancing Redux:<br>Steps:</p>
<ol>
<li>Create some vertex shader inputs that you intend to be instanced</li>
<li>Set the vertex attribute divisors with glVertexAttribDivisor()</li>
<li>Use the gl_InstanceID built-in variable in the vertex shader</li>
<li>Use the instanced versions of the rendering functions such as glDrawArraysInstanced() ……<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#define WVP_LOCATION 3</span><br><span class="line">#define WORLD_LOCATION 7</span><br><span class="line"></span><br><span class="line">bool Mesh::InitFromScene(const aiScene* pScene, const string&amp; Filename)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[WVP_MAT_VB]);</span><br><span class="line"></span><br><span class="line">    for (unsigned int i = 0; i &lt; 4 ; i++) &#123;</span><br><span class="line">        glEnableVertexAttribArray(WVP_LOCATION + i);</span><br><span class="line">        // Note: "A vertex attribute can contain no more than 4 floating points or integers."</span><br><span class="line">        // 因为vertex attribute不能超过4个float或integers，所以我们需要针对mat4每一行进行指定访问方式</span><br><span class="line">        glVertexAttribPointer(WVP_LOCATION + i, 4, GL_FLOAT, GL_FALSE, sizeof(Matrix4f),</span><br><span class="line">                                (const GLvoid*)(sizeof(GLfloat) * i * 4));</span><br><span class="line">        // 这里是"makes this an instance data rather than vertex data."</span><br><span class="line">        // 第一个参数指明特定attribute是instance data而非vertex data,</span><br><span class="line">        // 第二个参数指明instance data的使用频率，比如1表示每一个instance渲染后就访问下一个atrribute值，2表示每两个</span><br><span class="line">        glVertexAttribDivisor(WVP_LOCATION + i, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[WORLD_MAT_VB]);</span><br><span class="line"></span><br><span class="line">    for (unsigned int i = 0; i &lt; 4 ; i++) &#123;</span><br><span class="line">        glEnableVertexAttribArray(WORLD_LOCATION + i);</span><br><span class="line">        glVertexAttribPointer(WORLD_LOCATION + i, 4, GL_FLOAT, GL_FALSE, sizeof(Matrix4f),</span><br><span class="line">                                (const GLvoid*)(sizeof(GLfloat) * i * 4));</span><br><span class="line">        glVertexAttribDivisor(WORLD_LOCATION + i, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return GLCheckError();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void Mesh::Render(unsigned int NumInstances, const Matrix4f* WVPMats, const Matrix4f* WorldMats)</span><br><span class="line">&#123;</span><br><span class="line">	// 传递instance data的动态数据</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[WVP_MAT_VB]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Matrix4f) * NumInstances, WVPMats, GL_DYNAMIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, m_Buffers[WORLD_MAT_VB]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Matrix4f) * NumInstances, WorldMats, GL_DYNAMIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(m_VAO);</span><br><span class="line"></span><br><span class="line">    for (unsigned int i = 0 ; i &lt; m_Entries.size() ; i++) &#123;</span><br><span class="line">        const unsigned int MaterialIndex = m_Entries[i].MaterialIndex;</span><br><span class="line"></span><br><span class="line">        assert(MaterialIndex &lt; m_Textures.size());</span><br><span class="line"></span><br><span class="line">        if (m_Textures[MaterialIndex]) &#123;</span><br><span class="line">            m_Textures[MaterialIndex]-&gt;Bind(GL_TEXTURE0);</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用glDrawElementsInstanceBaseVertex来渲染多个instance</span><br><span class="line">        glDrawElementsInstancedBaseVertex(GL_TRIANGLES,</span><br><span class="line">                                         m_Entries[i].NumIndices,</span><br><span class="line">                                         GL_UNSIGNED_INT,</span><br><span class="line">                                         (void*)(sizeof(unsigned int) * m_Entries[i].BaseIndex),</span><br><span class="line">                                         NumInstances,</span><br><span class="line">                                         m_Entries[i].BaseVertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure the VAO is not changed from the outside</span><br><span class="line">    glBindVertexArray(0);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    virtual void RenderSceneCB()</span><br><span class="line">    &#123;   </span><br><span class="line">        .......    </span><br><span class="line"></span><br><span class="line">        Matrix4f WVPMatrics[NUM_INSTANCES];</span><br><span class="line">        Matrix4f WorldMatrices[NUM_INSTANCES];</span><br><span class="line">        </span><br><span class="line">        for (unsigned int i = 0 ; i &lt; NUM_INSTANCES ; i++) &#123;</span><br><span class="line">            Vector3f Pos(m_positions[i]);</span><br><span class="line">            Pos.y += sinf(m_scale) * m_velocity[i];</span><br><span class="line">            p.WorldPos(Pos);</span><br><span class="line">            // 这里需要注意，这里之所以要转置之后再传递的原因如下：</span><br><span class="line">            // 在Shader里定义mat4时，OpenGL传递mat4时会以去构造列向量为主的mat4</span><br><span class="line">            // 即把传递的mat4的行作为列去构造mat4</span><br><span class="line">            // 因为我们这里定义的mat4本来就是基于OpenGL的列向量构造的，</span><br><span class="line">            // 所以在传递过去的时候为了保证正确，我们需要先进行转置      </span><br><span class="line">            // 如果我们的mat4本来就是基于DX的列向量，那么就不需要转置</span><br><span class="line">            WVPMatrics[i] = p.GetWVPTrans().Transpose();</span><br><span class="line">            WorldMatrices[i] = p.GetWorldTrans().Transpose();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_pMesh-&gt;Render(NUM_INSTANCES, WVPMatrics, WorldMatrices);</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">lighting.vs</span><br><span class="line">#version 330                                                                        </span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = 0) in vec3 Position;                                             </span><br><span class="line">layout (location = 1) in vec2 TexCoord;                                             </span><br><span class="line">layout (location = 2) in vec3 Normal;</span><br><span class="line">// 这里注意因为vertex attribute不能超过4个float或integers，我们前面指定了每一个mat4四次vertex attribute</span><br><span class="line">// 所以这里WVP location = 3 而 World location = 7</span><br><span class="line">layout (location = 3) in mat4 WVP;                                                  </span><br><span class="line">layout (location = 7) in mat4 World;                                                </span><br><span class="line">                                                                                    </span><br><span class="line">out vec2 TexCoord0;                                                                 </span><br><span class="line">out vec3 Normal0;                                                                   </span><br><span class="line">out vec3 WorldPos0;</span><br><span class="line">// "Since integers cannot be interpolated by the rasterizer we have to mark the output variable as 'flat' (forgetting to do that will trigger a compiler error)."</span><br><span class="line">// 因为integers不能被rasterizer interpolated，所以我们需要使用'flat'关键词避免编译错误</span><br><span class="line">flat out int InstanceID;                                                            </span><br><span class="line">                                                                                    </span><br><span class="line">void main()                                                                         </span><br><span class="line">&#123;                                                                                   </span><br><span class="line">    gl_Position = WVP * vec4(Position, 1.0);                                        </span><br><span class="line">    TexCoord0   = TexCoord;                                                         </span><br><span class="line">    Normal0     = (World * vec4(Normal, 0.0)).xyz;                                  </span><br><span class="line">    WorldPos0   = (World * vec4(Position, 1.0)).xyz;                                </span><br><span class="line">    InstanceID = gl_InstanceID;                                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Final Effect:<br><img src="/img/OpenGL/InstancedRendering.PNG" alt="InstancedRendering"></p>
<p>Note:<br>gl_InstanceID is always present in the vertex shader, even when the current drawing command is not one of the instanced ones.</p>
<h3 id="GLFX_-_An_OpenGL_Effect_Library">GLFX - An OpenGL Effect Library</h3><p>首先让我们了解一下，什么是Effect file？<br>“An effect is a text file that can potentially contain multiple shaders and functions and makes it easy to combine them together into programs. This overcomes the limitation of the glShaderSource() function that requires you to specify the text of a single shader stage.”<br>可以看出，通过effect file，我们可以把所有shader写到一个文件里，不用再创建针对各个stage的shader的文件。这样一来我们在shader里定义的结构体就能在多个shader共用。</p>
<p>那什么是GLFX了？<br>“Effects system for OpenGL and OpenGL ES”<br>GLFX提供了方便的接口去转换effect file到GLSL program.</p>
<p><a href="https://github.com/maizensh/glfx" target="_blank" rel="external">GLFX源码下载地址</a></p>
<p>接下来让我们看看，如何使用GLFX支持effect file。</p>
<ol>
<li>编译生成并添加glfx.lib到引用</li>
<li><p>包含glfx.h头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;glfx.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解析effect file</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!glfxParseEffectFromFile(effect, <span class="string">"effect.glsl"</span>)) &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">// C++ error handling</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">log</span> = glfxGetEffectLog(effect);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error parsing effect: "</span> &lt;&lt; <span class="built_in">log</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span> <span class="comment">// C error handling</span></span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">log</span>[<span class="number">10000</span>];</span><br><span class="line">    glfxGetEffectLog(effect, <span class="built_in">log</span>, <span class="keyword">sizeof</span>(<span class="built_in">log</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error parsing effect: %s:\n"</span>, <span class="built_in">log</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译并启用Effect program</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shaderProg = glfxCompileProgram(effect, <span class="string">"ProgramName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shaderProg &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// same error handling as above</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">glUseProgram(shaderProg);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Release effect file after we no longer use it</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfxDeleteEffect(effect);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来看看编写Effect file有哪些不同于GLSL Shader的地方</p>
<ol>
<li><p>使用’program’ key word去定义一个program，并在其中包含各Shader的调用路口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">program Lighting</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//VSmain() 和 FSmain()分别定义了vs和fs的人口函数</span></span><br><span class="line">    vs(<span class="number">410</span>)=VSmain();</span><br><span class="line">    fs(<span class="number">410</span>)=FSmain();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用’shader’ key word去定义各shader stage的函数入口而非void</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shader <span class="title">VSmain</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    calculate_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以定义多个program在Effect file中，只需通过glfxCompileProgram()去指定编译特定program即可</p>
</li>
<li><p>因为所有shader内容都写在一个文件里了，所以支持共用struct定义，不用再定义一个个in or out variables</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> VSoutput</span><br><span class="line">&#123;</span><br><span class="line">    vec2 TexCoord;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shader <span class="title">VSmain</span><span class="params">(in vec3 Pos, in vec2 TexCoord, in vec3 Normal, out VSOutput VSout)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// do some transformations and update 'VSout'</span></span><br><span class="line">    VSout.TexCoord = TexCoord;</span><br><span class="line">    VSout.Normal = Normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shader <span class="title">FSmain</span><span class="params">(in VSOutput FSin, out vec4 FragColor)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 'FSin' matches 'VSout' from the VS. Use it</span></span><br><span class="line">    <span class="comment">// to do lighting calculations and write the final output to 'FragColor'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在Effect file里直接包含其他Effect file(但新包含的文件并不参与GLFX Parse，并且该文件是以直接插入的形式，所以该文件只能包含pure GLSL不能包含GLFX里的一些定义方式)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"another_effect.glsl"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过:后缀，快速定义attribute的位置而不是通过一个个layout(location=……)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> VSInput2</span><br><span class="line">&#123;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec3 Tangent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shader <span class="title">VSmain</span><span class="params">(in vec3 Pos : <span class="number">5</span>, in vec2 TexCoord : <span class="number">6</span>, in <span class="keyword">float</span> colorScale : <span class="number">10</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些关键词如’flat’，‘noperspective’修饰的变量不能放在Effect file定义的struct里，只能通过interface去定义，而interface又必须通过再次拷贝内容到struct才能在Effect里使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">be passed between shader stages. If you need to pass it as a whole to another function you will need to copy the contents to a <span class="keyword">struct</span>. For example:</span><br><span class="line">interface foo</span><br><span class="line">&#123;</span><br><span class="line">    flat <span class="keyword">int</span> a;</span><br><span class="line">    noperspective <span class="keyword">float</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shader <span class="title">VSmain</span><span class="params">(out foo f)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calc</span><span class="params">(bar c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shader <span class="title">FSmain</span><span class="params">(in foo f)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> bar c;</span><br><span class="line">    c.a = f.a;</span><br><span class="line">    c.b = f.b;</span><br><span class="line"></span><br><span class="line">    Calc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>glfxc工具，可以用于外部单独解析编译Effect file，提前查看是否有问题(这个本人没有试，因为我没有编译出glfxc。)<br>glfxc <effect file="" name=""> <program name=""> </program></effect></p>
</li>
</ol>
<p>Final Effect:<br><img src="/img/OpenGL/GLFX.PNG" alt="GLFX"></p>
<p>Note:<br>“GLFX is dependant on GLEW(注意GLFX是依赖于GLEW的，编译GLFX的时候会需要指定GLEW的路径)”</p>
<h3 id="Deferred_Shading">Deferred Shading</h3><p>在了解什么是Deferred Shading之前，我们需要了解与之对应的Forward Rendering。<br>What is forward rendering?<br>Forward Rendering就是我们之前一直采用的，给GPU传入geometry，texture数据，然后每一个vertex通过pipeline(VS,GS,FS……)得出最后的render target显示在screen上。<br><a href="http://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342" target="_blank" rel="external">下图来源</a><br><img src="/img/OpenGL/ForwardRendering.PNG" alt="ForwardRendering"></p>
<p>既然有了Forward Rendering，为什么我们还需要Deferred Shading了？</p>
<ol>
<li><p><a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html" target="_blank" rel="external">Since each pixel of every object gets only a single FS invocation we have to provide the FS with information on all light sources and take all of them into account when calculating the light effect per pixel. This is a simple approach but it has its downsides. If the scene is highly complex (as is the case in most modern games) with many objects and a large depth complexity (same screen pixel covered by several objects) we get a lot of wasted GPU cycles. </a>(第一个问题大量无用的光照计算。简单的说就是传统的Forward Rendering是针对每一个传入的顶点都会经历一套完整的Pipeline(包含参与光照计算)。但在大型游戏里，会有很多物体(顶点数据)，但最终只有离camera最近或者透明的一部分物体会显示在屏幕上，这样一来，针对每一个顶点都计算光照就会做很多无用功。)</p>
</li>
<li><p><a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html" target="_blank" rel="external">When there are many light sources, forward rendering simply doesn’t scale well with many light sources.</a>(因为Forward Redenring每一个pixel都会参与光照计算，当场景里光照很多的时候，无论光源对物体的影响有多微弱或多强，Forward Rendering都会一一计算这些光照对物体的影响，这样会导致大量的光照计算。)</p>
</li>
</ol>
<p>而Deferred Shading却没有上述问题。<br>那么让我们来了解一下什么是Deferred Shading<br><a href="https://en.wikipedia.org/wiki/Deferred_shading" target="_blank" rel="external">deferred shading is a screen-space shading technique. It is called deferred because no shading is actually performed in the first pass of the vertex and pixel shaders: instead shading is “deferred” until a second pass.</a><br><a href="http://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342" target="_blank" rel="external">下图来源</a><br><img src="/img/OpenGL/DeferredShading.PNG" alt="DeferredShading"></p>
<p>从上面我们只能看出，Deferred Shading是针对scree-space而非每一个物体的vertex。并且deferred shading是由两个pass构成，第二个pass才是真正的shading。<br>接下来让我们看看这两个pass：</p>
<ol>
<li><p>Geometry Pass. <a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html" target="_blank" rel="external">Data that is required for shading computation is gathered. Positions, normals, and materials for each surface are rendered into the geometry buffer (G-buffer) using “render to texture.(Multiple Render Targets (MRT)</a>(在第一个pass我们并不像Forward Rendering把所有光照计算相关的数据传入FS而是存入geometry buffer(G-buffer)用于第二个pass进行真正的Shading。因为我们存储在G-buffer里的数据都是经过rasterizer的，所以在G-buffer里我们只存储了通过depth test的pixel，这样一来我们在第二次用G-buffer数据计算光照的时候就避免了无谓的光照计算(这里指没通过depth test的pixel))<br>让我们来看看G-buffer都存储些什么数据，<a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html" target="_blank" rel="external">下图来源</a><br><img src="/img/OpenGL/G-Buffer.PNG" alt="G-Buffer"><br>可以看出，我们存储了所有参与光照计算所需要的数据。<br>Geometry Pass的主要目的是生成4个关于Position，Diffuse，Normal，TexCoord的纹理贴图和一个关于Depth的纹理贴图。<br>Geometry Pass主要由以下几个步骤：</p>
<ol>
<li><p>创建m_FBO</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GBuffer::Init(<span class="keyword">unsigned</span> <span class="keyword">int</span> windowwidth, <span class="keyword">unsigned</span> <span class="keyword">int</span> windowheight)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Create the FBO</span></span><br><span class="line">	glGenFramebuffers(<span class="number">1</span>, &amp;m_FBO);</span><br><span class="line">	glBindFramebuffer(GL_FRAMEBUFFER, m_FBO);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建4个纹理贴图分别Attach到m_FBO的GL_COLOR_ATTACHMENT*上。单独创建1个纹理贴图Attach到m_FBO的GL_DEPTH_ATTACHMENT上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GBuffer::Init(<span class="keyword">unsigned</span> <span class="keyword">int</span> windowwidth, <span class="keyword">unsigned</span> <span class="keyword">int</span> windowheight)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Create the FBO</span></span><br><span class="line">    ......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Create the gbuffer textures</span></span><br><span class="line">	glGenTextures(ARRAY_SIZE_IN_ELEMENTS(m_Textures), m_Textures);</span><br><span class="line">	glGenTextures(<span class="number">1</span>, &amp;m_DepthTexture);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_Textures); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		glBindTexture(GL_TEXTURE_2D, m_Textures[i]);</span><br><span class="line">		glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB32F, windowwidth, windowheight, <span class="number">0</span>, GL_RGB, GL_FLOAT, <span class="number">0</span>);</span><br><span class="line">		glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, m_Textures[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//depth texture</span></span><br><span class="line">	glBindTexture(GL_TEXTURE_2D, m_DepthTexture);</span><br><span class="line">	glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT32, windowwidth, windowheight, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">	glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_DepthTexture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	GLenum drawbuffers[] = &#123; GL_COLOR_ATTACHMENT0,</span><br><span class="line">							 GL_COLOR_ATTACHMENT1,</span><br><span class="line">							 GL_COLOR_ATTACHMENT2,</span><br><span class="line">							 GL_COLOR_ATTACHMENT3&#125;;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定需要从FS中输出的Position，Diffuse，Normal，TexCoord绘制的color buffer</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">bool GBuffer::Init(unsigned int windowwidth, unsigned int windowheight)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	// specify the color buffer to be drawn into, we will output buffer data for each color buffer in FS with out key word variable</span><br><span class="line">	// 这里应对的是FS里指定的out输出</span><br><span class="line">	glDrawBuffers(ARRAY_SIZE_IN_ELEMENTS(drawbuffers), drawbuffers);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">geometry_pass.vs</span><br><span class="line">// VS没什么变化，只是把我们需要保存的Position，TexCoord，Normal分别转换透视投影坐标系和世界坐标系里</span><br><span class="line">#version 330                                                                        </span><br><span class="line">                                                                                    </span><br><span class="line">layout (location = 0) in vec3 Position;                                             </span><br><span class="line">layout (location = 1) in vec2 TexCoord;                                             </span><br><span class="line">layout (location = 2) in vec3 Normal;                                               </span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line">uniform mat4 gWorld;</span><br><span class="line">                                        </span><br><span class="line">out vec2 TexCoord0;                                                                 </span><br><span class="line">out vec3 Normal0;                                                                   </span><br><span class="line">out vec3 WorldPos0;                                                                 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;       </span><br><span class="line">    gl_Position    = gWVP * vec4(Position, 1.0);</span><br><span class="line">    TexCoord0      = TexCoord;                  </span><br><span class="line">    Normal0        = (gWorld * vec4(Normal, 0.0)).xyz;   </span><br><span class="line">    WorldPos0      = (gWorld * vec4(Position, 1.0)).xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">geometry_pass.fs</span><br><span class="line">// FS负责把转换后的Position，Diffuse，Normal，TexCoordOut输出到我们之前绑定的GL_COLOR_ATTACHMENT*上</span><br><span class="line">#version 330</span><br><span class="line">                                                                        </span><br><span class="line">in vec2 TexCoord0;                                                                  </span><br><span class="line">in vec3 Normal0;                                                                    </span><br><span class="line">in vec3 WorldPos0;                                                                  </span><br><span class="line"></span><br><span class="line">layout (location = 0) out vec3 WorldPosOut;   </span><br><span class="line">layout (location = 1) out vec3 DiffuseOut;     </span><br><span class="line">layout (location = 2) out vec3 NormalOut;     </span><br><span class="line">layout (location = 3) out vec3 TexCoordOut;    </span><br><span class="line">										</span><br><span class="line">uniform sampler2D gColorMap;                </span><br><span class="line">											</span><br><span class="line">void main()									</span><br><span class="line">&#123;											</span><br><span class="line">	WorldPosOut     = WorldPos0;					</span><br><span class="line">	DiffuseOut      = texture(gColorMap, TexCoord0).xyz;	</span><br><span class="line">	NormalOut       = normalize(Normal0);					</span><br><span class="line">	TexCoordOut     = vec3(TexCoord0, 0.0);				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用Geometry Pass生成对应的纹理贴图信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DSGeometryPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	gDSGeomPassTech.Enable();</span><br><span class="line">    <span class="comment">// 输出到Color Texture里之前，</span></span><br><span class="line">    <span class="comment">// 我们需要指定我们需要绘制到的FrameBuffer是我们Color Texture所绑定的m_FBO</span></span><br><span class="line">	gGbuffer.BindForWriting();</span><br><span class="line"></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.Scale(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>);</span><br><span class="line">	p.Rotate(<span class="number">0.0f</span>, gScale, <span class="number">0.0f</span>);</span><br><span class="line">	p.WorldPos(-<span class="number">0.8f</span>, -<span class="number">1.0f</span>, <span class="number">12.0f</span>);</span><br><span class="line">	p.SetCamera(pGameCamera-&gt;GetPos(), pGameCamera-&gt;GetTarget(), pGameCamera-&gt;GetUp());</span><br><span class="line">	p.SetPerspectiveProj(gPersProjInfo);</span><br><span class="line"></span><br><span class="line">	gDSGeomPassTech.SetWVP(p.GetWVPTrans());</span><br><span class="line">	gDSGeomPassTech.SetWorldMatrix(p.GetWorldTrans());</span><br><span class="line"></span><br><span class="line">	gMesh.Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将生成的4个Color Texture复制到FrameBuffer 0里，然后渲染到屏幕上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DSLightPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// Bound frame buffer target 0 to draw state, we will copy four color buffer to this buffer later</span></span><br><span class="line">	<span class="comment">// 因为glBlitFramebuffer()函数是把GL_READ_FRAMEBUFFER的target copy到GL_DRAW_FRAMEBUFFER的target上，</span></span><br><span class="line">	<span class="comment">// 所以我们要声明Frame buffer 0作为我们最终的目的地</span></span><br><span class="line">	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bound frame buffer m_FBO to reading state,</span></span><br><span class="line">	<span class="comment">// we will copy four color buffer that attach to m_FBO to frame buffer target 0 later</span></span><br><span class="line">	<span class="comment">// BindForReading()就是设置m_FBO作为glBlitFramebuffer()里的copy来源，</span></span><br><span class="line">	<span class="comment">// 所以需要设置成GL_READ_FRAMEBUFFER</span></span><br><span class="line">	gGbuffer.BindForReading();</span><br><span class="line"></span><br><span class="line">	GLint halfwidth = (GLint)(WINDOW_WIDTH / <span class="number">2.0f</span>);</span><br><span class="line">	GLint halfheight = (GLint)(WINDOW_HEIGHT / <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Color buffer for position</span></span><br><span class="line">	<span class="comment">// Set color buffer source for copying</span></span><br><span class="line">	<span class="comment">// 因为一次只能从一个texture里copy，所以我们需要指定是copy哪一个</span></span><br><span class="line">	gGbuffer.SetReadBuffer(GBuffer::GBUFFER_TEXTURE_TYPE_POSITION);</span><br><span class="line">	<span class="comment">// Set buffer copy info</span></span><br><span class="line">	glBlitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, WINDOW_WIDTH, WINDOW_HEIGHT, <span class="number">0</span>, <span class="number">0</span>, halfwidth, halfheight, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Color buffer for diffuses</span></span><br><span class="line">	gGbuffer.SetReadBuffer(GBuffer::GBUFFER_TEXTURE_TYPE_DIFFUSE);</span><br><span class="line">	glBlitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, WINDOW_WIDTH, WINDOW_HEIGHT, <span class="number">0</span>,halfheight, halfwidth, WINDOW_HEIGHT, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Color buffer for normal</span></span><br><span class="line">	gGbuffer.SetReadBuffer(GBuffer::GBUFFER_TEXTURE_TYPE_NORMAL);</span><br><span class="line">	glBlitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, WINDOW_WIDTH, WINDOW_HEIGHT, halfwidth,halfheight, WINDOW_WIDTH, WINDOW_HEIGHT, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Color buffer for TexCoor</span></span><br><span class="line">	gGbuffer.SetReadBuffer(GBuffer::GBUFFER_TEXTURE_TYPE_TEXCOORD);</span><br><span class="line">	glBlitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, WINDOW_WIDTH, WINDOW_HEIGHT, halfwidth,<span class="number">0</span>, WINDOW_WIDTH, halfheight, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Final Effect:<br><img src="/img/OpenGL/DeferredShading_GeometryPass.PNG" alt="DeferredShading_GeometryPass"><br> 在真正的Deferred Shading中，有几个需要注意的点。<br> 第一个点，我们不需要讲生成的四个Color Texture显示在屏幕上，所以最后一步是可以省去的。<br> 第二个点因为Geometry Pass只需要存储closest pixel，所以我们需要开启GL_DEPTH_TEST，并且设置glDepthMask(GL_TRUE)来防止其他pass写入我们的fbo的depth buffer。<br> 最终geometry pass代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DSGeometryPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    m_DSGeomPassTech.Enable();</span><br><span class="line"></span><br><span class="line">    m_gbuffer.BindForWriting();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only the geometry pass updates the depth buffer</span></span><br><span class="line">    glDepthMask(GL_TRUE);</span><br><span class="line"></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    glDisable(GL_BLEND);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When we get here the depth buffer is already populated and the stencil pass</span></span><br><span class="line">    <span class="comment">// depends on it, but it does not write to it.</span></span><br><span class="line">    glDepthMask(GL_FALSE);</span><br><span class="line"></span><br><span class="line">    glDisable(GL_DEPTH_TEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第三个点，因为Lighting Pass里参与计算的的TexCoordnate信息可以通过下列算式计算出来，所以出于节约内存，我们可以不必生成TexCoordnate的Texture(即只需要Position，Diffuse，Normal和Depth（这个后续会用到）四个贴图)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">CalcTexCoord</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gl_FragCoord.xy / gScreenSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第四个点，因为我们生成的Texture最终会用于Screen的1对1映射计算，所以我们需要把我们生成的Texture指定filter。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> GBuffer::Init(<span class="keyword">unsigned</span> <span class="keyword">int</span> WindowWidth, <span class="keyword">unsigned</span> <span class="keyword">int</span> WindowHeight)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_textures) ; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>Lighting Pass. <a href="https://en.wikipedia.org/wiki/Deferred_shading" target="_blank" rel="external">A pixel shader computes the direct and indirect lighting at each pixel using the information of the texture buffers in screen space.</a><br>在第二个Lighting Pass里我们只需要用我们在Geometry Pass存储的数据来进行pixel by pixel的光照计算即可，因为我们存储的texture是针对screen space的，所有存储的pixel都是通过了depth test的，所以在Deferred Shading里，我们只针对通过了depth test的pixel进行了光照计算。<br>下面我们来看看如何通过已经存储的Position，Diffuse，Normal，Depth信息来得出最终的光照颜色。首先让我们看看整体的轮廓。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCallbackCB</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	pGameCamera-&gt;OnRender();</span><br><span class="line"></span><br><span class="line">	gScale += <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">	DSGeometryPass();</span><br><span class="line"></span><br><span class="line">	BeginLightPasses();</span><br><span class="line"></span><br><span class="line">	DSPointLightPass();</span><br><span class="line"></span><br><span class="line">	DSDirectionalLightPass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swap buffer</span></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>开启混合模式，因为Deferred Shading现在是每一个pixel都会针对所有相关的光照进行计算，最终的结果将有所有光照计算叠加而成。(因为我们不需要再从我们生成的fbo读取数据了(直接从生成的texture里去读)，所以不需要再绑定到生成的fbo上，而是绑定到默认的fbo上，这样一来我们只需设置并绑定我们对应的Texture即可)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GBuffer::BindForReading()</span><br><span class="line">&#123;</span><br><span class="line">	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_textures); i++) &#123;</span><br><span class="line">		glActiveTexture(GL_TEXTURE0 + i);		</span><br><span class="line">		glBindTexture(GL_TEXTURE_2D, m_textures[GBUFFER_TEXTURE_TYPE_POSITION + i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeginLightPasses</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    glEnable(GL_BLEND);</span><br><span class="line">    glBlendEquation(GL_FUNC_ADD);</span><br><span class="line">    glBlendFunc(GL_ONE, GL_ONE);</span><br><span class="line"></span><br><span class="line">    m_gbuffer.BindForReading();</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一个Pixel针对场景里的Point， Direction， Spot Light进行计算得出最终颜色。这里要针对每一种光照进行说明，如何触发正确的计算。<br>Direction Light因为是全局光，所以我们需要针对每一个Pixel进行计算，这里我们通过一个铺满屏幕的Quad Mesh来触发计算。<br>Direction Light:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">light_pass.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span>                                                                        </span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position; </span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;          </span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dir_light_pass.fs</span><br><span class="line"><span class="comment">// 这个和之前大部分一样，唯一的区别就是从对应的Texture读取需要参与计算的信息</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function">vec2 <span class="title">CalcTexCoord</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gl_FragCoord.xy / gScreenSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vec2 TexCoord = CalcTexCoord();</span><br><span class="line">	vec3 WorldPos = texture(gPositionMap, TexCoord).xyz;</span><br><span class="line">	vec3 Color = texture(gColorMap, TexCoord).xyz;</span><br><span class="line">	vec3 Normal = texture(gNormalMap, TexCoord).xyz;</span><br><span class="line">	Normal = normalize(Normal);</span><br><span class="line"></span><br><span class="line">	FragColor = vec4(Color, <span class="number">1.0</span>) * CalcDirectionalLight(WorldPos, Normal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DSDirectionalLightPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    m_DSDirLightPassTech.Enable();</span><br><span class="line">    m_DSDirLightPassTech.SetEyeWorldPos(m_pGameCamera-&gt;GetPos());</span><br><span class="line">    Matrix4f WVP;</span><br><span class="line">    <span class="comment">// 这里我们使用的quad是(-1,1)to(1,1)，通过设置WVP为单位矩阵，这样一来经过rasterizer后，</span></span><br><span class="line">    <span class="comment">// (-1,-1)to(1,1)就会被映射到(0,0)to(SCREEN_WIDTH,SCREEN_HEIGHT)即铺满全屏</span></span><br><span class="line">    <span class="comment">// 其他都和之前Dir Light计算一样，只是这里有多少个Dir Light就要针对每个Pixel计算多少次</span></span><br><span class="line">    WVP.InitIdentity();</span><br><span class="line">    m_DSDirLightPassTech.SetWVP(WVP);</span><br><span class="line">    m_quad.Render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>Point Light因为是范围光，所以我们需要知道Point Light所影响的范围去触发对应Pixel的光照计算。这里涉及到一个Point Light的<a href="http://ogldev.atspace.co.uk/www/tutorial36/tutorial36.html" target="_blank" rel="external">Point Light光照削弱方程</a>。这里我也没详细看了，想了解的可以去看一下。通过方程我们得出了Point Light的有效范围，这样一来我们只需要以Point Light所在位置为圆心绘制一个Sphere就能触发正确的Point Light光照计算了。<br>Point Light:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shader没什么变化，只是通过Texture去读取相关数据，这里就不重复了。</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光照削弱计算</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CalcPointLightBSphere</span><span class="params">(<span class="keyword">const</span> PointLight&amp; Light)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> MaxChannel = fmax(fmax(Light.Color.x, Light.Color.y), Light.Color.z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> ret = (-Light.Attenuation.Linear + sqrtf(Light.Attenuation.Linear * Light.Attenuation.Linear -</span><br><span class="line">        <span class="number">4</span> * Light.Attenuation.Exp * (Light.Attenuation.Exp - <span class="number">256</span> * MaxChannel * Light.DiffuseIntensity)))</span><br><span class="line">            /</span><br><span class="line">        (<span class="number">2</span> * Light.Attenuation.Exp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DSPointLightsPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    m_DSPointLightPassTech.Enable();</span><br><span class="line">    m_DSPointLightPassTech.SetEyeWorldPos(m_pGameCamera-&gt;GetPos());</span><br><span class="line"></span><br><span class="line">    Pipeline p;</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    p.SetPerspectiveProj(m_persProjInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里也一样，有多少个Point Light就要触发多少次光照运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_pointLight); i++) &#123;</span><br><span class="line">        m_DSPointLightPassTech.SetPointLight(m_pointLight[i]);</span><br><span class="line">        p.WorldPos(m_pointLight[i].Position);</span><br><span class="line">        <span class="comment">// 绘制指定半径大小的Sphere触发光照计算</span></span><br><span class="line">        <span class="keyword">float</span> BSphereScale = CalcPointLightBSphere(m_pointLight[i]);</span><br><span class="line">        p.Scale(BSphereScale, BSphereScale, BSphereScale);</span><br><span class="line">        m_DSPointLightPassTech.SetWVP(p.GetWVPTrans());</span><br><span class="line">        m_bsphere.Render();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现的过程中我遇到点问题，所以也没有去实现Spot Light，个人认为应该是通过cone(圆锥体)去模拟Spot Light的范围，通过光照削弱方程去计算有效范围。</p>
<p>这里说一下我遇到的问题(没有解决)，如果大家有什么头绪，欢迎提出来。<br>描述上来说，我通过官网的教程根据source code编写后，发现我的只有当camera离的很近的时候才会显示一个box(最初怀疑是PersProjInfo设置的zFar导致的，后来查看是一模一样的。但通过修改源代码的zFar=2.0我得到了相同的结果，但这里无论我如何修改zFar，我的示例始终只有靠近box的时候才显示一部分。)<br><img src="/img/OpenGL/DSStart.PNG" alt="DS一开始截图"><br><img src="/img/OpenGL/DSClose.PNG" alt="DS靠近后"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Source Code</span></span><br><span class="line">	m_persProjInfo.FOV = <span class="number">60.0f</span>;</span><br><span class="line">	m_persProjInfo.Height = WINDOW_HEIGHT;</span><br><span class="line">	m_persProjInfo.Width = WINDOW_WIDTH;</span><br><span class="line">	m_persProjInfo.zNear = <span class="number">1.0f</span>;</span><br><span class="line">	m_persProjInfo.zFar = <span class="number">100.0f</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// My Code</span></span><br><span class="line">	gPersProjInfo.FOV = <span class="number">60.0f</span>;</span><br><span class="line">	gPersProjInfo.Height = WINDOW_HEIGHT;</span><br><span class="line">	gPersProjInfo.Width = WINDOW_WIDTH;</span><br><span class="line">	gPersProjInfo.zNear = <span class="number">1.0f</span>;</span><br><span class="line">	gPersProjInfo.zFar = <span class="number">100.0f</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过上述方法计算后，我们得出了我们Deferred Shading后的效果<br><img src="/img/OpenGL/DSSourceCode.PNG" alt="DS源代码效果"></p>
<p>但上述方法还有一些问题：</p>
<ol>
<li><p>当我们靠近Point Light的时候，Point Light光照消失了(这是因为我们之渲染front face，当Camera进入Light Sphere的时候Sphere被cull away了，所以也就不会触发Point Light的计算了。)</p>
</li>
<li><p>因为Sphere是针对我们生成的Screen Space的Texture而言的，所以有时候有些object其实不在sphere内但在sphere所在的screen space上就参与了计算，这样就错误的给某些object计算了point light。<br>解决第二个问题，需要用到Stencil Buffer。<br>在此之前让我们先来了解下什么是Stencil Buffer？<br><a href="https://en.wikipedia.org/wiki/Stencil_buffer" target="_blank" rel="external">A stencil buffer is an extra buffer, in addition to the color buffer and depth buffer (z-buffering) found on modern graphics hardware. The buffer is per pixel, and works on integer values, usually with a depth of one byte per pixel. </a><br>简单的想，可以把Stencil Buffer理解成PS里面的模板，只有Stencil Buffer里面的数据(数据可以修改)不为0的时候特定像素才能通过。真是因为这个特性我们可以控制哪些pixel参与Point Light光照计算。</p>
</li>
</ol>
<p>Stencil Buffer用于Stencil Test,Stencil Test是针对每一个像素调用，就像我之前说的类似PS的模板。</p>
<p>来我们来看个简单的Stencil Buffer效果，<a href="http://www.learnopengl.com/#!Advanced-OpenGL/Stencil-testing" target="_blank" rel="external">下图来源</a>:<br><img src="/img/OpenGL/StencilBufferEffect.PNG" alt="StencilBufferEffect"></p>
<p>我们可以指定Stencil Buffer里的值如何修改，什么时候修改。</p>
<p>接下来让我们来看看如何通过Stencil Buffer来解决第二个问题：<br><a href="http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html" target="_blank" rel="external">以下引用至</a></p>
<ol>
<li>Render the objects as usual into the G buffer so that the depth buffer will be properly populated.</li>
<li>Disable writing into the depth buffer. From now on we want it to be read-only</li>
<li>Disable back face culling. We want the rasterizer to process all polygons of the sphere.</li>
<li>Set the stencil test to always succeed. What we really care about is the stencil operation.</li>
<li>Configure the stencil operation for the back facing polygons to increment the value in the stencil buffer when the depth test fails but to keep it unchanged when either depth test or stencil test succeed.</li>
<li>Configure the stencil operation for the front facing polygons to decrement the value in the stencil buffer when the depth test fails but to keep it unchanged when either depth test or stencil test succeed.</li>
<li>Render the light sphere.(only when the stencil value of the pixel is different from zero)</li>
</ol>
<p>关键思想是通过判断object的front和back face是否在sphere的front和back的前面或后面来修改stencil buffer的值，然后通过该值得出我们所需绘制的pixel。<br>请看下图：<br><img src="/img/OpenGL/DeferredShadingStencilBufferUsing.PNG" alt="DeferredShadingStencilBufferUsing"><br>sphere的front和back face都在物体A的后面，物体C的前面，就物体B而言，front face在物体B之前，back face在物体B之后。</p>
<p>所以通过5,6步骤设定的规则，只有物体B所在的所在的pixel的stencil buffer值大于0</p>
<p>上面的2-6算作Stencil Pass，用于得到哪些物体参与Point Light Sphere的计算。</p>
<p>第7步才是真正光照计算。</p>
<p>接下来让我们看看代码实现：</p>
<ol>
<li><p>针对每一个Point Light开启stencil test并在进行关照计算之前调用stencil pass得出需要参与计算的pixel</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">null_technique.vs</span><br><span class="line"><span class="preprocessor">#version <span class="number">330</span></span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 Position; </span><br><span class="line"></span><br><span class="line">uniform mat4 gWVP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;          </span><br><span class="line">    gl_Position = <span class="function">gWVP * <span class="title">vec4</span><span class="params">(Position, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">null_technique.fs</span><br><span class="line"><span class="comment">// 这个为空，因为在stencil pass我们不需要填充color buffer，我们只需要触发rasterizer即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为最终pixel会被绘制到G buffer的GL_COLOR_ATTACHMENT4上，</span></span><br><span class="line"><span class="comment">// 所以我们要在每次渲染之前清除GL_COLOR_ATTACHMENT4</span></span><br><span class="line"><span class="keyword">void</span> GBuffer::StartFrame()</span><br><span class="line">&#123;</span><br><span class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_fbo);</span><br><span class="line">    glDrawBuffer(GL_COLOR_ATTACHMENT4);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化G buffer的时候需要注意，因为我们需要存储stencil值</span></span><br><span class="line"><span class="comment">// 这里depth texture格式变为GL_DEPTH32F_STENCIL8，并且attach到GL_DEPTH_STENCIL_ATTACHMENT上</span></span><br><span class="line"><span class="keyword">bool</span> GBuffer::Init(<span class="keyword">unsigned</span> <span class="keyword">int</span> WindowWidth, <span class="keyword">unsigned</span> <span class="keyword">int</span> WindowHeight)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// depth</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_depthTexture);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH32F_STENCIL8, WindowWidth, WindowHeight, <span class="number">0</span>, GL_DEPTH_STENCIL,</span><br><span class="line">                  GL_FLOAT_32_UNSIGNED_INT_24_8_REV, <span class="literal">NULL</span>);</span><br><span class="line">    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, m_depthTexture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GBuffer::BindForStencilPass()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// must disable the draw buffers </span></span><br><span class="line">	glDrawBuffer(GL_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DSStencilPass</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> PointLightIndex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	m_nullTech.Enable();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable color/depth write and enable stencil</span></span><br><span class="line">	<span class="comment">// 这里使用我们之前创建的fbo(存储了之前object渲染后depth buffer的fbo)</span></span><br><span class="line">	m_gbuffer.BindForStencilPass();</span><br><span class="line">	<span class="comment">// 因为stencil buffer的值更新跟depth test有关，所以需要开启GL_DEPTH_TEST</span></span><br><span class="line">	glEnable(GL_DEPTH_TEST);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了得到正确的stencil buffer值，我们需要针对sphere进行front和back face渲染</span></span><br><span class="line">    glDisable(GL_CULL_FACE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归零stencil buffer，用于下一个point light</span></span><br><span class="line">	glClear(GL_STENCIL_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We need the stencil test to be enabled but we want it</span></span><br><span class="line">	<span class="comment">// to succeed always. Only the depth test matters.</span></span><br><span class="line">	<span class="comment">// 指定stencil text always success，</span></span><br><span class="line">	<span class="comment">// 因为这里我只需要通过设定stencil buffer修改规则就能得到我们要的值了</span></span><br><span class="line">	glStencilFunc(GL_ALWAYS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为stencil buffer指定修改方式，即我们之前提到的6和7步骤</span></span><br><span class="line">	glStencilOpSeparate(GL_BACK, GL_KEEP, GL_INCR_WRAP, GL_KEEP);</span><br><span class="line">	glStencilOpSeparate(GL_FRONT, GL_KEEP, GL_DECR_WRAP, GL_KEEP);</span><br><span class="line"></span><br><span class="line">	Pipeline p;</span><br><span class="line">	p.WorldPos(m_pointLight[PointLightIndex].Position);</span><br><span class="line">    <span class="keyword">float</span> BBoxScale = CalcPointLightBSphere(m_pointLight[PointLightIndex]);</span><br><span class="line">	p.Scale(BBoxScale, BBoxScale, BBoxScale);		</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    p.SetPerspectiveProj(m_persProjInfo);</span><br><span class="line"></span><br><span class="line">	m_nullTech.SetWVP(p.GetWVPTrans());</span><br><span class="line">	<span class="comment">// 这样一来我们就得到了针对特定光照sphere的stencil buffer值了</span></span><br><span class="line">	m_bsphere.Render();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RenderSceneCB</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除G buffer的GL_COLOR_ATTACHMENT4</span></span><br><span class="line">    m_gbuffer.StartFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need stencil to be enabled in the stencil pass to get the stencil buffer</span></span><br><span class="line">    <span class="comment">// updated and we also need it in the light pass because we render the light</span></span><br><span class="line">    <span class="comment">// only if the stencil passes.</span></span><br><span class="line">    glEnable(GL_STENCIL_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_pointLight); i++) &#123;</span><br><span class="line">        DSStencilPass(i);</span><br><span class="line">        DSPointLightPass(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The directional light does not need a stencil test because its volume</span></span><br><span class="line">    <span class="comment">// is unlimited and the final pass simply copies the texture.</span></span><br><span class="line">    glDisable(GL_STENCIL_TEST);</span><br><span class="line"></span><br><span class="line">    DSDirectionalLightPass();</span><br><span class="line"></span><br><span class="line">    DSFinalPass();</span><br><span class="line"></span><br><span class="line">    RenderFPS();</span><br><span class="line"></span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用Point Light Pass通过stencil buffer对特定pixel进行光照计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GBuffer::BindForLightPass()</span><br><span class="line">&#123;</span><br><span class="line">    glDrawBuffer(GL_COLOR_ATTACHMENT4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ARRAY_SIZE_IN_ELEMENTS(m_textures); i++) &#123;</span><br><span class="line">        glActiveTexture(GL_TEXTURE0 + i);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, m_textures[GBUFFER_TEXTURE_TYPE_POSITION + i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DSPointLightPass</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> PointLightIndex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定参与光照计算的texture</span></span><br><span class="line">	m_gbuffer.BindForLightPass();</span><br><span class="line"></span><br><span class="line">    m_DSPointLightPassTech.Enable();</span><br><span class="line">    m_DSPointLightPassTech.SetEyeWorldPos(m_pGameCamera-&gt;GetPos());        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当stencil buffer value不等于0的时候才通过，</span></span><br><span class="line">    <span class="comment">// 这样一来就只有通过stencil pass即在光照sphere内的物体才参与计算</span></span><br><span class="line">	glStencilFunc(GL_NOTEQUAL, <span class="number">0</span>, <span class="number">0xFF</span>);</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">// 计算光照不需要Delpth test，只需要叠加计算光照效果即可</span></span><br><span class="line">	glDisable(GL_DEPTH_TEST);</span><br><span class="line">	glEnable(GL_BLEND);</span><br><span class="line">	glBlendEquation(GL_FUNC_ADD);</span><br><span class="line">	glBlendFunc(GL_ONE, GL_ONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里很重要，当我们去计算光照的时候，我们需要开启GL_FRONT Cull，</span></span><br><span class="line">    <span class="comment">// 这样一来可以避免camera位于sphere内的时候无法计算光照</span></span><br><span class="line">    <span class="comment">// (确保了sphere back face的片面渲染，但如果是GL_BACK，这一部分是会被CULL掉)</span></span><br><span class="line">    <span class="comment">// 这样一来就解决了之前说的当camera位于sphere内，无法计算光照的问题</span></span><br><span class="line">    glEnable(GL_CULL_FACE);</span><br><span class="line">    glCullFace(GL_FRONT);</span><br><span class="line"></span><br><span class="line">    Pipeline p;</span><br><span class="line">    p.WorldPos(m_pointLight[PointLightIndex].Position);</span><br><span class="line">    <span class="keyword">float</span> BBoxScale = CalcPointLightBSphere(m_pointLight[PointLightIndex]);        </span><br><span class="line">	p.Scale(BBoxScale, BBoxScale, BBoxScale);		</span><br><span class="line">    p.SetCamera(m_pGameCamera-&gt;GetPos(), m_pGameCamera-&gt;GetTarget(), m_pGameCamera-&gt;GetUp());</span><br><span class="line">    p.SetPerspectiveProj(m_persProjInfo);               </span><br><span class="line">    m_DSPointLightPassTech.SetWVP(p.GetWVPTrans());</span><br><span class="line">    m_DSPointLightPassTech.SetPointLight(m_pointLight[PointLightIndex]);</span><br><span class="line">    m_bsphere.Render(); </span><br><span class="line">    glCullFace(GL_BACK);</span><br><span class="line">   </span><br><span class="line">	glDisable(GL_BLEND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后渲染G buffer里计算得出的图像(之前我们绘制到了G buffer的GL_COLOR_ATTACHMENT4里)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GBuffer::BindForFinalPass()</span><br><span class="line">&#123;</span><br><span class="line">	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">    glBindFramebuffer(GL_READ_FRAMEBUFFER, m_fbo);</span><br><span class="line">    glReadBuffer(GL_COLOR_ATTACHMENT4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DSFinalPass</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 这里我之所以不直接渲染到default FBO的原因是因为，</span></span><br><span class="line">	<span class="comment">// 在Point Light Pass的时候我们需要知道depth buffer里的值来决定那些pixel应该参与光照计算</span></span><br><span class="line">    m_gbuffer.BindForFinalPass();</span><br><span class="line">    glBlitFramebuffer(<span class="number">0</span>, <span class="number">0</span>, WINDOW_WIDTH, WINDOW_HEIGHT,</span><br><span class="line">                      <span class="number">0</span>, <span class="number">0</span>, WINDOW_WIDTH, WINDOW_HEIGHT, GL_COLOR_BUFFER_BIT, GL_LINEAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Final Effect:<br><img src="/img/OpenGL/DeferredShadingFinalEffect.PNG" alt="DeferredShadingFinalEffect"></p>
<p>Note:<br><a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html" target="_blank" rel="external">The key point behind deferred shading is the decoupling of the geometry calculations (position and normal transformations) and the lighting calculations. </a></p>
<h2 id="OpenGL_Utility">OpenGL Utility</h2><h3 id="Open_Asset_Import_Library">Open Asset Import Library</h3><p>“Open Asset Import Library is a portable Open Source library to import various well-known 3D model formats in a uniform manne”</p>
<p><a href="http://www.assimp.org/" target="_blank" rel="external">官方网站</a></p>
<h4 id="assimp">assimp</h4><p>“assimp is a library to load and process geometric scenes from various data formats. It is tailored at typical game scenarios by supporting a node hierarchy, static or skinned meshes, materials, bone animations and potential texture data. The library is not designed for speed, it is primarily useful for importing assets from various sources once and storing it in a engine-specific format for easy and fast every-day-loading. “</p>
<p><a href="http://www.assimp.org/lib_html/index.html" target="_blank" rel="external">官方文档</a></p>
<p>Note:<br>个人理解，assimp主要是提供了对多种格式模型的数据解析，并抽象了所有数据到aiScene这个类里。<br>通过aiScene我们可以去访问模型数据里的顶点数据，纹理数据，材质数据等。<br>我们通过这些数据最终去作为我们的顶点数据创建顶点buffer，作为纹理数据创建纹理贴图，最终绘制出我们的模型。</p>
<p>源代码参考OpenGL Tutorial 22</p>
<h4 id="open3mod">open3mod</h4><p>“open3mod is a Windows-based model viewer. It loads all file formats that Assimp supports and is perfectly suited to quickly inspect 3d assets.”</p>
<p>主要用于快速查看各种资源格式的模型。<br><img src="/img/OpenGL/Open3mod.PNG" alt="Open3modUsing"></p>
<h3 id="GIMP">GIMP</h3><p>GNU Image Manipulation Program (GIMP) is a cross-platform image editor available for GNU/Linux, OS X, Windows and more operating systems.<br><a href="http://www.gimp.org/" target="_blank" rel="external">GIMPDownloadLink</a></p>
<p>gimp-normalmap plugin that supports to export normal map from texture<br><a href="https://code.google.com/archive/p/gimp-normalmap/" target="_blank" rel="external">gimp-normalmapDownloadLink</a></p>
<p>通过GIMP和gimp-normalmap插件，我们可以从texture中导出normal map使用。</p>
<h3 id="GLSL_Debuger">GLSL Debuger</h3><h4 id="Nsight">Nsight</h4><p><a href="http://www.nvidia.com/object/nsight.html" target="_blank" rel="external">NVIDIA® Nsight™ is the ultimate development platform for heterogeneous computing. Work with powerful debugging and profiling tools that enable you to fully optimize the performance of the CPU and GPU. - See more at: http://www.nvidia.com/object/nsight.html#sthash.Hc8TfPMs.dpuf</a><br>Nsight是NVIDIA开发的一套协助GPU开发的工具。<br>优点：</p>
<ol>
<li>支持直接调试GLSL和HLSL等着色器语言</li>
<li>和VS完美集成</li>
</ol>
<p>缺点：</p>
<ol>
<li>硬件限制比较多（比如主要针对NVIDIA公司的显卡）<br><a href="https://developer.nvidia.com/nsight-visual-studio-edition-requirements" target="_blank" rel="external">Nsight Visual Studio Edition Requirements</a></li>
</ol>
<h3 id="OpenGL_proiler,_debugger">OpenGL proiler, debugger</h3><h4 id="gDEBugger">gDEBugger</h4><p>gDEBugger是一个针对OpenGL和OpenCL开发的一套调试器，分析器和内存分析器等协助工具。<br>通过gDEBugger我们可以查看在某一贞关于OpenGL相关的大量信息（比如Uniform值，OpenGL的各个状态，Draw call次数等）<br>可以查看到OpenGL的一些状态，比如GL_CULL_FACE:<br><img src="/img/OpenGL/gDEBuggerCapture.PNG" alt="gDEBuggerCapture"></p>
<p>可以查看Shader的一些信息，并且可以编译Shader等：<br><img src="/img/OpenGL/gDEBuggerShaderInfo.PNG" alt="gDEBuggerShaderInfo"></p>
<h1 id="Reference_Website:">Reference Website:</h1><p><a href="http://www.opengl.org/sdk/docs/man4/" target="_blank" rel="external">OpenGL 4 reference page</a><br><a href="http://blog.csdn.net/guolihui112/article/details/5702915" target="_blank" rel="external">client-server 模式</a><br><a href="http://www.glprogramming.com/blue/ch01.html" target="_blank" rel="external">OpenGL Execute Model</a><br><a href="http://blog.chinaunix.net/uid-28959509-id-3762988.html" target="_blank" rel="external">X Window System</a><br><a href="http://ogldev.atspace.co.uk/index.html" target="_blank" rel="external">OpenGL Tutorial</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGL Windows &amp; Context</a><br><a href="https://www.opengl.org/wiki/Creating_an_OpenGL_Context_%28WGL%29" target="_blank" rel="external">Creating an OpenGL Context (WGL)</a><br><a href="https://www.opengl.org/wiki/OpenGL_Context" target="_blank" rel="external">OpenGL Context</a><br><a href="https://open.gl/context" target="_blank" rel="external">Window and OpenGL context</a><br><a href="http://openglbook.com/chapter-1-getting-started.html" target="_blank" rel="external">OpenGLBook.com Getting Started</a></p>
<p>Note:<br><strong>OpenGL uses right-handed coordinate system (OpenGL使用右手坐标系)</strong></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Rendering/">Rendering</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OpenGL/">OpenGL</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2015/08/26/OpenGL学习/" data-title="OpenGL学习 | 走停人生路" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/29/计算机图形学相关知识/" title="计算机图形学相关知识">
  <strong>上一篇：</strong><br/>
  <span>
  计算机图形学相关知识</span>
</a>
</div>


<div class="next">
<a href="/2015/08/15/CS学习/"  title="CS学习">
 <strong>下一篇：</strong><br/> 
 <span>CS学习
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/26/OpenGL学习/" data-title="OpenGL学习" data-url="http://tonytang1990.github.io/2015/08/26/OpenGL学习/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introdction_to_OpenGL"><span class="toc-number">1.1.</span> <span class="toc-text">Introdction to OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What_is_OpenGL?"><span class="toc-number">1.1.1.</span> <span class="toc-text">What is OpenGL?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History"><span class="toc-number">1.1.2.</span> <span class="toc-text">History</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next_Generation_OpenGL"><span class="toc-number">1.1.3.</span> <span class="toc-text">Next Generation OpenGL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_relative_knowledge"><span class="toc-number">1.2.</span> <span class="toc-text">OpenGL relative knowledge</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_render_pipeline"><span class="toc-number">1.2.1.</span> <span class="toc-text">OpenGL render pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Shader_Language_(GLSL)"><span class="toc-number">1.2.2.</span> <span class="toc-text">OpenGL Shader Language (GLSL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The_color_space_in_OpenGL"><span class="toc-number">1.2.3.</span> <span class="toc-text">The color space in OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-obj_and_-mtl_file_format"><span class="toc-number">1.2.4.</span> <span class="toc-text">.obj and .mtl file format</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_learning_journal"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL learning journal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">1.3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_Knowledge:"><span class="toc-number">1.3.2.</span> <span class="toc-text">OpenGL Knowledge:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Practice"><span class="toc-number">1.4.</span> <span class="toc-text">OpenGL Practice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Check_supported_OpenGL_version"><span class="toc-number">1.4.1.</span> <span class="toc-text">Check supported OpenGL version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Know_what_Glut_and_Glew_are,_and_how_to_use_them"><span class="toc-number">1.4.2.</span> <span class="toc-text">Know what Glut and Glew are, and how to use them</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_a_Window"><span class="toc-number">1.4.3.</span> <span class="toc-text">Open a Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_OpenGL"><span class="toc-number">1.4.4.</span> <span class="toc-text">Using OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using_Shader"><span class="toc-number">1.4.5.</span> <span class="toc-text">Using Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniform_Variables"><span class="toc-number">1.4.6.</span> <span class="toc-text">Uniform Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpolation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinate_Transformations_&_Perspective_Projection"><span class="toc-number">1.4.8.</span> <span class="toc-text">Coordinate Transformations & Perspective Projection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keyboard_&&_Mouse_Control"><span class="toc-number">1.4.9.</span> <span class="toc-text">Keyboard && Mouse Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture_Mapping"><span class="toc-number">1.4.10.</span> <span class="toc-text">Texture Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light_and_Shadow"><span class="toc-number">1.4.11.</span> <span class="toc-text">Light and Shadow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Skybox"><span class="toc-number">1.4.12.</span> <span class="toc-text">Skybox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Normal_Mapping"><span class="toc-number">1.4.13.</span> <span class="toc-text">Normal Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BillBoard_And_Geometry_Shader"><span class="toc-number">1.4.14.</span> <span class="toc-text">BillBoard And Geometry Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D_Picking"><span class="toc-number">1.4.15.</span> <span class="toc-text">3D Picking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic_Tessellation"><span class="toc-number">1.4.16.</span> <span class="toc-text">Basic Tessellation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vertex_Array_Objects"><span class="toc-number">1.4.17.</span> <span class="toc-text">Vertex Array Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instanced_Rendering"><span class="toc-number">1.4.18.</span> <span class="toc-text">Instanced Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLFX_-_An_OpenGL_Effect_Library"><span class="toc-number">1.4.19.</span> <span class="toc-text">GLFX - An OpenGL Effect Library</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deferred_Shading"><span class="toc-number">1.4.20.</span> <span class="toc-text">Deferred Shading</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL_Utility"><span class="toc-number">1.5.</span> <span class="toc-text">OpenGL Utility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Open_Asset_Import_Library"><span class="toc-number">1.5.1.</span> <span class="toc-text">Open Asset Import Library</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assimp"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">assimp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open3mod"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">open3mod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIMP"><span class="toc-number">1.5.2.</span> <span class="toc-text">GIMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL_Debuger"><span class="toc-number">1.5.3.</span> <span class="toc-text">GLSL Debuger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nsight"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Nsight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL_proiler,_debugger"><span class="toc-number">1.5.4.</span> <span class="toc-text">OpenGL proiler, debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gDEBugger"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">gDEBugger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website:"><span class="toc-number">2.</span> <span class="toc-text">Reference Website:</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Automation/" title="Automation">Automation<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Editor/" title="Editor">Editor<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game-Engine/" title="Game_Engine">Game_Engine<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>4</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Editor/" title="Editor">Editor<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Other/" title="Other">Other<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Resource/" title="Resource">Resource<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Excel/" title="Excel">Excel<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Art/" title="Art">Art<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Collision/" title="Collision">Collision<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/VersionControl/" title="VersionControl">VersionControl<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HotUpdate/" title="HotUpdate">HotUpdate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Network/" title="Network">Network<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sort/" title="Sort">Sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GameDesignPattern/" title="GameDesignPattern">GameDesignPattern<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Optimization/" title="Optimization">Optimization<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Time/" title="Time">Time<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Plugin/" title="Plugin">Plugin<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Prefab/" title="Prefab">Prefab<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Native/" title="Native">Native<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Tony Tang. <br/>
			This is my new blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2022 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"TonyTang1990"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
