
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>C# Study | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content=".Net FrameworkIntroduction.Net Framework是Microsoft为开发应用程序而创建创的一个具有革命意义的平台。
Content.Net Framework主要包含一个非常大的代码库，可以在客户语言中通过面向对象编程技术来使用这些代码。这个库分为多个不同的模块。
.Net Framework还包含.NET公共语言运行库(Common Language Runti">
<meta property="og:type" content="article">
<meta property="og:title" content="C# Study">
<meta property="og:url" content="http://tonytang1990.github.io/2015/08/15/CSharp-Study/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content=".Net FrameworkIntroduction.Net Framework是Microsoft为开发应用程序而创建创的一个具有革命意义的平台。
Content.Net Framework主要包含一个非常大的代码库，可以在客户语言中通过面向对象编程技术来使用这些代码。这个库分为多个不同的模块。
.Net Framework还包含.NET公共语言运行库(Common Language Runti">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CTSAndCLS.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CSharp_Compile_Process1.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CompileSourceIntoManagedModules.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ManagedModulesComponents.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/RelationshipBetweenModulesAndAssemblies.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CSharp_Compile_Process2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CodeExecution.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CodeExecution2.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CSharp_Compile_Process3.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/DelegateStudy.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/MulticastDelegate.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/MultipleDelegatePart1.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/MultipleDelegatePart2.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/MultipleDelegatePart3.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/MultipleDelegatePart4.png">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/DelegateStudyOutput.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CSharp_Delegate.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Static_Constructor_And_Static_Class.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/PriorityQueue_Study.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ExtensionMethods.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/PartialMethods.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Generic.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Variance_Contravariance.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CLRAppDomainProcessRelationship.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CrossAppDomainCommunicationOutPut.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ExportPublicAssemblyType.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CreateGenericInstance.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ClassHierchyOfReflection.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/PrintOutPublicMemberInfo.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ReflectionClassHierarchical.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ReflectionMethodInvoke.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/RuntimeHandlesUsing.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/RuntimeHandlesTestInBook.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Serialization.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/PlatformInvokeDemo.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/EventDefinition.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/EventTestResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CharAndCultureInfoOutput.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/StringConstructOutput.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/StringCatenationOutput.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/StringConstructionWithMemorySave.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Enumerates.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/EnumWithExtentionMethod.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/BitWithFlag.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/BitWithoutFlag.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/CustomAttribute.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ExceptionProperties.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/ExceptionWindow.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/StackAndHeapPart1.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/StackAndHeapPart2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/StackAndHeapPart3.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/GCGenerations.png">
<meta property="og:updated_time" content="2016-10-26T03:33:20.677Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C# Study">
<meta name="twitter:description" content=".Net FrameworkIntroduction.Net Framework是Microsoft为开发应用程序而创建创的一个具有革命意义的平台。
Content.Net Framework主要包含一个非常大的代码库，可以在客户语言中通过面向对象编程技术来使用这些代码。这个库分为多个不同的模块。
.Net Framework还包含.NET公共语言运行库(Common Language Runti">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">有时候不是习惯了一个人，而是在没有认可自己之前选择了一个人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/15/CSharp-Study/" title="C# Study" itemprop="url">C# Study</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2015-08-15T06:30:53.000Z" itemprop="datePublished"> 發表於 2015-08-15</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#-Net_Framework"><span class="toc-number">1.</span> <span class="toc-text">.Net Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content"><span class="toc-number">1.2.</span> <span class="toc-text">Content</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using_-NET_Framework"><span class="toc-number">1.3.</span> <span class="toc-text">Using .NET Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tools"><span class="toc-number">1.3.1.</span> <span class="toc-text">Tools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关概念"><span class="toc-number">1.3.2.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FCL(Framework_Class_Library)"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">FCL(Framework Class Library)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metadata"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IL(Intermediate_Language)"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">IL(Intermediate Language)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLI(Common_Language_Infrastructure)"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">CLI(Common Language Infrastructure)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLR(Common_Language_Runtime)"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">CLR(Common Language Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CTS(Common_Type_System)"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">CTS(Common Type System)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLS(Common_Language_Specification)"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">CLS(Common Language Specification)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compile_process"><span class="toc-number">1.3.3.</span> <span class="toc-text">Compile process</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Managed_Module"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Managed Module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executing_Assembly_Code"><span class="toc-number">1.3.4.</span> <span class="toc-text">Executing Assembly Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序集"><span class="toc-number">1.3.5.</span> <span class="toc-text">程序集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#托管代码"><span class="toc-number">1.3.6.</span> <span class="toc-text">托管代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收"><span class="toc-number">1.3.7.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接"><span class="toc-number">1.3.8.</span> <span class="toc-text">链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp"><span class="toc-number">2.</span> <span class="toc-text">CSharp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-1"><span class="toc-number">2.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Features"><span class="toc-number">2.2.</span> <span class="toc-text">Features</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Development"><span class="toc-number">2.3.</span> <span class="toc-text">Development</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Language_Study"><span class="toc-number">2.4.</span> <span class="toc-text">Language Study</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delegate"><span class="toc-number">2.4.1.</span> <span class="toc-text">delegate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_&_interface"><span class="toc-number">2.4.2.</span> <span class="toc-text">Class & interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Not_supported_multiple_inherit"><span class="toc-number">2.4.3.</span> <span class="toc-text">Not supported multiple inherit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_member"><span class="toc-number">2.4.4.</span> <span class="toc-text">Class member</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Struct_&_Class"><span class="toc-number">2.4.5.</span> <span class="toc-text">Struct & Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection_class_(System-Collection)"><span class="toc-number">2.4.6.</span> <span class="toc-text">Collection class (System.Collection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-number">2.4.7.</span> <span class="toc-text">Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparasion"><span class="toc-number">2.4.8.</span> <span class="toc-text">Comparasion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conversion"><span class="toc-number">2.4.9.</span> <span class="toc-text">Conversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generics"><span class="toc-number">2.4.10.</span> <span class="toc-text">Generics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hosting,_AppDomain,_Assembly,_Reflection"><span class="toc-number">2.4.11.</span> <span class="toc-text">Hosting, AppDomain, Assembly, Reflection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hosting"><span class="toc-number">2.4.11.1.</span> <span class="toc-text">Hosting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AppDomain"><span class="toc-number">2.4.11.2.</span> <span class="toc-text">AppDomain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Assembly_Loading"><span class="toc-number">2.4.11.3.</span> <span class="toc-text">Assembly Loading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflection"><span class="toc-number">2.4.11.4.</span> <span class="toc-text">Reflection</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime_Serialization"><span class="toc-number">2.4.12.</span> <span class="toc-text">Runtime Serialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Platform_Invoke"><span class="toc-number">2.4.13.</span> <span class="toc-text">Platform Invoke</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event"><span class="toc-number">2.4.14.</span> <span class="toc-text">Event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chars,_Strings,_and_Working_with_Text"><span class="toc-number">2.4.15.</span> <span class="toc-text">Chars, Strings, and Working with Text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enumerated_and_Bit_Flags"><span class="toc-number">2.4.16.</span> <span class="toc-text">Enumerated and Bit Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom_Attributes"><span class="toc-number">2.4.17.</span> <span class="toc-text">Custom Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exceptions_and_State_Management"><span class="toc-number">2.4.18.</span> <span class="toc-text">Exceptions and State Management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The_Managed_Heap_and_Garbage_Collection"><span class="toc-number">2.4.19.</span> <span class="toc-text">The Managed Heap and Garbage Collection</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<h1 id="-Net_Framework">.Net Framework</h1><h2 id="Introduction">Introduction</h2><p>.Net Framework是Microsoft为开发应用程序而创建创的一个具有革命意义的平台。</p>
<h2 id="Content">Content</h2><p>.Net Framework主要包含一个非常大的代码库，可以在客户语言中通过面向对象编程技术来使用这些代码。这个库分为多个不同的模块。</p>
<p>.Net Framework还包含.NET公共语言运行库(Common Language Runtime, CLR)，它负责管理用.NET库开发的所有应用程序的执行</p>
<h2 id="Using_-NET_Framework">Using .NET Framework</h2><h3 id="Tools">Tools</h3><ol>
<li>Visual Studio</li>
<li>VCE(for C#)</li>
</ol>
<h3 id="相关概念">相关概念</h3><h4 id="FCL(Framework_Class_Library)">FCL(Framework Class Library)</h4><p>“The FCL is a set of DLL assemblies that contain several thousand type definitions in which each type exposes some functionality.”(提供了大量功能的现有DLL库)</p>
<h4 id="Metadata">Metadata</h4><p>“There are two main types of tables: tables that describe the types and members defined in your source code and tables that describe the types and members referenced by your source code.”(包含了源代码里类型的定义，对象的索引等信息)</p>
<h4 id="IL(Intermediate_Language)">IL(Intermediate Language)</h4><p>“IL is a CPU-independent machine language created by Microsoft after consultation with several external commercial and academic language/compiler writers.”(CPU无关的中间语言，用来抽象编译后的高阶语言，在JIT中会被编译成特定OS和目标机器架构的机器代码)</p>
<h4 id="CLI(Common_Language_Infrastructure)">CLI(Common Language Infrastructure)</h4><p><a href="https://en.wikipedia.org/wiki/Common_Language_Infrastructure" target="_blank" rel="external">The Common Language Infrastructure (CLI) is an open specification developed by Microsoft and standardized by ISO[1] and ECMA[2] that describes executable code and a runtime environment that allow multiple high-level languages to be used on different computer platforms without being rewritten for specific architectures.</a>(通用语言基础架构定义了可执行码以及代码的运行时环境的规范，使得高级语言编写的软件无需重新编写就可以运行在不同的计算机体系结构上)</p>
<p>Note:<br><a href="https://en.wikipedia.org/wiki/Common_Language_Infrastructure" target="_blank" rel="external">The .NET Framework and the free and open source Mono and Portable.NET are implementations of the CLI.</a></p>
<h4 id="CLR(Common_Language_Runtime)">CLR(Common Language Runtime)</h4><p>“The common language runtime (CLR) is just what its name says it is: a runtime that is usable by different and varied programming languages. The core features of the CLR (such as memory management, assembly loading, security, exception handling, and thread synchronization) are available to any and all programming languages that target it” — 《CLR Via C# Fourth Edition - Jeffrey Richter》(公共语言运行库提供了内存管理，异常处理，线程同步等功能)</p>
<h4 id="CTS(Common_Type_System)">CTS(Common Type System)</h4><p>“Describes how types are defined and how they behave. Defines the rules governing type inheritance, virtual methods, object lifetime, and so on.”</p>
<h4 id="CLS(Common_Language_Specification)">CLS(Common Language Specification)</h4><p>“Details for compiler vendors the minimum set of features their compilers must support if these compilers are to generate types compatible with other components written by other CLS-compliant languages on top of the CLR.”(通用语言规范定义了通用语言之间类型交互的基本规范)<br><img src="/img/CSharp/CTSAndCLS.png" alt="CTSAndCLS"></p>
<h3 id="Compile_process">Compile process</h3><ol>
<li>CIL(Common Intermediate Language)<br>首先把代码编译成通用中间语言(Common Intermediate Language, CIL)代码<br><img src="/img/CSharp/CSharp_Compile_Process1.PNG" alt="编译到程序集"></li>
</ol>
<p><img src="/img/CSharp/CompileSourceIntoManagedModules.png" alt="Compile Source Into Managed Modules"><br>从上面可以看出CLR支持的语言都被编译成Managed module(IL and metadata)</p>
<h4 id="Managed_Module">Managed Module</h4><p>Managed Module由两部分组成：</p>
<ol>
<li>Metadata</li>
<li>IL(Intermediate Language)<br><img src="/img/CSharp/ManagedModulesComponents.png" alt="ManagedModulesComponents"><br>可以看出Metadata是负责记录类型信息。<br>IL是通过CLR编译后的CPU-independent的中间语言。<br>CLR支持的语言都会编译成IL和Metadata存储在Managed Module里。<br>但我们最终在程序里加载的不是Module而是Assebmlies。下面来看看Module和Assebmly之间的关系。<br><img src="/img/CSharp/RelationshipBetweenModulesAndAssemblies.png" alt="RelationshipBetweenModulesAndAssemblies"><br>可以看出Assembly是由多个Module组成。<br>而CLR是负责管理Assebmlies里的代码执行。<br>所以才有了多种CLR支持的语言在CLR内可以互相调用。<h3 id="Executing_Assembly_Code">Executing Assembly Code</h3></li>
<li>JIT(Just-In-Time)<br>把CIL编译为专用于OS和目标机器结构的机器代码<br><img src="/img/CSharp/CSharp_Compile_Process2.PNG" alt="编译为本机代码"><br>e.g.<br><img src="/img/CSharp/CodeExecution.png" alt="CodeExecutionExample1"><br><img src="/img/CSharp/CodeExecution2.png" alt="CodeExecutionExample2"><br>从上面可以看出，之前生成的IL会被JIT在运行时编译成对应的本地机器代码。当同样的方法再次调用时，就不需要JIT进行IL到本地机器代码的编译，直接调用之前编译好的机器代码即可。</li>
</ol>
<p>这里有个Unsafe code的概念值得注意。<br>Unsafe code is allowed to work directly with memory addresses and can manipulate bytes at these addresses.<br>/unsafe compiler switch to control whether allow to executing unsafe code(只有编译器开启了/unsafe标志才允许执行unsafe code(e.g. 直接操作内存地址进行修改))<br>PEVerify.exe可用不查看Assembly里是否有unsafe code。</p>
<h3 id="程序集">程序集</h3><p>编译程序时所创建的CIL代码存储在一个程序集中（e.g. .exe .dll）<br>程序集包含程序用到的相关数据信息(Assemblies contains all module’s Metadata and IL)</p>
<p>Note:<br>PDB(program Database) file helps the debugger find local variables and map the IL instructions to the source code.<br>NGen.exe tool can compiles all of an assembly’s IL code into native code and saves the resulting native code to a file on disk.(avoid compilation at run time)</p>
<h3 id="托管代码">托管代码</h3><p>CLR管理着应用程序，其方式是管理内存，处理安全性以及允许进行跨语言调试等。相反，不受CLR控制运行着的应用程序属于非托管类型。<br><img src="/img/CSharp/CSharp_Compile_Process3.PNG" alt="托管到CLR运行"></p>
<p>Note:<br>“C++ is unique in that it is the only compiler that allows the developer to write both managed and unmanaged code and have it emitted into a single module.”</p>
<h3 id="垃圾回收">垃圾回收</h3><p>托管代码中的一个功能GC(garbage collection)</p>
<h3 id="链接">链接</h3><p>模块化</p>
<h1 id="CSharp">CSharp</h1><h2 id="Introduction-1">Introduction</h2><p>C#是可用于创建要运行在.NET CLR上的应用程序的语言之一，它从C和C++语言演化而来，是Microsoft专门为使用.NET平台而创建的。</p>
<h2 id="Features">Features</h2><ol>
<li>语法简单</li>
<li>类型安全</li>
<li>为.NET Framework设计的语言</li>
</ol>
<h2 id="Development">Development</h2><p>Application Type</p>
<ol>
<li>Windows Appliaction Program</li>
<li>Web Application Program</li>
<li>Web Service</li>
</ol>
<h2 id="Language_Study">Language Study</h2><p>Only record some difference between C# and C++/Java</p>
<h3 id="delegate">delegate</h3><p>delegates — type-safe<br>Unmanaged C/C++ callback functions are not type-safe<br>首先要知道的是delegate在C#里类型安全的(即有有编译时的类型检查)<br>C++里是不是类型安全的</p>
<p>在调用delegate的时候，CLR提供了当reference type绑定方法到delegate的时covariance和contra-variance的支持。<br>Covariance means that a method can return a type that is derived from the delegate’s return type.(reference type的方法的返回类型可以是delegate指定返回类型的子类)<br>Contra-variance means that a method can take a parameter that is a base of the delegate’s parameter type.(reference type的方法的参数可以是delegate指定参数类型的父类)<br>The reason why value types and void cannot be used for covariance and contra-variance is because the memory structure for these things varies, whereas the memory structure for reference type is always a pointer.(value type和void不支持上述功能)</p>
<p>接下来让我们看看Delegate背后的故事：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpDeepStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">region</span> Delegate Study</span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">DelegateStudy</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="preprocessor">#<span class="keyword">region</span> Delegate Study</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StaticDelegateDemo</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"StaticDelegateDemo(&#123;0&#125;)"</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InstanceDelegateDemo</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"InstanceDelegateDemo(&#123;0&#125;)"</span>,<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChainDelegateDemo</span>(<span class="params">Program p</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            DelegateStudy cdd = <span class="keyword">null</span>;</span><br><span class="line">            cdd += Program.StaticDelegateDemo;</span><br><span class="line">            cdd += p.InstanceDelegateDemo;</span><br><span class="line">            cdd.Invoke(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> Delegate Study</span></span><br><span class="line">            Program p = <span class="keyword">new</span> Program();</span><br><span class="line">            DelegateStudy sdd = Program.StaticDelegateDemo;</span><br><span class="line">            DelegateStudy idd = p.InstanceDelegateDemo;</span><br><span class="line">            sdd.Invoke(<span class="number">1</span>);</span><br><span class="line">            idd.Invoke(<span class="number">2</span>);</span><br><span class="line">            Program.ChainDelegateDemo(p);</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line">                        </span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> Dynamic Study</span></span><br><span class="line">            <span class="comment">//Dynamic delegate part</span></span><br><span class="line">            MethodInfo mi = <span class="keyword">typeof</span>(Program).GetMethod(<span class="string">"InstanceDelegateDemo"</span>);</span><br><span class="line">            Delegate d = Delegate.CreateDelegate(<span class="keyword">typeof</span>(DelegateStudy), p, mi);</span><br><span class="line">            d.DynamicInvoke(<span class="number">4</span>);</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反编译后：<br><img src="/img/CSharp/DelegateStudy.png" alt="DelegateStudy"><br>从上面可以看到，当我们定义一个delegate的时候CLR会给我们生成一个继承至System.MulticastDelegate的类，上面是DelegateStudy Class。<br>而MulticastDelegate是我们去累加delegate的关键。<br><img src="/img/CSharp/MulticastDelegate.png" alt="MulticastDelegate"><br>从上面可以看出，MulticastDelegate包含了三个关键成员：</p>
<ol>
<li>_target<br>用于保存delegate的实例对象，如果是全局static的回调则为null</li>
<li>_methodPtr<br>用于识别回调方法</li>
<li>_invocationList<br>这个是用于delegate chain的关键，用于保存array of delegate objects<br>下面我们看看_invocationList是如何完成delegate chain的：<br><img src="/img/CSharp/MultipleDelegatePart1.png" alt="MultipleDelegatePart1"><br><img src="/img/CSharp/MultipleDelegatePart2.png" alt="MultipleDelegatePart2"><br><img src="/img/CSharp/MultipleDelegatePart3.png" alt="MultipleDelegatePart3"><br><img src="/img/CSharp/MultipleDelegatePart4.png" alt="MultipleDelegatePart4"><br>可以看出当我们chain delegate的时候_invocationList存储了delegate的指针到_invocationList里，从而实现了multiple delegate chain的效果。<br>最后要讲的一点是关于反射动态创建delegate：<br>通过System.Reflection.MethodInfo.CreateDelegate()方法我们可以实现动态创建delegate。<br>最终上面的代码会输出如下：<br><img src="/img/CSharp/DelegateStudyOutput.PNG" alt="DelegateStudyOutput"></li>
</ol>
<p>(C++里用函数指针实现,Java里通过内部类的闭包和interface去实现)<br>最后我们还可以通过lambda表达式和匿名方法去定义delegate<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">testDelegate</span>(<span class="params"><span class="keyword">string</span> para</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span>(<span class="params"><span class="keyword">string</span> para</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"doSomething:"</span> + para);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> method 1 to use delegate</span></span><br><span class="line">	        testDelegate delegate1;</span><br><span class="line">            delegate1 = <span class="keyword">new</span> testDelegate(doSomething);</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line">            delegate1(<span class="string">"delegate1"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> method 2 to use delegate(lambda expression)</span></span><br><span class="line">            testDelegate delegate2 = s =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"doSomething:"</span> + s);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line">            delegate2(<span class="string">"delegate2"</span>);</span><br><span class="line">              </span><br><span class="line">           <span class="preprocessor">#<span class="keyword">region</span> method 3 to use delegate(anonymous method)</span></span><br><span class="line">            testDelegate delegate3 = <span class="keyword">delegate</span>(<span class="keyword">string</span> para)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">"delegate3's para = "</span> + para);</span><br><span class="line">           &#125;;</span><br><span class="line">           <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line">           delegate3(<span class="string">"delegate3"</span>);</span><br><span class="line">           Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><img src="/img/CSharp/CSharp_Delegate.PNG" alt="CSharp_Delegate"></p>
<p>详细比较Delegate和函数指针，参见<a href="http://blog.sina.com.cn/s/blog_8c7d49f20101djju.html" target="_blank" rel="external">C# VS C++之一： 委托 vs 函数指针</a></p>
<p>这里只写最后的总结：<br>1.C#委托对象是真正的对象，C/C++函数指针只是函数入口地址<br>2.C++的委托对象：functor<br>3.C++的静多态：模版</p>
<h3 id="Class_&amp;_interface">Class &amp; interface</h3><ol>
<li>Class qualifier<br>internal class — only code in current project can access (default)<br>public class — other project code can access</li>
</ol>
<p>abstract class — abstract class<br>sealed class — cant not be inheritated</p>
<p>Note:<br>Compiler is not allowed derived class’s access privileges higher than parent class</p>
<p>e.g.<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyBase</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyBase</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cant do like this due to Child class access previlage is higher than parent class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyChild</span> <span class="comment">/*: MyBase*/</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyChild</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>support extends multiple interface<br>Note:<br>base class must be write down first when we inherites from one class and extends several interface<br>abstract &amp; sealed can not be used by interface due to no implementation in interface (abstract &amp; sealed qualifier are meaningless)</p>
<ol>
<li>Static constructor &amp; Static class<br>静态构造函数只会被调用一次且属于整个类<br>静态类不能拥有实例构造函数且只能有static成员<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">StaticConstructor</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="title">StaticConstructor</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Static StaticConstructor()"</span>);</span><br><span class="line">                m_ID = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">StaticConstructor</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Normal StaticConstructor()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m_ID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">            //Cant have instance constructor (do not know why static constructor neither)</span><br><span class="line">            static StaticClass()</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine("StaticClass()");</span><br><span class="line">                m_ID = 2;</span><br><span class="line">                m_Type = "Static";</span><br><span class="line">            &#125;</span><br><span class="line">            */</span></span><br><span class="line">            <span class="comment">//Can not non static member</span></span><br><span class="line">            <span class="comment">//public int m_Test = 3; </span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m_ID = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> m_Type = <span class="string">"Static"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">           StaticConstructor sc = <span class="keyword">new</span> StaticConstructor();</span><br><span class="line">           Console.WriteLine(<span class="string">"StaticConstructor::m_ID = "</span> + StaticConstructor.m_ID);</span><br><span class="line"></span><br><span class="line">           Console.WriteLine(<span class="string">"StaticClass::m_ID = "</span> + StaticClass.m_ID);</span><br><span class="line">           Console.WriteLine(<span class="string">"StaticClass::m_Type = "</span> + StaticClass.m_Type);</span><br><span class="line"></span><br><span class="line">           Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Output:<br><img src="/img/CSharp/Static_Constructor_And_Static_Class.PNG" alt="Static_Constructor_And_Static_Class"></p>
<h3 id="Not_supported_multiple_inherit">Not supported multiple inherit</h3><p>C++支持多重继承，Java和C#通过extend多个Interface来实现多重继承<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Base1</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Base1</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       Console.WriteLine(<span class="string">"Base1()"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Base2</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Base2</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       Console.WriteLine(<span class="string">"Base1()"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Base1</span><span class="comment">/*, Base2*/</span><span class="comment">//Not support multiple inherit</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Child</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       Console.WriteLine(<span class="string">"Child()"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">   Child c = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure></p>
<h3 id="Class_member">Class member</h3><p>access qualifier<br>public, private, internal, protected</p>
<p>readonly — only can be initilized in constructor or declaration</p>
<p>property &amp; field<br>property gives more control to field access</p>
<p>accessor privilege — can not be higher than the access privilege that it is belonged to<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Accessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> IntA</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Can not be public due to IntA's access privilege is lower than public</span></span><br><span class="line">        <span class="comment">//public set</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_A = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>member function<br> override key word can hide base function(works with polymorphism)<br> Access base function that has been hiden uses base key word in child class</p>
</li>
<li><p>Interface member<br> all interface member must be public<br> can not use static, virtual, abstract, sealed</p>
</li>
<li><p>Interface implementation<br>explicit implementation — only can be accessed through interface (return type interface.functionanme(para))<br>implicit implementation — can be accessd through both interface and class</p>
</li>
<li><p>partial class definition &amp; partial property<br> can put class member, property, method, field into several files(partial key word)<br> Partial property is always static and withought return value</p>
</li>
</ol>
<h3 id="Struct_&amp;_Class">Struct &amp; Class</h3><p>Struct is value type<br>在栈上分配内存<br>栈回收快速<br>传递的是值<br>转换为reference type会触发boxing引发堆上的额外内存分配<br>Class is reference type<br>在堆上分配内存<br>GC管理<br>传递的是索引<br>那么什么时候定义struct，什么时候定义class了？<br>一下来至MSDN<a href="https://msdn.microsoft.com/en-us/library/ms229017(v=vs.110" target="_blank" rel="external">Choosing Between Class and Struct</a>.aspx)<br>✓ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.<br>如果生命周期短，并被包含在其他类里而已考虑使用struct</p>
<p>X AVOID defining a struct unless the type has all of the following characteristics:<br>    It logically represents a single value, similar to primitive types (int, double, etc.).<br>    It has an instance size under 16 bytes.<br>    It is immutable.<br>    It will not have to be boxed frequently.<br>In all other cases, you should define your types as classes.<br>可以看出只有在数据简单，不可变，不需要频繁boxing的时候才会选择定义struct。</p>
<p>Shallow copy &amp; Deep copy<br>Shallow copy will only copy value type member, reference type member will use original one(System.Object.MemberwiseClone())</p>
<p>Deep copy  will copy all member value instead of reference(implememnt ICloneable::Clone())</p>
<h3 id="Collection_class_(System-Collection)">Collection class (System.Collection)</h3><p>好比C++里的STL里的container<br>Our own collection (extends CollectionBase Class || DictionaryBase)</p>
<p>因为C#没有自带PriorityQueue而是通过基本的List等数据结构来实现，下面是自己实现PriorityQueue，主要是通过堆排序用List来模拟优先队列。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">public class PriorityQueue&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public PriorityQueue()</span><br><span class="line">    &#123;</span><br><span class="line">        mHeap = new Heap&lt;T1, T2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PriorityQueue(Heap&lt;T1, T2&gt; heap)</span><br><span class="line">    &#123;</span><br><span class="line">        mHeap = heap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool Empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return (mHeap.Size() == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Push(KeyValuePair&lt;T1, T2&gt; kvp)</span><br><span class="line">    &#123;</span><br><span class="line">        mHeap.Insert(kvp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KeyValuePair&lt;T1, T2&gt; Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        KeyValuePair&lt;T1, T2&gt; result = mHeap.Top();</span><br><span class="line">        mHeap.RemoveTop();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Size()</span><br><span class="line">    &#123;</span><br><span class="line">        return mHeap.Size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KeyValuePair&lt;T1, T2&gt; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return mHeap.Top(); ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void PrintOutAllMember()</span><br><span class="line">    &#123;</span><br><span class="line">        mHeap.PrintOutAllMember();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Heap&lt;T1, T2&gt; mHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Heap&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;KeyValuePair&lt;T1, T2&gt;&gt; mList;</span><br><span class="line">    private IComparer&lt;T2&gt; mComparer;</span><br><span class="line">    private int mCount;</span><br><span class="line"></span><br><span class="line">    public Heap()</span><br><span class="line">    &#123;</span><br><span class="line">        mList = new List&lt;KeyValuePair&lt;T1, T2&gt;&gt;();</span><br><span class="line">        mComparer = Comparer&lt;T2&gt;.Default;</span><br><span class="line">        mCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Heap(List&lt;KeyValuePair&lt;T1, T2&gt;&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        mList = list;</span><br><span class="line">        mCount = list.Count;</span><br><span class="line">        mComparer = Comparer&lt;T2&gt;.Default;</span><br><span class="line">        BuildingHeap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Size()</span><br><span class="line">    &#123;</span><br><span class="line">        if (mList != null)</span><br><span class="line">        &#123;</span><br><span class="line">            return mCount;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //O(Log(N))</span><br><span class="line">    public void RemoveTop()</span><br><span class="line">    &#123;</span><br><span class="line">        if (mList != null)</span><br><span class="line">        &#123;</span><br><span class="line">            mList[0] = mList[mCount - 1];</span><br><span class="line">            mList.RemoveAt(mCount - 1);</span><br><span class="line">            mCount--;</span><br><span class="line">            HeapifyFromBeginningToEnd(0, mCount - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KeyValuePair&lt;T1, T2&gt; Top()</span><br><span class="line">    &#123;</span><br><span class="line">        if (mList != null)</span><br><span class="line">        &#123;</span><br><span class="line">            return mList[0];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            //No more member</span><br><span class="line">            throw new InvalidOperationException("Empty heap.");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void PrintOutAllMember()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (KeyValuePair&lt;T1, T2&gt; valuepair in mList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(valuepair.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //O(Log(N))</span><br><span class="line">    public void Insert(KeyValuePair&lt;T1, T2&gt; valuepair)</span><br><span class="line">    &#123;</span><br><span class="line">        mList.Add(valuepair);</span><br><span class="line">        mCount++;</span><br><span class="line">        HeapifyFromEndToBeginning(mCount - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调整堆确保堆是最大堆，这里花O(log(n))，跟堆的深度有关</span><br><span class="line">    private void HeapifyFromBeginningToEnd(int parentindex, int length)</span><br><span class="line">    &#123;</span><br><span class="line">        int max_index = parentindex;</span><br><span class="line">        int left_child_index = parentindex * 2 + 1;</span><br><span class="line">        int right_child_index = parentindex * 2 + 2;</span><br><span class="line"></span><br><span class="line">        //Chose biggest one between parent and left&amp;right child</span><br><span class="line">        if (left_child_index &lt; length &amp;&amp; mComparer.Compare(mList[left_child_index].Value, mList[max_index].Value) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            max_index = left_child_index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (right_child_index &lt; length &amp;&amp; mComparer.Compare(mList[right_child_index].Value, mList[max_index].Value) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            max_index = right_child_index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //If any child is bigger than parent, </span><br><span class="line">        //then we swap it and do adjust for child again to make sure meet max heap definition</span><br><span class="line">        if (max_index != parentindex)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(max_index, parentindex);</span><br><span class="line">            HeapifyFromBeginningToEnd(max_index, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //O(log(N))</span><br><span class="line">    private void HeapifyFromEndToBeginning(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (index &gt;= mCount)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (index &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int parentindex = (index - 1) / 2;</span><br><span class="line">            if (mComparer.Compare(mList[parentindex].Value, mList[index].Value) &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(parentindex, index);</span><br><span class="line">                index = parentindex;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过初试数据构建最大堆</span><br><span class="line">    ////O(N*Log(N))</span><br><span class="line">    private void BuildingHeap()</span><br><span class="line">    &#123;</span><br><span class="line">        if (mList != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = mList.Count / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                //1.2 Adjust heap</span><br><span class="line">                //Make sure meet max heap definition</span><br><span class="line">                //Max Heap definition:</span><br><span class="line">                // (k(i) &gt;= k(2i) &amp;&amp; k(i) &gt;= k(2i+1))   (1 &lt;= i &lt;= n/2)</span><br><span class="line">                HeapifyFromBeginningToEnd(i, mList.Count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ////O(N*log(N))</span><br><span class="line">    private void HeapSort()</span><br><span class="line">    &#123;</span><br><span class="line">        if (mList != null)</span><br><span class="line">        &#123;</span><br><span class="line">            //Steps:</span><br><span class="line">            // 1. Build heap</span><br><span class="line">            // 1.1 Init heap</span><br><span class="line">            // 1.2 Adjust heap</span><br><span class="line">            // 2. Sort heap</span><br><span class="line"></span><br><span class="line">            //1. Build max heap</span><br><span class="line">            // 1.1 Init heap</span><br><span class="line">            //Assume we construct max heap</span><br><span class="line">            BuildingHeap();</span><br><span class="line">            //2. Sort heap</span><br><span class="line">            //这里花O(n)，跟数据数量有关</span><br><span class="line">            for (int i = mList.Count - 1; i &gt; 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                //swap first element and last element</span><br><span class="line">                //do adjust heap process again to make sure the new array are still max heap</span><br><span class="line">                Swap(i, 0);</span><br><span class="line">                //Due to we already building max heap before,</span><br><span class="line">                //so  we just need to adjust for index 0 after we swap first and last element</span><br><span class="line">                HeapifyFromBeginningToEnd(0, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write("mList == null");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Swap(int id1, int id2)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyValuePair&lt;T1, T2&gt; temp;</span><br><span class="line">        temp = mList[id1];</span><br><span class="line">        mList[id1] = mList[id2];</span><br><span class="line">        mList[id2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;KeyValuePair&lt;int, float&gt;&gt; list = new List&lt;KeyValuePair&lt;int, float&gt;&gt;();</span><br><span class="line">    list.Add(new KeyValuePair&lt;int, float&gt;(3, 1.0f));</span><br><span class="line">    list.Add(new KeyValuePair&lt;int, float&gt;(2, 5.0f));</span><br><span class="line">    list.Add(new KeyValuePair&lt;int, float&gt;(1, 3.0f));</span><br><span class="line">    list.Add(new KeyValuePair&lt;int, float&gt;(6, 4.0f));</span><br><span class="line">    list.Add(new KeyValuePair&lt;int, float&gt;(5, 2.0f));</span><br><span class="line">    list.Add(new KeyValuePair&lt;int, float&gt;(4, 6.0f));</span><br><span class="line"></span><br><span class="line">    Heap&lt;int,float&gt; heap = new Heap&lt;int,float&gt;(list);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;int,float&gt; pq = new PriorityQueue&lt;int,float&gt;(heap);</span><br><span class="line"></span><br><span class="line">    pq.PrintOutAllMember();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("------------------------pq.Push(new KeyValuePair&lt;int, float&gt;(0, 0.0f));");</span><br><span class="line"></span><br><span class="line">    pq.Push(new KeyValuePair&lt;int, float&gt;(0, 0.0f));</span><br><span class="line"></span><br><span class="line">    pq.PrintOutAllMember();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("------------------------pq.Pop();");</span><br><span class="line"></span><br><span class="line">    pq.Pop();</span><br><span class="line"></span><br><span class="line">    pq.PrintOutAllMember();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine("------------------------pq.Top();");</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(pq.Top().ToString());</span><br><span class="line"></span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:<br><img src="/img/CSharp/PriorityQueue_Study.PNG" alt="PriorityQueue_Study"></p>
<p>堆排序构造有序堆的时间复杂度是O(N * Log(N))<br>但插入和移除操作都是O(Log(N))</p>
<p><a href="http://tonytang1990.github.io/2015/07/11/Sort-Algorithm/">排序算法参考</a></p>
<h3 id="Method">Method</h3><p>关于Method这里主要讲两点：</p>
<ol>
<li>Extension Methods<br>“It allows you to define a static method that you can invoke using instance method syntax.”(Extension Methods最主要的好处就在于当你无法给特定类或结构定义方法的时候，你可以通过定义extension method来为该类或结构添加方法，使用的时候就跟在类里定义方法一样，通过实例就能调用。)<br>定义Extension Method首先必须定义在一个静态类里，且方法为静态方法，并且第一个参数类型前要加this关键词，this后面跟的就是我们要extension的类。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringBuilderExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int32 <span class="title">Indexof</span>(<span class="params"><span class="keyword">this</span> StringBuilder sb, Char <span class="keyword">value</span></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Int32 index = <span class="number">0</span>; index &lt; sb.Length; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb[index] == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello. My name is Tony."</span>);</span><br><span class="line">    Int32 index = sb.Indexof(<span class="string">'T'</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"sb.Indexof('T') = "</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Output:<br><img src="/img/CSharp/ExtensionMethods.PNG" alt="ExtensionMethods"><br>调用Extension method跟Compiler如何去寻找方法编译有关，具体见《CLR via C#》 — Methods的Extension Methods章节<br>定义Extension Methods需要注意一下几点：</p>
<pre><code><span class="number">1</span>. 只能定义在非模板静态类里。
<span class="number">2</span>. 定义Extension Methods的类必须位于file <span class="function"><span class="title">scope</span><span class="params">(不能被其他类包含)</span></span>
<span class="number">3</span>. 必须包含添加Extension Methods的类的<span class="function"><span class="title">namespace</span><span class="params">(为了避免检查所有文件去找extension methods)</span></span>
<span class="number">4</span>. Extension Methods应该少用，会造成versioning <span class="function"><span class="title">problem</span><span class="params">(未来可能添加相同方法到类里，不同版本的调用会出现不同的表现)</span></span>。
</code></pre><ol>
<li>Partial Methods<br>首先得知道我们为什么需要Partial Methods？<ol>
<li>Override去重写virtual方法的时候要求父类不能是Sealed，不能为sealed class或value type重写方法</li>
<li>无需为了重写个别方法而单独定义一个类<br>使用Partial Methods在partial class里定义partial方法前加partial关键字<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            OnNameChanging(<span class="keyword">value</span>.ToUpper());</span><br><span class="line">            mName = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//This defining-partial-method-declaration is called before changing the mName field</span></span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">OnNameChanging</span>(<span class="params">String <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">OnNameChanging</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">value</span></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Base::OnNameChanging(&#123;0&#125;)"</span>, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Base bs = <span class="keyword">new</span> Base();</span><br><span class="line">    bs.Name = <span class="string">"Tony"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>Output:<br><img src="/img/CSharp/PartialMethods.PNG" alt="PartialMethods"><br>使用Partial Methods需要注意以下几点：</p>
<pre><code><span class="number">1</span>. 只能在<span class="keyword">Partial</span> <span class="keyword">class</span> <span class="keyword">or</span> Struct里定义
<span class="number">2</span>. <span class="keyword">Partial</span> <span class="function"><span class="keyword">Method</span>必须返回<span class="title">void</span>，并且不能有<span class="title">parameter</span>有<span class="title">out</span>关键词修饰
3. <span class="title">Partial</span> <span class="title">Method</span>必须和原方法签名一样
4. 如果<span class="title">Partial</span> <span class="title">Method</span>没有实现，<span class="title">Delegate</span>不能指向该<span class="title">partial</span> <span class="title">method</span>
5. <span class="title">Partial</span> <span class="title">Methods</span>永远是<span class="title">private</span>的</span>
</code></pre><h3 id="Comparasion">Comparasion</h3><ol>
<li><p>Type comparasion<br>System.Object.GetType()<br>&amp;&amp;<br>typeof()<br>&amp;&amp;<br>is operator — is specific type or type can be cast</p>
<ol>
<li>boxing — cast value type into System.Object type(shollow copy) or interface type that is implemented by value type</li>
<li>unboxing — boxing reverse process</li>
</ol>
</li>
<li><p>Value comparasion<br>operator overloading — must be static<br>IComparable — compare object’s data with the same type<br>&amp;&amp;<br>IComparer — compare two object with different type or the same type</p>
</li>
</ol>
<h3 id="Conversion">Conversion</h3><p>Conversion operator<br>implici<br>explicit<br>e.g.<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">B</span>(<span class="params">A a</span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">A</span>(<span class="params">B b</span>)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>as operator</p>
<p><operand> as <type><br>Suit case</type></operand></p>
<ol>
<li>operand type is type</li>
<li>operand type can be casted into type implicitly</li>
<li>operand can be boxing into type</li>
</ol>
<h3 id="Generics">Generics</h3><p>C++里是template实现<br>System.Collections.Generic<br>value type can not be initilized with null<br>Problem</p>
<ol>
<li>null (value type or reference type)<ol>
<li>default key word — if it is reference type, initilized with null. otherwise use default value</li>
</ol>
</li>
<li>type<ol>
<li>constraining<br> where key words<br> e.g.<br> class A<t>: where T:B 9( T must inherite from B)<br>Code e.g.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">namespace CSharpStudy</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        //Can not instantiation with int when where T1 : class </span><br><span class="line">        //public class GenericClass&lt;T1&gt; where T1 : class</span><br><span class="line">        public class GenericClass&lt;T1&gt; : IEnumerable&lt;T1&gt; where T1 : struct</span><br><span class="line">        &#123;</span><br><span class="line">            private List&lt;T1&gt; m_Member = new List&lt;T1&gt;();</span><br><span class="line"></span><br><span class="line">            public GenericClass()</span><br><span class="line">            &#123;</span><br><span class="line">                //use T1's default value</span><br><span class="line">                //m_Member.Add(default(T1));</span><br><span class="line">            &#125;</span><br><span class="line">            public List&lt;T1&gt; GetMember</span><br><span class="line">            &#123;</span><br><span class="line">                get</span><br><span class="line">                &#123;</span><br><span class="line">                    return m_Member;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            public IEnumerator&lt;T1&gt; GetEnumerator()</span><br><span class="line">            &#123;</span><br><span class="line">                return m_Member.GetEnumerator();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">            &#123;</span><br><span class="line">                return m_Member.GetEnumerator();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public static implicit operator List&lt;T1&gt;(GenericClass&lt;T1&gt; gc)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;T1&gt; result = new List&lt;T1&gt;();</span><br><span class="line">                foreach (T1 i in gc)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.Add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public static GenericClass&lt;T1&gt; operator +(GenericClass&lt;T1&gt; gc, List&lt;T1&gt; l)</span><br><span class="line">            &#123;</span><br><span class="line">                GenericClass&lt;T1&gt; result = new GenericClass&lt;T1&gt;();</span><br><span class="line">                foreach (T1 m in gc)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.GetMember.Add(m);</span><br><span class="line">                &#125;</span><br><span class="line">                foreach (T1 m in l)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!result.GetMember.Contains(m))</span><br><span class="line">                    &#123;</span><br><span class="line">                        result.GetMember.Add(m);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">           //Nullable problem, </span><br><span class="line">           //value type can not be initiated with null</span><br><span class="line">           //int normalint = null;</span><br><span class="line">           System.Nullable&lt;int&gt; nullableint = null;</span><br><span class="line">           //nullable</span><br><span class="line">           int? nullalbleint = null;</span><br><span class="line">           int? result = nullalbleint ?? 5;</span><br><span class="line">           Console.WriteLine("result = " + result);</span><br><span class="line">           List&lt;int&gt; list = new List&lt;int&gt;(2);</span><br><span class="line">           list.Add(1);</span><br><span class="line">           list.Add(2);</span><br><span class="line">           foreach (int i in list)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine("list value = " + i);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           GenericClass&lt;int&gt; gc = new GenericClass&lt;int&gt;();</span><br><span class="line">           Console.WriteLine("gc.m_Member = " + gc.GetMember);</span><br><span class="line"></span><br><span class="line">           GenericClass&lt;int&gt; gc2 = new GenericClass&lt;int&gt;();</span><br><span class="line">           gc2.GetMember.Add(11);</span><br><span class="line">           gc2.GetMember.Add(111);</span><br><span class="line">           GenericClass&lt;int&gt; gc3 = new GenericClass&lt;int&gt;();</span><br><span class="line">           gc3.GetMember.Add(11);</span><br><span class="line">           gc3.GetMember.Add(22);</span><br><span class="line">           gc3.GetMember.Add(222);</span><br><span class="line"></span><br><span class="line">           gc = gc2 + gc3;</span><br><span class="line">           foreach (int i in gc)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine("gc member = " + i);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</t></li>
</ol>
</li>
</ol>
<p>Output:<br><img src="/img/CSharp/Generic.PNG" alt="Generic"></p>
<p>Variance (变体)</p>
<ol>
<li>Convariance — 协变 out key word<br>主要用于Interface和delegate的返回类型或者参数类型的隐士转换（子类到父类）</li>
<li>Contravariance — 抗变 int key word<br>与协变相反（父类到子类）<br>Code e.g.<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Covariance</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListAnimals</span>(<span class="params">IEnumerable&lt;Animal&gt; animals</span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">foreach</span> (Animal animal <span class="keyword">in</span> animals)</span><br><span class="line">       &#123;</span><br><span class="line">          Console.WriteLine(animal.ToString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FeeAnimal</span>(<span class="params">Func&lt;Animal&gt; animalCreator</span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> animal = animalCreator();</span><br><span class="line">       Console.WriteLine(<span class="string">"animal.name = "</span> + animal.Name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FeeAnimal</span>(<span class="params">Func&lt;Cow&gt; animalCreator</span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> animal = animalCreator();</span><br><span class="line">       Console.WriteLine(<span class="string">"animal.name = "</span> + animal.Name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> Cow <span class="title">CreateCow</span>(<span class="params"></span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Cow(<span class="string">"DelegateCow"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Contravariance</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FeeAnimal</span>(<span class="params">Animal animal</span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       Console.WriteLine(<span class="string">"FeeAnimal:"</span> + animal.Name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">Action&lt;Cow&gt; cact</span>)</span><br><span class="line">   </span>&#123;</span><br><span class="line">       cact(<span class="keyword">new</span> Cow(<span class="string">"ExecuteCow"</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Covariance</span></span><br><span class="line">   List&lt;Cow&gt; cows = <span class="keyword">new</span> List&lt;Cow&gt;();</span><br><span class="line">   cows.Add(<span class="keyword">new</span> Cow(<span class="string">"Cow1"</span>));</span><br><span class="line">   ListAnimals(cows);</span><br><span class="line"></span><br><span class="line">   FeeAnimal(CreateCow);</span><br><span class="line">   Func&lt;Cow&gt; cFunc = CreateCow;</span><br><span class="line">   Func&lt;Animal&gt; aFunc = cFunc;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Contravariance</span></span><br><span class="line">   Action&lt;Animal&gt; aAct = FeeAnimal;</span><br><span class="line">   Action&lt;Cow&gt; cAct = aAct;</span><br><span class="line"></span><br><span class="line">   Execute(aAct);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Output:<br><img src="/img/CSharp/Variance_Contravariance.PNG" alt="Variance_Contravariance"></p>
<p>Note:<br>C++是通过编译器检测出模板使用的特定类型<br>C#是运行时进行</p>
<h3 id="Hosting,_AppDomain,_Assembly,_Reflection">Hosting, AppDomain, Assembly, Reflection</h3><p>这一章节主要是学习关于Assembly Loading和Reflection技术。<br>在学习Assembly Loading和Reflection之前，我们需要了解Hosting，AppDomain的概念。</p>
<h4 id="Hosting">Hosting</h4><p>以下英文内容来至《CLR via C#》<br>Hosting allows any application to use the features of the common language runtime(CLR). Furthermore, hosting allows applications the ability to offer customization and extensibility via programming.<br>Extensibility means that third-party code will be running inside your process.</p>
<p>The hosting application can call methods defined by ICLRMetaHost interface to:</p>
<ol>
<li>Set Host managers. Tell the CLR that the host wants to be involved in making decisions related to memory allocations, thread scheduling/synchronization, assembly loading, and more. The host can also state that it wants notifications of garbage collection starts and stops and when certain operations time out.</li>
<li>Get CLR managers. Tell the CLR to prevent the use of some classes/members. In addition, the host can tell which code can and can’t be debugged and which methods in the host should be called when a special event—such as an AppDomain unload, CLR stop, or stack overflow exception—occurs.</li>
<li>Initialize and start the CLR.</li>
<li>Load an assembly and execute code in it.</li>
<li>Stop the CLR, thus preventing any more managed code from running in the Windows process.</li>
</ol>
<p>Hosting(allows any application to offer CLR features) Benifits:</p>
<ol>
<li>Programming can be done in any programming language.</li>
<li>Code is just-in-time (JIT)–compiled for speed (versus being interpreted).</li>
<li>Code uses garbage collection to avoid memory leaks and corruption.</li>
<li>Code runs in a secure sandbox.</li>
<li>The host doesn’t need to worry about providing a rich development environment. The<br>host makes use of existing technologies: languages, compilers, editors, debuggers, profilers, and more.<br>从上面所有内容可以看出Hosting可以让我们去利用CLR的特性，我们而已通过Host去设定很多CLR相关的设定(比如GC,Memory Manager……)，初始化CLR，创建出默认的AppDomain，通过CLR去加载Assemly到AppDomain然后执行。</li>
</ol>
<h4 id="AppDomain">AppDomain</h4><p>AppDomain allows third-party untrusted code to run in an existing proceess, and the CLR guarantees that the data structures, code, and security context will not be exploited or compromised.(AppDomain允许不可信的代码在当前进程执行，CLR会去确保数据结构，代码等安全问题)<br>AppDomain和CLR的关系：<br>“AppDomains are a CLR feature.”</p>
<p>“When the CLR COM server initializes, it creates an AppDomain. An AppDomain is a logical container for a set of assemblies. The first AppDomain created when the CLR is initialized is called the default AppDomain; this AppDomain is destroyed only when the Windows process terminates.”(AppDomain是一个assemblies集合的容器，当CLR初始化的时候会创建默认的AppDOmain,这个AppDomain只能在程序结束的时候被终止)</p>
<p>The whole purpose of an AppDomain is to provide isolation. Here are the specific features offered by an AppDomain(AppDomain的主要目的是为了实现程序隔离):</p>
<ol>
<li>Objects created by code in one AppDomain cannot be accessed directly by code in another AppDomain When(确保不同AppDomain里的Object不会被其他AppDomain访问)</li>
<li>AppDomains can be unloaded(AppDomain可以被unload)</li>
<li>AppDomains can be individually secured(通过设定AppDomain的permission用于确保assembly的一些权限)</li>
<li>AppDomains can be individually configured(设置AppDomian的配置，影响如何去加载Assemlies等)</li>
</ol>
<p>这里提到AppDomain的程序隔离功能，那就不得不说一下Process了。<br>“Process isolation prevents security holes, data corruption, and other<br>unpredictable behaviors from occurring, making Windows and the applications running<br>on it robust.”<br>这里Process可以理解为进程面上的程序隔离，而AppDomain可以理解为进程内的程序隔离(一个进程可以创建多个AppDomain)<br>让我们看一下程序是如何在Process,AppDomain还有CLR下工作的:<br><img src="/img/CSharp/CLRAppDomainProcessRelationship.PNG" alt="CLRAppDomainProcessRelationship"><br>可以看出一个Process下创建了多个AppDomain，每一个AppDomain加载了特定的Assembly，每一个AppDomain有自己的LoaderHeap，每一个LoaderHeap记录了该AppDomain所访问过的type，当调用type的method的时候，IL code会被JIT运行时编译到对应的机器代码执行。<br>普通的AppDomain之间的Assembly是完全隔离的，所以就算多个AppDomain引用了同一个Assembly，他们也不会共享数据和内存。<br>但上图有一个比较特殊的AppDomain，叫做Domain-Neutrl Assemblies。<br>这个Domain的主要目的是共享一些通用的Assemblys，加载在这个AppDomian下的Assemblys可以被所有的AppDomains访问。<br>虽然Assembly在AppDomain之间是完全隔离的，但不同AppDomain创建的objects还是可以相互访问的。<br>让我们看看不同AppDomain创建的objeccts如何相互访问的：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Runtime;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpDeepStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="preprocessor">#<span class="keyword">region</span> Hosting and AppDomain Study</span></span><br><span class="line">        <span class="comment">// Instances can be marshaled-by-reference across AppDomain boundaries</span></span><br><span class="line">        [Serializable]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByRefType</span> : <span class="title">MarshalByRefObject</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MarshalByRefType</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0&#125; ctor running in &#123;1&#125;"</span>, <span class="keyword">this</span>.GetType().ToString(), Thread.GetDomain().FriendlyName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Executing in "</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MarshalByValType <span class="title">MethodWithReturn</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Executing in "</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">                MarshalByValType t = <span class="keyword">new</span> MarshalByValType();</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> NonMarshalableType <span class="title">MethodArgAndReturn</span>(<span class="params">String callingdomainname</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Calling from &#123;0&#125; to &#123;1&#125;"</span>, callingdomainname, Thread.GetDomain().FriendlyName);</span><br><span class="line">                NonMarshalableType t = <span class="keyword">new</span> NonMarshalableType();</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instances can be marshaled-by-value across AppDomain boundaries</span></span><br><span class="line">        [Serializable]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MarshalByValType</span> : <span class="title">Object</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> DateTime m_CreationTime = DateTime.Now;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MarshalByValType</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0&#125; ctor running in &#123;1&#125;, Created on &#123;2:D&#125;"</span>, <span class="keyword">this</span>.GetType().ToString(), Thread.GetDomain().FriendlyName, m_CreationTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> String <span class="title">ToString</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m_CreationTime.ToLongDateString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instances cannot be marshaled across AppDomain boundaries</span></span><br><span class="line">        <span class="comment">// [Serializable]</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">NonMarshalableType</span> : <span class="title">Object</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">NonMarshalableType</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Excuting in "</span> + Thread.GetDomain().FriendlyName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Marshalling</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">//Obtain current thread AppDomain</span></span><br><span class="line">            AppDomain currentthreadappdomian = Thread.GetDomain();</span><br><span class="line">            String callingdomainname = currentthreadappdomian.FriendlyName;</span><br><span class="line">            Console.WriteLine(<span class="string">"currentthreadappdomian.name = "</span> + callingdomainname);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Get the assembly that contains the main method</span></span><br><span class="line">            Assembly mainassembly = Assembly.GetEntryAssembly();</span><br><span class="line">            String exeassembly = mainassembly.FullName;</span><br><span class="line">            Console.WriteLine(<span class="string">"Assembly's that contains main method name is "</span> + exeassembly);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Accessing Objects Across AppDomain Boundaries</span></span><br><span class="line">            <span class="comment">//Cross-AppDomain Communication using marshal-by-reference</span></span><br><span class="line">            AppDomain ad2 = <span class="keyword">null</span>;</span><br><span class="line">            ad2 = AppDomain.CreateDomain(<span class="string">"AD2"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            MarshalByRefType mbrt = <span class="keyword">null</span>;</span><br><span class="line">            mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeassembly, <span class="keyword">typeof</span>(MarshalByRefType).FullName);</span><br><span class="line">            Console.WriteLine(<span class="string">"Type = &#123;0&#125;"</span>, mbrt.GetType());</span><br><span class="line">            <span class="comment">//Prove that we got a reference to a proxy object</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Is proxy = &#123;0&#125;"</span>, RemotingServices.IsTransparentProxy(mbrt));</span><br><span class="line">            <span class="comment">//Call method in the AppDomain owning the objects</span></span><br><span class="line">            mbrt.SomeMethod();</span><br><span class="line">            <span class="comment">//Unload the new AppDomian</span></span><br><span class="line">            AppDomain.Unload(ad2);</span><br><span class="line">            <span class="comment">//try access mbrt after we unload AppDomain it owned</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                mbrt.SomeMethod();</span><br><span class="line">                Console.WriteLine(<span class="string">"Successful call SomeMehtod()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AppDomainUnloadedException)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Failed call SomeMethod()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Cross-AppDomain Communication using Marshal-by-value</span></span><br><span class="line">            <span class="comment">//Create new AppDomain</span></span><br><span class="line">            ad2 = AppDomain.CreateDomain(<span class="string">"AD3"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeassembly, <span class="keyword">typeof</span>(MarshalByRefType).FullName);</span><br><span class="line"></span><br><span class="line">            MarshalByValType mbvt = mbrt.MethodWithReturn();</span><br><span class="line">            <span class="comment">//Prove that we did NOT get a reference to a proxy object</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Is Proxy=&#123;0&#125;"</span>, RemotingServices.IsTransparentProxy(mbvt));</span><br><span class="line">            <span class="comment">//Try call method on real object</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Returned object created "</span> + mbvt.ToString());</span><br><span class="line">            <span class="comment">//Unload AppDomain again</span></span><br><span class="line">            AppDomain.Unload(ad2);</span><br><span class="line">            <span class="comment">//try access method on real object again</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Returned object created "</span> + mbvt.ToString());</span><br><span class="line">                Console.WriteLine(<span class="string">"Successful call."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AppDomainUnloadedException)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Failed call."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Cross-AppDomain Communication Using non-marshalable type</span></span><br><span class="line">            ad2 = AppDomain.CreateDomain(<span class="string">"AD4"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//Load assembly into the new AppDoamin</span></span><br><span class="line">            mbrt = (MarshalByRefType)ad2.CreateInstanceAndUnwrap(exeassembly, <span class="keyword">typeof</span>(MarshalByRefType).FullName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//call the object method to get non-marshalable object</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                NonMarshalableType nmt = mbrt.MethodArgAndReturn(callingdomainname);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (System.Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(e.ToString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> Hosting and AppDomain Study</span></span><br><span class="line">            Marshalling();</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/CrossAppDomainCommunicationOutPut.PNG" alt="CrossAppDomainCommunicationOutPut"><br>上面的测试主要是针对下面三种情况：</p>
<ol>
<li>Cross-AppDomain Communication Using Marshal-by-Reference<br>从上面可以看出当我们Marshal-by-Reference between AppDomain的时候，我们需要继承至MarshalByRefObject。(通过RemotingServices.IsTransparentProxy检查是否是Proxy)<br>底层是通过在Destination AppDomain生成的Proxy Type信息，其中还生成了instane fields去记录了哪一个AppDomain真正拥有这个type，如何在该AppDomain下找到这个real object去实现Reference的。<br>这样就说得通当我们关掉创建Prox Type的AppDomain后，再次通过Prox Type调用就无法通过了，因为通过调用AppDomain.Unload(),所有在该AppDomain里的assemblies和通过assemblies里的信息创建的对象都被释放回收了。<br>Note:<br>“although you can access fields of a type derived from MarshalByRefObject, the performance is particularly bad because the CLR really ends up calling methods to perform the field access.”</li>
<li>Cross-AppDomain Communication Using Marshal-by-Value<br>当我们Marshal-by-Value时不需要继承至MarshalByRefObject，但需要确保MarshalByValType是[Serializable]的。<br>因为底层实现是通过序列化和反序列化实现Destination AppDomain加载并生成对应type信息。</li>
<li>Cross-AppDomain Communication Using Non-Marshalable Types<br>最后一个是因为我们采用Marshal-by-Value但却没有把NonMarshalableType设置成[Serializable]导致在Serialize NonMarshalableType到Destination AppDomain的时候抛异常。<br>针对AppDomain问题我没有深入学习，如有不对之处欢迎指出，详情请参考《CLR via C#》<br>Hosting,CLR,AppDomain,Process,Assemly关系作用总结：<br>Hosting使我们可以去利用CLR的特性，通过Host可以设定很多CLR相关的设定(比如GC,Memory Manager……)。<br>当CLR初始化完成后，会创建出默认的AppDomain。<br>通过CLR去加载Assemly到AppDomain然后执行。<br>一个Process可以有多个AppDomian。<br>每个AppDomain有自己的Loader Heap去记录加载到AppDomain里的Type信息。<br>当调用Type的method的时候，IL code会被JIT运行时编译到对应的机器代码执行。<br>普通的AppDomain之间的Assembly是完全隔离的，所以就算多个AppDomain引用了同一个Assembly，他们也不会共享数据和内存。<br>但加载在这个Domain-Neutrl Assemblies AppDomian下的Assemblys可以被所有的AppDomains访问。<br>虽然Assembly在AppDomain之间是完全隔离的，但不同AppDomain创建的objects还是可以通过Marshal-by-Value和Marshal-by-Reference方式相互访问的。<br>关于AppDomain的更多内容参考《CLR via C#》 — CLR Hosting and AppDomains章节(e.g. AppDomain Monitoring, How Hosts Use AppDomians……)<br>Note:<br>在Windows上默认的AppDomain的名字是是<em>*</em>.exe(执行的程序)</li>
</ol>
<p>了解了AppDomain的基本概念，接下来让我们看看关于Assembly Loading:</p>
<h4 id="Assembly_Loading">Assembly Loading</h4><p>Assembly是一个包含类型信息，方法信息，成员信息，程序名称，版本号，自我描述，文件关联关系和文件位置等信息的一个集合。<br>System.Reflection.Assembly.Load — 加载Assembly到AppDomain。(相比System.AppDomain.Load, Prefer use System.Reflection.Assembly)<br>System.Reflection.Assembly.LoadFrom — 加载指定路径的Assembly到AppDomain，这里也可以指定URL<br>System.Reflection.Assembly.ReflectionOnlyLoad or ReflectionOnlyLoadFrom — 确保只加载Assembly不会去执行里面的任何代码(只用于获取Assembly里的一些相关信息)。用这两个方法需要注册AppDomain’s ReflectionOnlyAssemblyResolve<br>event去手动加载索引的assemblies<br>既然我们知道了如何加载Assembly，也知道了Assembly包含了我们程序去创建实例所需要的所有信息，那么我们如何动态的使用Assembly里的信息去创建实例了，答案是反射。<br>System.Reflection给我们提供了很多方法可以去访问Assembly里的fields，methods，properties等信息。<br>通过这些信息，我们可以制作像ILDasm.exe这样的反编译工具，因为通过有些类我们可以得到方法的IL指令数据。<br>这也就是我们为什么能通过System.Reflection.Emit去动态创建类的原因(使用IL指令反向构建方法，类等)。参见<a href="http://tonytang1990.github.io/2015/07/15/Unity-Study/#AOT_&amp;_JIT">AOT &amp; JIT</a><br>那么接下来让我们看看Reflection：</p>
<h4 id="Reflection">Reflection</h4><p>这里不得不提一个Reflection使用的典型案列，那就是Serialization，序列化反序列是通过reflection去获取类型信息去存储和构建实例的。<br>具体关于Serialization后续后讲到。<br>反射最强大的地方就在于可以在运行时动态创建和使用一些类型，但这些类型我们在编译时期是不可知的。<br>但缺点如下：</p>
<ol>
<li>Reflection prevents type safety at compile time(因为是运行时才动态创建，所以编译时期就无法确保类型安全)</li>
<li>Reflection is slow(反射很慢，因为我们需要在运行时动态去获取类型信息去动态创建)<br>反射慢的主要原因就在于运行时去访问获取类型信息，所以我们应该尽可能的使用在编译时期就能知道类型信息的方式。<br>比如：<br>通过实现一个继承至父类或接口的类，通过多态的方式去调用方法。(编译时期就知道该调用哪个方法)<br>那么接下来让我们看看如何使用反射去访问类型信息并调用里面的方法。<br>首先我们看看如何去获取Assembly里的一些类型信息：<br>首先我们创建一个只包含了几个类信息的dll<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpDLL</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSharpDLLPublicClass1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSharpDLLPublicClass2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CSharpDLLSealedClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后通过Assembly.Load去加载并查看里面的Type信息<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadAssemAndShowPublicTypes</span>(<span class="params"><span class="keyword">string</span> assemblename</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Assembly a = Assembly.LoadFrom(assemblename);</span><br><span class="line">    <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> a.GetExportedTypes())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(t.FullName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    LoadAssemAndShowPublicTypes(<span class="string">"CSharpDLL.dll"</span>);</span><br><span class="line"> </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/ExportPublicAssemblyType.PNG" alt="ExportPublicAssemblyType"><br>可以看出除了sealed的CSharpDLLSealedClass都成功打印出来了。<br>那么这里就有个疑问了，Type是个什么类型?<br>“Represents type declarations: class types, interface types, array types……A System. Type object represents a type reference”<br><a href="https://dotnetcademy.net/Learn/4/Pages/3" target="_blank" rel="external">A TypeInfo instance contains the definition for a Type, and a Type now contains only reference data. </a><br>可以看出TypeInfo包含类型定义,Type只存储类型定义的索引。<br>我么可以通过以下方法获取Type：</p>
<ol>
<li>System.Type.GetType</li>
<li>System.Type.ReflectionOnlyGetType — 只能通过reflect调用里面的方法</li>
<li>System.Reflection.TypeInfo.GetDeclaredNestedType</li>
<li>System.Reflection.Assemly.GetType or ExportedTypes or DefinedTypes</li>
<li>typeof operator — early-bound<br>TypeInfo包含了类型的大量信息，我们可以通过System.Reflection.TrospectionExtensions的GetTypeInfo去转换Type到TypeInfo(TypeInfo在.NET 4.5才开始支持)，然后通过TypeInfo去获取Type的相关信息。<br>也可以通过调用AsType把TypeInfo转回Type。</li>
</ol>
<p>现在我们得到了Type，我们而已通过一下方法使用Type去构建一个实例对象：</p>
<ol>
<li>System.Activator.CreateInstance</li>
<li>System.Activator.CreateInstanceFrom</li>
<li>System.AppDomain.CreateInstance or ……</li>
<li>System.Reflection.ConstructorInfo.Invoke<br>上述方法不能用于创建array和delegate：<br>创建array使用Array.CreateInstance<br>创建delegate使用MethodInfo.CreateDelegate<br>当创建泛型实例的时候，我们需要先调用Type.MakeGenericType去设置泛型类的T参数，然后返回的Type是泛型类的Type了，然后通过前面讲到的方法就能创建出泛型类实例了。<br>一下是创建一个泛型类实例的过程：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type closedtype = opentype.MakeGenericType(<span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">int</span>));</span><br><span class="line">Object o = Activator.CreateInstance(closedtype);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(o.GetType());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/img/CSharp/CreateGenericInstance.PNG" alt="CreateGenericInstance"><br>知道了如何通过Type创建实例对象，接下来让我们看看如何通过反射去访问Type里的所有信息：<br>在开始之前让我们先来看看Reflection里的类是如何应对到Type里的各个信息里的(e.g. Method, Field, Property, Event……)<br><img src="/img/CSharp/ClassHierchyOfReflection.PNG" alt="ClassHierchyOfReflection"><br>MemberInfo代表了Type里的所有成员信息，FieldInfo,PropertyInfo,EventInfo,MethodBase等都分别对应了类定义里的成员，属性，事件，方法等信息<br>接下来让我们修改一下之前定义的CSharpDLL.dll里的代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpDLL</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSharpDLLPublicClass1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">CSharpDLLPublicClass1</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                mPublicClass1ID = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CSharpDLLPublicClass1Method</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"CSharpDLLPublicClass1Method() called"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> PublicCLass1ID</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> mPublicClass1ID;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">set</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mPublicClass1ID = <span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> mPublicClass1ID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后通过Reflection里的方法，把CSharpDLL.dll里的所有public的类型定义信息打印出来<br>因为Type.GetTypeInfo()在.NET 4.5才开始支持，所以这里我通过Type.GetMembers()去访问public的成员信息并打印而非所有的成员信息<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PritAllTypeInfoInAssembly</span>(<span class="params"><span class="keyword">string</span> assemblename</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Assembly a = Assembly.LoadFrom(assemblename);</span><br><span class="line">    Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;.Fullname = &#123;1&#125;"</span>,assemblename,a.FullName));</span><br><span class="line">    <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> a.GetExportedTypes())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"Type = &#123;0&#125;"</span>, t));</span><br><span class="line">        <span class="keyword">foreach</span> (MemberInfo mi <span class="keyword">in</span> t.GetMembers())</span><br><span class="line">        &#123;</span><br><span class="line">            String typename = String.Empty;</span><br><span class="line">            <span class="keyword">if</span> (mi <span class="keyword">is</span> Type)</span><br><span class="line">            &#123;</span><br><span class="line">                typename = <span class="string">"Type"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">mi <span class="keyword">is</span> FieldInfo</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                typename = <span class="string">"FieldInfo"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">mi <span class="keyword">is</span> MethodInfo</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                typename = <span class="string">"MethodInfo"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">mi <span class="keyword">is</span> ConstructorInfo</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                typename = <span class="string">"ConstructorInfo"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">mi <span class="keyword">is</span> PropertyInfo</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                typename = <span class="string">"PropertyInfo"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">mi <span class="keyword">is</span> EventInfo</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                typename = <span class="string">"EventInfo"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; : &#123;1&#125;"</span>, typename, mi.ToString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    PritAllTypeInfoInAssembly(<span class="string">"CSharpDLL.dll"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/PrintOutPublicMemberInfo.PNG" alt="PrintOutPublicMemberInfo"><br>这样一来就打印出了所有public的MemberInfo<br>下面是Reflection访问程序信息的层次结构图：<br><img src="/img/CSharp/ReflectionClassHierarchical.PNG" alt="ReflectionClassHierarchical"><br>既然能够访问特定的类型信息了，那么通过reflection去访问调用就易如反掌了：<br>我们只需通过构造函数构建一个实例，然后通过Invoke方法传递实例对象就能调用对应方法了。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReflectionInvoke</span>(<span class="params"><span class="keyword">string</span> assemblename, <span class="keyword">string</span> classname, <span class="keyword">string</span> methodname</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Assembly a = Assembly.LoadFrom(assemblename);</span><br><span class="line">    Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;.Fullname = &#123;1&#125;"</span>,assemblename,a.FullName));</span><br><span class="line">    <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> a.GetExportedTypes())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">is</span> Type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.Name == classname)</span><br><span class="line">            &#123;</span><br><span class="line">                ConstructorInfo constructor = t.GetConstructor(Type.EmptyTypes);</span><br><span class="line">                <span class="keyword">object</span> instance = constructor.Invoke(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; &#125;);</span><br><span class="line">                MethodInfo methods = t.GetMethod(methodname);</span><br><span class="line">                methods.Invoke(instance, <span class="keyword">new</span> <span class="keyword">object</span>[]&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    ReflectionInvoke(<span class="string">"CSharpDLL.dll"</span>, <span class="string">"CSharpDLLPublicClass1"</span>,<span class="string">"CSharpDLLPublicClass1Method"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/ReflectionMethodInvoke.PNG" alt="ReflectionMethodInvoke"><br>这样一来我们就实现了动态加载Assemble，然后通过反射调用里面特定类的特定方法。<br>关于反射使用Event并动态创建Delegate参考《CLR vir C#》 — Assembly Loading and Reflection章节</p>
<p>注意下面讲到的内容和书上的测试结果不一致，暂时不知道为什么。结论对错暂时不予置评。<br>如果我们要频繁的通过反射去访问特定类里的方法和成员，我们会采用存储Type,MemberInfo-derived Object到collection的方式，然后再通过collection去访问。<br>“Type and MemberInfo-derived objects require a lot of memory.”<br>但Type，MemberInfo及子类存储了大量的类型信息，会耗费大量的内存。<br>如何解决这个问题了？<br>“Developers who are saving/caching a lot of Type and MemberInfoderived<br>objects can reduce their working set by using run-time handles instead of objects.”<br>通过存储run-time handles而非Type，MemberInfo object本身可以节约大量内存，然后通过run-time handles转换到对应Type/MemberInfo去访问类型信息。</p>
<ol>
<li>RuntimeTypeHandle</li>
<li>RuntimeFieldHandle</li>
<li>RuntimeMethodHandle<br>“All of these types are value types that contain just one field, an IntPtr. The IntPtr field is a handle that refers to a type, field, or method in an AppDomain’s loader heap.”<br>Run-time handles只包含一个成员，那就是IntPtr，这里存储的相当于类型信息的索引或指针。而真正的类型信息是存储在AppDomain的Loader heap上。<br>所以我们只需要通过去构造run-time handles指向AppDomain loader heap上特定type，field，method，然后通过转换handle到对应Type/MemberInfo去访问类型信息就能避免存储大量的Type，MemberInfo对象，从而达到节约内存的目的。<br>那么我们来看看如何通过run-time handle到底能节约多少内存？如何通过转换run-time handle去访问类型信息：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowHeapMemoryUsing</span>(<span class="params"><span class="keyword">string</span> postfix</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"Heap Memory Size = &#123;0&#125; -- &#123;1&#125;"</span>,GC.GetTotalMemory(<span class="keyword">true</span>), postfix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RuntimeTypeHandleAccessObjectTypeInfo</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    ShowHeapMemoryUsing(<span class="string">"Before do anything!"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;MethodBase&gt; methodinfos = <span class="keyword">new</span> List&lt;MethodBase&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function">Type t <span class="keyword">in</span> <span class="title">typeof</span>(<span class="params">Object</span>).Assembly.<span class="title">GetExportedTypes</span>(<span class="params"></span>))</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//skip over any generic types</span></span><br><span class="line">        <span class="keyword">if</span>(t.IsGenericTypeDefinition) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        MethodBase[] mb = t.GetMethods();</span><br><span class="line">        methodinfos.AddRange(mb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"Methods Number in Object : &#123;0&#125;"</span>,methodinfos.Count));</span><br><span class="line"></span><br><span class="line">    ShowHeapMemoryUsing(<span class="string">"After building cache of MethodInfo objects!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Build cache of RuntimeMethodHandles for all MethodInfo objects in class.name = classname</span></span><br><span class="line">    List&lt;RuntimeMethodHandle&gt; methodhandles = methodinfos.ConvertAll&lt;RuntimeMethodHandle&gt;(mb =&gt; mb.MethodHandle);</span><br><span class="line"></span><br><span class="line">    ShowHeapMemoryUsing(<span class="string">"Holding MethodInfo and RuntimeMethodHandle cache!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prevent cache from being GC'd early</span></span><br><span class="line">    GC.KeepAlive(methodinfos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Allow cache from being GC's now</span></span><br><span class="line">    methodinfos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ShowHeapMemoryUsing(<span class="string">"After freeing MethodInfo Objects!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Obtain methodinfos from methodhandle</span></span><br><span class="line">    methodinfos = methodhandles.ConvertAll&lt;MethodBase&gt;(rmh =&gt; MethodBase.GetMethodFromHandle(rmh));</span><br><span class="line"></span><br><span class="line">    ShowHeapMemoryUsing(<span class="string">"Size of heap after re-creating MethodInfo objects!"</span>);</span><br><span class="line"></span><br><span class="line">    GC.KeepAlive(methodhandles);</span><br><span class="line">    GC.KeepAlive(methodinfos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Alow cache to be GC'd now</span></span><br><span class="line">    methodhandles = <span class="keyword">null</span>;</span><br><span class="line">    methodinfos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ShowHeapMemoryUsing(<span class="string">"After freeing MethodInfos and RuntimeMethodHandles!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/img/CSharp/RuntimeHandlesUsing.PNG" alt="RuntimeHandlesUsing"><br>上述测试结果和《CLR via C#》测试结果完全不一致：<br><img src="/img/CSharp/RuntimeHandlesTestInBook.PNG" alt="RuntimeHandlesTestInBook"><br>对于释放之后methodinfos后，内存没有减少，重新转换run-time handle到<br>当我们得到run-time handles后，我们可以通过转换run-time handle到MethodBase后反倒内存使用减少。(<strong>对于run-time handles是否能够减少内存使用，这里表示疑问</strong>)<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object objinstance = <span class="keyword">typeof</span>(Object).GetConstructor(<span class="keyword">new</span> Type[] &#123; &#125;).Invoke(<span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">MethodBase migethashcode = methodinfos.Find( mi=&gt; mi.Name == <span class="string">"GetHashCode"</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"objinstance.GetHashCode = &#123;0&#125;"</span>,migethashcode.Invoke(objinstance, <span class="keyword">new</span> Object[]&#123;&#125;)));</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>“The CLR doesn’t support the ability to unload individual assemblies.you want to unload an assembly, you must unload the entire AppDomain that contains it.”(CLR不支持unload单独的assembly，如果需要unload assembly只能通过unload加载了该assembly的AppDomian来实现)<br>“avoid using reflection to access a field or invoke a method property.”(<br>尽量避免使用反射去调用方法和访问属性成员，因为很慢)</p>
<p>在学习了Hosting,AppDomain,Assembly,Reflection相关知识后，让我们看看Serialization是如何实现的。</p>
<h3 id="Runtime_Serialization">Runtime Serialization</h3><p>“Serialization is the process of converting an object or a graph of connected objects into a stream of<br>bytes. Deserialization is the process of converting a stream of bytes back into its graph of connected objects.”<br>序列化和反序列化支持我们把对象信息存储到bytes里，然后通过bytes去构建对象。</p>
<p>“When serializing an object, the full name of the type and the name of the type’s defining assembly are written to the stream.When deserializing an object, the formatter first grabs the assembly identity and ensures that the assembly is loaded into the executing AppDomain by calling System.Reflection.Assembly’s Load method.”<br>从上面可以看出来，序列化和反序列化的关键技术是通过写入类型信息和类型数据到byte里，然后通过反射实例化出对象。<br>反序列化的时候一定要确保正确的Assembly被加载，并且类型信息要和序列化时候使用的类型信息对应上。</p>
<p>那么怎么样才是使得类型信息支持序列化了？<br>我们需要在支持序列化的类型的定义前面加上flag:<br>[Serializable]]<br>“the SerializableAttribute attribute is not inherited by derived types.”<br>序列化的flag只对父类有效。<br>既然可以指定可序列化，那么当然也可以指定不支持序列化的flag:<br>[NonSerialized]<br>那么这些不支持反序列化的成员信息，如何确保在反序列化的时候初始化到正确的值了？<br>这里就需要一个flag：<br>[OnDeserialized]<br>OnDeserialized标记的方法会在反序列化该类型的时候被调用，用于初始化那些NonSerialized的成员信息。<br>那么如果我们在将来添加了类型信息里的成员定义，反序列化的时候需要怎样才能保证不出错了？<br>只需要在新添加的成员定义前添加下面这个flag:<br>[OptionalFieldAttribute]<br><a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.optionalfieldattribute(v=vs.110" target="_blank" rel="external">Specifies that a field can be missing from a serialization stream so that the BinaryFormatter and the SoapFormatter does not throw an exception.</a>.aspx)<br>标记该成员可以在序列化的时候缺失，不抛出异常。<br>更多的序列化相关控制标记参见如下：<br>[OnSerializing] — called during serialization of an object<br>[OnSerialized] — called after serialization of an object<br>[OnDeserializing] — called during deserialization of an object<br>[OnDeserialized] — called immediately after deserialization of an object<br>Note:<br>定义了以上flag的方法必须带一个StreamingContext的参数</p>
<p>接下来让我们详细看看Serialize的过程：<br>先大概了解下Serialization和Deserialization的使用<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Serializable]</span><br><span class="line">publci <span class="keyword">class</span> <span class="title">Map</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Serialization</span></span><br><span class="line">BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter ();</span><br><span class="line">FileStream fs = File.Open (mMapSavePath, FileMode.Open);</span><br><span class="line">bf.Serialize (fs, mMap);</span><br><span class="line">fs.Close ();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Deserialization</span></span><br><span class="line">BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter ();</span><br><span class="line">FileStream fs = File.Open (mMapSavePath, FileMode.Open);</span><br><span class="line">mMap = (Map)bf.Deserialize (fs);</span><br><span class="line">fs.Close ();</span><br></pre></td></tr></table></figure></p>
<p>以下内容源于《CLR via C#》<br>Serialize Steps:</p>
<ol>
<li>The formatter calls FormatterServices’s GetSerializableMembers method.<br>public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);<br>首先获取所有需要Serialize的成员信息(MemberInfo)，返回MemberInfo[]</li>
<li>The object being serialized and the array of System.Reflection.MemberInfo objects are then passed to FormatterServices’ static GetObjectData method.<br>通过MemberInfo去获取Object里成员信息的值，存储在Object[]里</li>
<li>The formatter writes the assembly’s identity and the type’s full name to the stream.<br>把相关的assembly identity，type名字写入stream</li>
<li>The formatter then enumerates over the elements in the two arrays, writing each member’s name and value to the stream.<br>最后把所有MemberInfo名字(MemberInfo[]里)和实际Object成员值(Objectp[]里)分别对应写入stream。</li>
</ol>
<p>Deserialize Steps：</p>
<ol>
<li>首先通过写入stream的assembly identity和type name去判断对应的Assembly是否已经加载。<br>如果加载了就通过FormatterServices::GetTypeFromAssembly去获取需要deserialize的type信息</li>
<li>然后通过FormatterServices::GetUninitializedObject去预分配内存但不调用构造函数，所有成员数据为null or 0</li>
<li>然后利用FormatterSerices::GetSerializableMembers得到支持序列化的类型成员信息用于构建和初始化</li>
<li>读取之前序列化保存成员数据信息</li>
<li>利用前面得到的支持序列化的成员信息和读取出的成员数据信息去初始化Object。FormatterServices::PopulateObjectMembers方法负责填充数据。</li>
</ol>
<p>因为序列化底层是通过反射来实现的，但反射是很慢的，如何高效的序列化数据了？<br>前面我们提到，序列化和反序列化真正去填充或读取的序列化和反序列数据是在调用FormatterServices::GetObjectData方法里。而默认的GetObjectData的数据填充是通过反射来实现的，所以我们只要使支持序列化的类实现ISerializaable的GetObjectData去自定义数据填充就能避免数据填充式reflection的使用。<br>确保传入GetObjectData的数据安全，在GetObjectData定义前加上：<br>[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]<br>还有就是需要定义一个特殊的构造函数，在Deserialization之前会被调用，这里会传入我们反序列化的SerializationInfo数据，然后我们通过IDeserializationCallback.OnDeserialization(Object sender)去填充数据完成反序列化。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[Serializable]</span><br><span class="line">public class Map : ISerializable, IDeserializationCallback</span><br><span class="line">&#123;</span><br><span class="line">    //Special construct(required by ISerializable) to control deserialization</span><br><span class="line">    [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]</span><br><span class="line">    protected Map(SerializationInfo info, StreamingContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine("protected Map(SerializationInfo info, StreamingContext context) called!");</span><br><span class="line">        m_SiInfo = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]</span><br><span class="line">    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine("Map::GetObjectData() called!");</span><br><span class="line">        info.AddValue("mID", mID);</span><br><span class="line">        info.AddValue("mMapName", mMapName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void IDeserializationCallback.OnDeserialization(Object sender)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine("Map::OnDeserialization() called!");</span><br><span class="line">        if (m_SiInfo == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mID = m_SiInfo.GetInt32("mID");</span><br><span class="line">        mMapName = m_SiInfo.GetString("mMapName");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SerializationInfo m_SiInfo;</span><br><span class="line"></span><br><span class="line">    public Map()</span><br><span class="line">    &#123;</span><br><span class="line">        mID = 0;</span><br><span class="line">        mMapName = "DefaultMap";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int ID</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return mID;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            mID = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int mID;</span><br><span class="line"></span><br><span class="line">    public string MapName</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return mMapName;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            mMapName = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private string mMapName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string mMapSavePath = "./mapInfo.dat";</span><br><span class="line">    Map mMap = new Map();</span><br><span class="line">    mMap.ID = 110;</span><br><span class="line">    mMap.MapName = "TonyMap";</span><br><span class="line">    BinaryFormatter bf = new BinaryFormatter ();</span><br><span class="line">    if (!File.Exists(mMapSavePath))</span><br><span class="line">    &#123;</span><br><span class="line">        FileStream fsc = File.Create(mMapSavePath);</span><br><span class="line">        fsc.Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileStream fs = File.Open(mMapSavePath, FileMode.Open);</span><br><span class="line">    bf.Serialize(fs, mMap);</span><br><span class="line">    fs.Close();</span><br><span class="line">    </span><br><span class="line">    //Deserialization</span><br><span class="line">    Map mDSMap;</span><br><span class="line">    BinaryFormatter dsbf = new BinaryFormatter ();</span><br><span class="line">    if (File.Exists(mMapSavePath))</span><br><span class="line">    &#123;</span><br><span class="line">        FileStream dsfs = File.Open(mMapSavePath, FileMode.Open);</span><br><span class="line">        mDSMap = (Map)dsbf.Deserialize(dsfs);</span><br><span class="line">        dsfs.Close();</span><br><span class="line">        Console.WriteLine(string.Format("Map.ID = &#123;0&#125;, Map.MapName = &#123;1&#125;", mDSMap.ID, mDSMap.MapName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/Serialization.PNG" alt="Serialization"><br>可以看到我们成功自定义了数据的填充和解析，避免了不必要的reflection调用。<br>更多关于Serialization学习参考《CLR via C#》 — Runtime Serialization章节</p>
<p>Note:<br>The .NET Framework also offers other serialization technologies that are designed<br>more for interoperating between CLR data types and non-CLR data types. (以下serialization技术支持CLR data type和non-CLR data types之间的交互，支持从XML序列化和反序列化，这里暂时没有深入学习了解)</p>
<ol>
<li>System.Xml.Serialization.XmlSerializer class</li>
<li>System.Runtime.Serialization.DataContractSerializer class<br>还有一种方式序列化是通过SoapFormatter类，.soap格式。<br>还有一种高效的平台无关话的序列化反序列化方式，<a href="http://tonytang1990.github.io/2015/07/15/Unity-Study/#Protocol_Buffers">参见Google Protocol Buffer学习</a><br>待续……</li>
</ol>
<h3 id="Platform_Invoke">Platform Invoke</h3><p>跨语言的调用，比如managed的C#调用unmanaged的C++代码<br>DllImport — Allow reusing existing unmanaged code in a managed application.</p>
<p>DllImport Attribute在DllImport的时候很重要，确保我们能找到正确的unmanaged function，传入正确的参数类型等。</p>
<p>DllImport Attribute有以下几个重要的参数：<br>EntryPoint — 指明我们将要导入的unmanaged方法名(只有指明正确的方法名，才能找到该方法)<br>CharSet — 指明如何去处理string类型，比如unicode or ansi(宽字符和单个字符是不一样的)<br>CallingConvention — 指明函数的调用约定(一般我们会涉及到<strong>stdcall和</strong>cdecl，前者是C++的标准调用约定，后者是C语言调用约定，只有用同样的调用约定我们才能正确调用方法)<br>Note:<br>不同的调用约定会决定参数的传入顺序，传参方式，堆栈维护，如何生成方法名等。</p>
<p>普通参数类型的调用事例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">MyMath.h</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> MATH_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MATH_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> UTILITYDLL_API _declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyMath</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> UTILITYDLL_API <span class="keyword">int</span> __<span class="function">stdcall <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> UTILITYDLL_API <span class="keyword">int</span> __<span class="function">cdecl <span class="title">MySubstract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyMath.cpp</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdafx.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"MyMath.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">UTILITYDLL_API <span class="keyword">int</span> __stdcall MyMath::MyAdd(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UTILITYDLL_API <span class="keyword">int</span> __cdecl MyMath::MySubstract(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">UTILITYDLL_API <span class="keyword">double</span> <span class="title">MyMultiple</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a *  b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UTILITYDLL_API <span class="keyword">double</span> __<span class="function">stdcall <span class="title">MyDivision</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a /  b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mID;</span><br><span class="line">    <span class="keyword">bool</span> mBMan;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">UTILITYDLL_API <span class="keyword">int</span> <span class="title">ModifyMyStruct</span><span class="params">(MyStruct* ms)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ms-&gt;mBMan == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ms-&gt;mBMan = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(MyStruct);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ms-&gt;mID = -<span class="number">1</span>;</span><br><span class="line">            ms-&gt;mAge = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(MyStruct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharpStudy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="preprocessor">#<span class="keyword">region</span> DLL import Study    </span></span><br><span class="line">        [StructLayout(LayoutKind.Explicit, Pack = <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">        &#123;</span><br><span class="line">            [FieldOffset(<span class="number">0</span>)] <span class="keyword">public</span> <span class="keyword">int</span> mID;</span><br><span class="line">            [FieldOffset(<span class="number">4</span>)] <span class="keyword">public</span> <span class="keyword">bool</span> mBMan;</span><br><span class="line">            [FieldOffset(<span class="number">5</span>)] <span class="keyword">public</span> <span class="keyword">int</span> mAge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [StructLayout(LayoutKind.Sequential)]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> MyStruct2</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> mID;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">bool</span> mBMan;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> mAge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [StructLayout(LayoutKind.Explicit)]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> MyStructExplicit</span><br><span class="line">        &#123;</span><br><span class="line">            [FieldOffset(<span class="number">0</span>)] <span class="keyword">public</span> Byte mByte;</span><br><span class="line">            [FieldOffset(<span class="number">4</span>)] <span class="keyword">public</span> <span class="keyword">int</span> mID;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [StructLayout(LayoutKind.Explicit, Pack = <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> MyStructExplicit2</span><br><span class="line">        &#123;</span><br><span class="line">            [FieldOffset(<span class="number">0</span>)]</span><br><span class="line">            <span class="keyword">public</span> Byte mByte;</span><br><span class="line">            [FieldOffset(<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> mID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [StructLayout(LayoutKind.Explicit, Pack = <span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> MyStructExplicit3</span><br><span class="line">        &#123;</span><br><span class="line">            [FieldOffset(<span class="number">0</span>)] <span class="keyword">public</span> Byte mByte;</span><br><span class="line">            [FieldOffset(<span class="number">2</span>)] <span class="keyword">public</span> <span class="keyword">int</span> mID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"TESTDLL.dll"</span>, EntryPoint = <span class="string">"?MyAdd@MyMath@@SGHHH@Z"</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">MyAdd</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"TESTDLL.dll"</span>, EntryPoint = <span class="string">"?MySubstract@MyMath@@SAHHH@Z"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">MySubstract</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line">        [DllImport(<span class="string">"TESTDLL.dll"</span>, EntryPoint = <span class="string">"MyMultiple"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">MyMultiple</span>(<span class="params"><span class="keyword">double</span> a, <span class="keyword">double</span> b</span>)</span>;</span><br><span class="line">        <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> DLL import Study</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            sum = MyAdd(a, b);</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; + &#123;1&#125; = &#123;2&#125;"</span>, a, b, sum));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> substractionresult = <span class="number">0</span>;</span><br><span class="line">            substractionresult = MySubstract(a, b);</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; - &#123;1&#125; = &#123;2&#125;"</span>, a, b, substractionresult));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> multiplier = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> multiplicand = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> multipleresult = <span class="number">0</span>;</span><br><span class="line">            multipleresult = MyMultiple(multiplier, multiplicand);</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; * &#123;1&#125; = &#123;2&#125;"</span>, multiplier, multiplicand, multipleresult));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> divisor = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> dividend = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> divisionresult = <span class="number">0</span>;</span><br><span class="line">            divisionresult = MyDivision(divisor, dividend);</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; / &#123;1&#125; = &#123;2&#125;"</span>, divisor, dividend, divisionresult));</span><br><span class="line"></span><br><span class="line">            MyStruct ms = <span class="keyword">new</span> MyStruct();</span><br><span class="line">            MyStruct2 ms2 = <span class="keyword">new</span> MyStruct2();</span><br><span class="line">            MyStructExplicit mse = <span class="keyword">new</span> MyStructExplicit();</span><br><span class="line">            MyStructExplicit2 mse2 = <span class="keyword">new</span> MyStructExplicit2();</span><br><span class="line">            MyStructExplicit3 mse3 = <span class="keyword">new</span> MyStructExplicit3();</span><br><span class="line">            Int32 sizeofms = <span class="number">0</span>;</span><br><span class="line">            ms.mID = <span class="number">4</span>;</span><br><span class="line">            ms.mBMan = <span class="keyword">false</span>;</span><br><span class="line">            ms.mAge = <span class="number">4</span>;</span><br><span class="line">            ms2.mID = <span class="number">5</span>;</span><br><span class="line">            ms2.mBMan = <span class="keyword">false</span>;</span><br><span class="line">            ms2.mID = <span class="number">5</span>;</span><br><span class="line">            mse.mID = <span class="number">1</span>;</span><br><span class="line">            mse.mByte = <span class="number">1</span>;</span><br><span class="line">            mse2.mID = <span class="number">2</span>;</span><br><span class="line">            mse2.mByte = <span class="number">2</span>;</span><br><span class="line">            mse3.mID = <span class="number">3</span>;</span><br><span class="line">            mse3.mByte = <span class="number">3</span>;</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"sizeof(MyStruct) = &#123;0&#125;"</span>, Marshal.SizeOf(ms)));</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"sizeof(MyStructExplicit) = &#123;0&#125;"</span>, Marshal.SizeOf(mse)));</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"sizeof(MyStructExplicit2) = &#123;0&#125;"</span>, Marshal.SizeOf(mse2)));</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"sizeof(MyStructExplicit3) = &#123;0&#125;"</span>, Marshal.SizeOf(mse3)));</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"ms.mID = &#123;0&#125;, ms.mBMan = &#123;1&#125;, ms.mAge = &#123;2&#125;"</span>, ms.mID, ms.mBMan, ms.mAge));</span><br><span class="line">            sizeofms = ModifyMyStruct(<span class="keyword">ref</span> ms);</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"ms.mID = &#123;0&#125;, ms.mBMan = &#123;1&#125;,  ms.mAge = &#123;2&#125;, sizeofms = &#123;3&#125;"</span>, ms.mID, ms.mBMan, ms.mAge, sizeofms));</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"ms2.mID = &#123;0&#125;, ms2.mBMan = &#123;1&#125;, ms2.mAge = &#123;2&#125;"</span>, ms2.mID, ms2.mBMan, ms2.mAge));</span><br><span class="line">            sizeofms = ModifyMyStruct2(<span class="keyword">ref</span> ms2);</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"ms2.mID = &#123;0&#125;, ms2.mBMan = &#123;1&#125;,  ms2.mAge = &#123;2&#125;, sizeofms = &#123;3&#125;"</span>, ms2.mID, ms2.mBMan, ms2.mAge, sizeofms));</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:<br><img src="/img/CSharp/PlatformInvokeDemo.PNG" alt="PlatformInvokeDemo"></p>
<p>分析上述事例：<br>针对MyAdd方法我们定义了<strong>Stdcall的C++调用约定方式，而且属于类的静态方法，所以在C#中import的时候我们需要指明具体的方法名(通过VS自带的dumpbin我们可以打出TESTDLL.dll里的符号表信息 — dmpbin.exe /all TESTDLL.dll &gt; TestDllDump.txt,我们可以找到MyAdd方法的具体方法名，否者会显示找不到EntryPoint方法MyAdd)，原本还需要指明调用约定为</strong>stdcall，但CallingConvention的默认值就是__stdcall，所以这里就不用指明了。</p>
<p>针对MySubstract方法我们定义了__cdecl的C调用约定方式，而且属于类的静态方法，所以我们在C#中import的时候需要指明具体的方法名和指明调用约定为CallingConvention = CallingConvention.Cdecl，否者会显示调用堆栈不对称等问题。</p>
<p>针对MyMultiple方法我们定义了<strong>cdecl的C调用约定方式，同时是全局方法，所以我们只需要指明调用约定为</strong>cdecl，直接指明调用方法为MyMultiple就能找到MyMultiple方法了。</p>
<p>针对MyDivision方法我们定义了<strong>stdcall的C++调用约定方式，同时是全局方法，但由于</strong>stdcall调用约定对方法名生成的方式(包含函数名，参数字节数信息等)，我们不能直接通过MyDivision来调用MyDivision方法而需要在EntryPoint里指定方法全名。</p>
<p>除了找到正确的函数方法和指定正确的函数调用约定等信息外，我们在Manage code调用Unmanaged code的时候需要保证Manage struct和Unmanage struct的内存布局要一致，以确保unmanaged code访问managed数据的时候拿到正确信息。</p>
<p><a href="https://msdn.microsoft.com/en-us/library/ef4c3t39.aspx" target="_blank" rel="external">These structures can have any legal name; there is no relationship between the native and managed version of the two structures other than their data layout. Therefore, it is vital that the managed version contains fields that are the same size and in the same order as the native version.</a><br>从官网可以看出，managed code的函数名字并不重要，我们必须确保结构体的内存布局要一致。</p>
<p>那我们为何要进行内存对齐了？<br>一下参考百度百科：<br>“<br>平台原因（移植原因）<br>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬<br>件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br>性能原因<br>数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问<br>未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问<br>”</p>
<p>从测试例子里可以看出，当我们通过StructLayoutAttribute.Pack指定MyStuct的内存对齐方式是1的时候，MyStruct的大小只有9bytes，而MyStruct2使用默认采用结构体内数据最大的值作为对齐方式，事例中是int即4bytes为对齐方式，MyStruct2的大小是12bytes。反观C++返回的MyStruct的大小是12(可以看出是以4bytes为对齐方式)，所以如果我们传递MyStruct的时候访问数据就出问题了，而MyStruct2访问到了正确的数据。</p>
<p>而后续的MyStructExplicit,MyStructExplicit2,MyStructExplicit3则展示了通过制定Pack的值(即内存对齐大小)是如何影响数据结构的大小的。</p>
<p>更多：<br><a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.pack%28v=vs.110%29.aspx" target="_blank" rel="external">StructLayoutAttribute.Pack</a><br><a href="https://msdn.microsoft.com/zh-cn/library/dn956973.aspx#NotExistJustToMakeTheAElementVisible" target="_blank" rel="external">在 Visual Studio 2015 之前，可以使用 Microsoft 专用关键字 __alignof 和 declspec(alignas) 来指定大于默认值的对齐方式。从 Visual Studio 2015 开始，应使用 C++11 标准关键字 alignof 和 alignas (C++) 以获得最高代码可移植性。</a></p>
<h3 id="Event">Event</h3><p>C#里的Event响应相当于listener and obsever 模式里触发监听回调。Delegate好比C++里的回调 — 当事件发生时调用</p>
<p>“The common language runtime’s (CLR’s) event model is based on delegates.”<br>event key word</p>
<p>定义Event我们需要做一下几件事，下面模拟邮件收发事件提醒为例:</p>
<ol>
<li><p>定义EventArgs(这个必须继承至EventArgs，里面包含了我们事件发生时所需要传递的信息，如果什么都不需要传递，使用EventArgs即可)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a type that will hold any additional information that should be sent to receivers of the event notification</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">NewMailEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewMailEventArgs</span>(<span class="params">String <span class="keyword">from</span>, String to, String subject</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        m_From = <span class="keyword">from</span>;</span><br><span class="line">        m_To = to;</span><br><span class="line">        m_Subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String From&#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_From; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> String m_From;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String To &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_To; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> String m_To;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String Subject &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_Subject; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> String m_Subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义Event成员，用于指定监听什么样的Event</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">EmailManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Define the event member</span></span><br><span class="line">    <span class="comment">// 虽然这里只有简短的一句话，</span></span><br><span class="line">    <span class="comment">// 但是编译器会给我们去定义关于此事件的监听添加和删除代码</span></span><br><span class="line">    <span class="comment">// 详情请看下面截图</span></span><br><span class="line">    <span class="comment">// 这样一来我们只要通过NewEmail就能添加和删除监听NewMailEventArgs事件的delegate了</span></span><br><span class="line">    <span class="comment">// EventHandler决定了我们监听事件的Delegate原型如下</span></span><br><span class="line">    <span class="comment">// public delegate void EventHandler(object sender, EventArgs e);</span></span><br><span class="line">    <span class="comment">// 监听的事件是NewMailEventArgs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;NewMailEventArgs&gt; NewMail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="/img/CSharp/EventDefinition.PNG" alt="EventExtraCode"></p>
</li>
<li><p>定义需要监听事件的类并提供添加和删除监听的方法</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Fax</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fax</span>(<span class="params">EmailManager em</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// Trigger add_NewMail method</span></span><br><span class="line">        em.NewMail += FaxMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delegate that is used to listen for NewMailEventArgs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FaxMsg</span>(<span class="params">Object sender, NewMailEventArgs e</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Faxing mail message:"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"From = &#123;0&#125;, To = &#123;1&#125;, Subject = &#123;2&#125;"</span>, e.From, e.To, e.Subject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove listener for NewMailEventArgs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unregester</span>(<span class="params">EmailManager em</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// Trigger remove_NewMail method</span></span><br><span class="line">        em.NewMail -= FaxMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义事件触发和事件通知方法</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">EmailManager</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a method responsible for raising the event</span></span><br><span class="line">    <span class="comment">// to notify registered objects that the event has occurred</span></span><br><span class="line">    <span class="comment">// If this class is sealed, make this method private and nonvirtual</span></span><br><span class="line">    <span class="comment">// 事件通知</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNewMail</span>(<span class="params">NewMailEventArgs e</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// Copy a reference to the delegate field now into a temporary field for thread safety</span></span><br><span class="line">        <span class="comment">// Be careful race condition</span></span><br><span class="line">        EventHandler&lt;NewMailEventArgs&gt; temp = NewMail;</span><br><span class="line">        <span class="comment">// 这里有thread safe问题，但由于delegate is immutable，</span></span><br><span class="line">        <span class="comment">// 所以我们把NewMail传递给临时变量temp后，无论别人如何改变NewMail都没关系了</span></span><br><span class="line">        <span class="comment">// If any methods registered interest with our event, notify them</span></span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp(<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a method that translates the input into the desired event</span></span><br><span class="line">    <span class="comment">// 事件触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SimulateNewMail</span>(<span class="params">String <span class="keyword">from</span>, String to, String subject</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// Hold the information we want to pass</span></span><br><span class="line">        NewMailEventArgs e = <span class="keyword">new</span> NewMailEventArgs(<span class="keyword">from</span>, to, subject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call OnNewMail to notify registered objects that the event has occured</span></span><br><span class="line">        OnNewMail(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试Event</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    EmailManager emailmanager = <span class="keyword">new</span> EmailManager();</span><br><span class="line"></span><br><span class="line">    Fax fax = <span class="keyword">new</span> Fax(emailmanager);</span><br><span class="line"></span><br><span class="line">    emailmanager.SimulateNewMail(<span class="string">"Tony"</span>, <span class="string">"Tom"</span>, <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">    fax.Unregester(emailmanager);</span><br><span class="line"></span><br><span class="line">    emailmanager.SimulateNewMail(<span class="string">"Tom"</span>, <span class="string">"Tony"</span>, <span class="string">"Hello World Again!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Test Result:<br><img src="/img/CSharp/EventTestResult.PNG" alt="EventTestResult"><br>可以看出我们成功的添加了自定义的事件监听也成功的移除了事件监听。</p>
<p>Note:<br>一般来说，设计事件监听都会设计成通过Dictionary来存储EventKey和Delegate，通过判断Dictinary里面是否存在该事件来添加Delegate，如果不存在则添加该事件监听。删除监听同理。</p>
<h3 id="Chars,_Strings,_and_Working_with_Text">Chars, Strings, and Working with Text</h3><p>Chars:<br>“In the .NET Framework, characters are always represented in 16-bit Unicode code values, easing the development of global applications.A character is represented with an instance of the System.Char structure (a value type).”</p>
<p>说到字符和字符串，就不得不提字符编码了，从上面可以看出，.NET的Char都是采用16bit的Unicode编码，主要是为了语言通用话(包含所有的字符编码)。还有一点就是Char是Structure是Value type。</p>
<p>针对字符本身的方法(Char)：<br>Char还提供了很多获取字符具体类型等相关信息的方法，e.g IsDigit, IsLetter,<br>IsWhiteSpace, IsUpper，GetUnicodeCategory(得到字符关于Unicode的分类信息)……<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Char c = <span class="string">'a'</span>;</span><br><span class="line">UnicodeCategory uc = Char.GetUnicodeCategory(c);</span><br><span class="line">Console.WriteLine(<span class="string">"UnicodeCategory = &#123;0&#125;"</span>, uc.ToString());</span><br><span class="line">c = <span class="string">'1'</span>;</span><br><span class="line">uc = Char.GetUnicodeCategory(c);</span><br><span class="line">Console.WriteLine(<span class="string">"UnicodeCategory = &#123;0&#125;"</span>, uc.ToString());</span><br></pre></td></tr></table></figure></p>
<p>针对字符全球化(CultureInfo):<br>在Char里面很多方法都有包含CultureInfo参数类型的版本，这个是针对全球化指定特定语言。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CultureInfo ci = CultureInfo.CurrentCulture;</span><br><span class="line">Console.WriteLine(<span class="string">"CurrentCulture = &#123;0&#125;"</span>, ci);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/CharAndCultureInfoOutput.PNG" alt="CharAndCultureInfoOutput"></p>
<p>Strings:<br>“The String type is derived immediately from Object, making it a reference type.”</p>
<p><em>String的构建：</em></p>
<ol>
<li>通过Literal string构建<br>虽然String是reference type，但我们构建String的时候不是通过new，而直接通过literal string(e.g. String s = “Tony”;)</li>
<li>支持像C++里那样特殊符号代表特定含义<br>String s = “Hi\r\nthere”;</li>
<li>跨平台考虑<br>特殊符号在不同平台有不同的表示方式，所以出于跨平台考虑，我们最好使用Environment里的变量来表示特定环境的特定符号<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1= <span class="string">"Tony"</span>;</span><br><span class="line">String s2 = <span class="string">"Hi\nTony!"</span>;</span><br><span class="line">String s3 = <span class="string">"Hi"</span> + Environment.NewLine + <span class="string">"Tom!"</span>;</span><br><span class="line">Console.WriteLine(<span class="string">"s1 = &#123;0&#125;"</span>, s1);</span><br><span class="line">Console.WriteLine(<span class="string">"s2 = &#123;0&#125;"</span>, s2);</span><br><span class="line">Console.WriteLine(<span class="string">"s3 = &#123;0&#125;"</span>, s3);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/img/CSharp/StringConstructOutput.PNG" alt="StringConstructOutput"></p>
<p><em>多个String合并：</em><br>多个字符串合并的时候最主要的是避免通过重复的literal string去构建String，因为String是reference type，多个literal string的构建会在heap上分配多个内存。正确的是通过System.Text.StringBuilder去构建。</p>
<p>“StringBuilder’s members allow you to manipulate this character array, effectively shrinking the string or changing the characters in the string.”</p>
<p>Unlike a String, a StringBuilder represents a mutable string. This means that most of StringBuilder’s members change the contents in the array of characters and don’t cause new objects to be allocated on the managed heap.”</p>
<p>可以看出StringBuilder之所以不会构建多个String是因为它内部构建了可变的character array，这样允许我们在StringBuilder里操作的时候不会触发新的String构建。这样以来我们就可以利用里面现有的String去动态构建我们需要的String了。<br>Error:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hi"</span> + <span class="string">"there!"</span>;</span><br></pre></td></tr></table></figure></p>
<p>Right:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String sp1 = <span class="string">"Tony"</span>;</span><br><span class="line">String sp2 = <span class="string">" and "</span>;</span><br><span class="line">String sp3 = <span class="string">"Tom"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello "</span>, <span class="number">50</span>);</span><br><span class="line">sb.Append(sp1);</span><br><span class="line">sb.Append(sp2);</span><br><span class="line">sb.Append(sp3);</span><br><span class="line">Console.WriteLine(<span class="string">"sb = &#123;0&#125;"</span>, sb.ToString());</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/StringCatenationOutput.PNG" alt="StringCatenationOutput"></p>
<p><em>String比较：</em><br>String.Compare(<em>*</em>)<br>……<br>比较的时候需要注意可能有不同国家的语言，这里需要注意需要传入CultureInfo作为比较的语言环境参数。</p>
<p>同时当我们的代码文件中直接书写了特定国家语言或语言Unicode编码的时候，我们需要把文件存储为Unicode格式，否则到时候编译器无法正常解析。</p>
<p>程序中大量的比较特别是针对特定国家语言的String比较很费时，我们应该尽量避免。</p>
<p>同时String是immuatable的，我们可以重复利用现有的String，无需大量重复构造相同的String去增加memory负担。<br>CLR里有一个叫internal hash table的东西，所有的Strings作为key，所有String的reference作为value。因为String是immutable的且是reference type，我们可以通过访问internal hash table去查看是否存在现有String，这样一来就避免了重构相同的String。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String ss = <span class="string">"internal string"</span>;</span><br><span class="line">String sintern = String.Intern(ss);</span><br><span class="line">Console.WriteLine(<span class="string">"sintern = &#123;0&#125;"</span>,sintern);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/StringConstructionWithMemorySave.PNG" alt="StringConstructionWithMemorySave"></p>
<p>“String objects referred to by the internal hash table can’t be freed until the AppDomain is unloaded or the process terminates.”</p>
<p>“System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning flag will control whether to inern all of the string.”</p>
<p><em>Security String:</em><br>System.Security.SecureString ……</p>
<p>Note:<br><strong>String object is immutable. The String class is sealed, which means that you cannot use it as a base class for your own type.</strong></p>
<h3 id="Enumerated_and_Bit_Flags">Enumerated and Bit Flags</h3><ol>
<li><p>Enum<br>“Every enumerated type is derived directly from System.Enum, which is derived from System.ValueType, which in turn is derived from System.Object”<br>首先可以看出Enumerated属于Value Type。<br>这里还是说一下使用Enumerate的好处：</p>
<ol>
<li>“Enumerated types make the program much easier to write, read, and maintain.”(可视化，容易看懂，无需hard code)</li>
<li><p>“Enumerated types are strongly typed.”(类型传递不对，编译器会报错)<br>Enumerate在C#里作为一个最基础的type，且是面向对象的，C#给我们提供了很多可以相互转化的方法(e.g. 比如Enum到String — ToString() String到Enum — Parse())</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Colors</span><br><span class="line">&#123;</span><br><span class="line">    BLACK = <span class="number">0</span>,</span><br><span class="line">    RED = <span class="number">1</span>,</span><br><span class="line">    GREEN = <span class="number">2</span>,</span><br><span class="line">    BLUE = <span class="number">3</span>,</span><br><span class="line">    WHITE = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Colors c = Colors.RED;</span><br><span class="line">    Console.WriteLine(<span class="string">"Decimal format: c = &#123;0&#125;"</span>, c.ToString(<span class="string">"D"</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">"General format: c = &#123;0&#125;"</span>, c.ToString(<span class="string">"G"</span>));</span><br><span class="line">    Colors c2 = (Colors)Enum.Parse(<span class="keyword">typeof</span>(Colors), <span class="string">"GREEN"</span>, <span class="keyword">true</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"Decimal format: c2 = &#123;0&#125;"</span>, c2.ToString(<span class="string">"D"</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">"General format: c2 = &#123;0&#125;"</span>, c2.ToString(<span class="string">"G"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:<br><img src="/img/CSharp/Enumerates.PNG" alt="EnumeratesOuput"><br> 还有一点值得注意的就是enum无法定义methods,properties,or events。<br> 针对methods我们可以通过C#里extention methods(详情见Methods那一节)的特性给enum添加methods。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[Flags]</span><br><span class="line"><span class="keyword">enum</span> Actions</span><br><span class="line">&#123;</span><br><span class="line">    NONE = <span class="number">0</span>,</span><br><span class="line">    READ = <span class="number">0x0001</span>,</span><br><span class="line">    WRITE = <span class="number">0x0002</span>,</span><br><span class="line">    READANDWRITE = READ | WRITE,</span><br><span class="line">    DELETE = <span class="number">0x0004</span>,</span><br><span class="line">    QUERY = <span class="number">0x0008</span>,</span><br><span class="line">    Sync = <span class="number">0x0010</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ActionsExtensionMethods</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Actions <span class="title">Set</span>(<span class="params"><span class="keyword">this</span> Actions flags, Actions setflags</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flags | setflags;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Actions actions = Actions.READ;</span><br><span class="line">    Console.WriteLine(<span class="string">"actions = &#123;0&#125;"</span>, actions.ToString());</span><br><span class="line">    actions = actions | Actions.DELETE;</span><br><span class="line">    Console.WriteLine(<span class="string">"actions = &#123;0&#125;"</span>,actions.ToString());</span><br><span class="line">    actions = actions.Set(Actions.WRITE);</span><br><span class="line">    Console.WriteLine(<span class="string">"actions = &#123;0&#125;"</span>, actions.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:<br><img src="/img/CSharp/EnumWithExtentionMethod.PNG" alt="EnumWithExtentionMethod"><br> Note:<br> “Symbols defined by an enumerated type are constant values.”</p>
</li>
</ol>
</li>
<li>Bit<br>如果说Enum是一个成员代表一个含义，那么Bit可以看做是一个Bit代表一组含义。<br>最经常用到的地方就是File的访问控制权限：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileAttributes &#123;</span><br><span class="line">    ReadOnly = <span class="number">0x00001</span>,</span><br><span class="line">    Hidden = <span class="number">0x00002</span>,</span><br><span class="line">    System = <span class="number">0x00004</span>,</span><br><span class="line">    Directory = <span class="number">0x00010</span>,</span><br><span class="line">    Archive = <span class="number">0x00020</span>,</span><br><span class="line">    <span class="number">368</span> PART III Essential Types</span><br><span class="line">    Device = <span class="number">0x00040</span>,</span><br><span class="line">    Normal = <span class="number">0x00080</span>,</span><br><span class="line">    Temporary = <span class="number">0x00100</span>,</span><br><span class="line">    SparseFile = <span class="number">0x00200</span>,</span><br><span class="line">    ReparsePoint = <span class="number">0x00400</span>,</span><br><span class="line">    Compressed = <span class="number">0x00800</span>,</span><br><span class="line">    Offline = <span class="number">0x01000</span>,</span><br><span class="line">    NotContentIndexed = <span class="number">0x02000</span>,</span><br><span class="line">    Encrypted = <span class="number">0x04000</span>,</span><br><span class="line">    IntegrityStream = <span class="number">0x08000</span>,</span><br><span class="line">    NoScrubData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里有个比较方便的用法，可以把enum看做一组Bits。<br>定义enum的时候加上前缀[Flags],可以使enum的成员被看做一组bits。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Flags]</span><br><span class="line"><span class="keyword">enum</span> Actions</span><br><span class="line">&#123;</span><br><span class="line">    NONE = <span class="number">0</span>,</span><br><span class="line">    READ = <span class="number">0x0001</span>,</span><br><span class="line">    WRITE = <span class="number">0x0002</span>,</span><br><span class="line">    READANDWRITE = READ | WRITE,</span><br><span class="line">    DELETE = <span class="number">0x0004</span>,</span><br><span class="line">    QUERY = <span class="number">0x0008</span>,</span><br><span class="line">    Sync = <span class="number">0x0010</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Actions actions = Actions.READ;</span><br><span class="line">    Console.WriteLine(<span class="string">"actions = &#123;0&#125;"</span>, actions.ToString());</span><br><span class="line">    actions = actions | Actions.DELETE;</span><br><span class="line">    Console.WriteLine(<span class="string">"actions = &#123;0&#125;"</span>,actions.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/CSharp/BitWithFlag.PNG" alt="BitWithFlag"><br><img src="/img/CSharp/BitWithoutFlag.PNG" alt="BitWithoutFlag"></p>
<h3 id="Custom_Attributes">Custom Attributes</h3><p>“they’re just a way to associate additional information with a target.The compiler emits this additional information into the managed module’s metadata.”<br>上面这句话可以理解成，custom attributes是为了关联一些额外的信息到特定的目标上(这里的目标可以是class，event，methods…..)，这些额外的信息是被编译器编译保存到了module的metadata里。</p>
<p>让我们看个Custom Attributes例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">[assembly: SomeAttr] // Applied to assembly</span><br><span class="line">[module: SomeAttr] // Applied to module</span><br><span class="line">[type: SomeAttr] // Applied to type</span><br><span class="line">internal sealed class SomeType&lt;[typevar: SomeAttr] T&gt; &#123; // Applied to generic type variable</span><br><span class="line">    [field: SomeAttr] // Applied to field</span><br><span class="line">    public Int32 SomeField = 0;</span><br><span class="line">    [return: SomeAttr] // Applied to return value</span><br><span class="line">    [method: SomeAttr] // Applied to method</span><br><span class="line">    public Int32 SomeMethod(</span><br><span class="line">        [param: SomeAttr] // Applied to parameter</span><br><span class="line">        Int32 SomeParam) </span><br><span class="line">    &#123; </span><br><span class="line">        return SomeParam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [property: SomeAttr] // Applied to property</span><br><span class="line">    public String SomeProp &#123;</span><br><span class="line">        [method: SomeAttr] // Applied to get accessor method</span><br><span class="line">        get &#123; return null; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [event: SomeAttr] // Applied to event</span><br><span class="line">    [field: SomeAttr] // Applied to compiler-generated field</span><br><span class="line">    [method: SomeAttr] // Applied to compiler-generated add &amp; remove methods</span><br><span class="line">    public event EventHandler SomeEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出我们可以定义custom attribute的范围很广，包括assembly，module，type，filed，method…….</p>
<p>“A custom attribute is simply an instance of a type.”<br>Custom attribute其实也是一个类，只是我们定义custom attribute的时候触发了这些类的构造，把custom attribute的信息写入到了metadata里。</p>
<p>那么知道了Custom attribute是一个类，那么怎么定义Custom attribute了？<br>“Common Language Specification (CLS) compliance, custom attribute classes must be derived, directly or indirectly, from the public abstract System.Attribute class.”<br>从上面可以看出custom attribute必须直接或间接的继承至System.Attribute class.</p>
<p><strong>接下来我们使用MSDN上的例子来详细了解下Custom Attribute是怎么工作的。</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CustomAttrCS</span> &#123;</span><br><span class="line">    <span class="comment">// An enumeration of animals. Start at 1 (0 = uninitialized).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Animal &#123;</span><br><span class="line">        <span class="comment">// Pets.</span></span><br><span class="line">        Dog = <span class="number">1</span>,</span><br><span class="line">        Cat,</span><br><span class="line">        Bird,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A custom attribute to allow a target to have a pet.</span></span><br><span class="line">    <span class="comment">// 定义Custom attribute必须直接或间接继承至Attribute</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnimalTypeAttribute</span> : <span class="title">Attribute</span> &#123;</span><br><span class="line">        <span class="comment">// The constructor is called when the attribute is set.</span></span><br><span class="line">        <span class="comment">// 构建的时候我们可以去设置含参和不含参构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimalTypeAttribute</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">           thePet = Animal.Bird;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimalTypeAttribute</span>(<span class="params">Animal pet</span>) </span>&#123;</span><br><span class="line">            thePet = pet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep a variable internally ...</span></span><br><span class="line">        <span class="keyword">protected</span> Animal thePet;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// .. and show a copy to the outside world.</span></span><br><span class="line">        <span class="keyword">public</span> Animal Pet &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> thePet; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; thePet = Pet; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A test class where each method has its own pet.</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">AnimalTypeTestClass</span> &#123;</span><br><span class="line">        <span class="comment">// 定义custom attribute的时候，我们可以调用对应构造函数</span></span><br><span class="line">        [AnimalType(Animals.DOG)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DogMethod</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">        <span class="comment">// 除了调用构造函数外，我们还可以调用Custom Attribute Class的Property设定特定值</span></span><br><span class="line">        [AnimalType(Pet = Animals.CAT)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CatMethod</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        [AnimalType()]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BirdMethod</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">DemoClass</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 通过反射去检查AnimalTypeTestClass里的方法是否定义了Attribute</span></span><br><span class="line">            AnimalTypeTestClass testClass = <span class="keyword">new</span> AnimalTypeTestClass();</span><br><span class="line">            Type type = testClass.GetType();</span><br><span class="line">            <span class="comment">// Iterate through all the methods of the class.</span></span><br><span class="line">            <span class="keyword">foreach</span>(MethodInfo mInfo <span class="keyword">in</span> type.GetMethods()) &#123;</span><br><span class="line">                <span class="comment">// Iterate through all the Attributes for each method.</span></span><br><span class="line">                <span class="keyword">foreach</span> (Attribute attr <span class="keyword">in</span> </span><br><span class="line">                    Attribute.GetCustomAttributes(mInfo)) &#123;</span><br><span class="line">                    <span class="comment">// Check for the AnimalType attribute.</span></span><br><span class="line">                    <span class="keyword">if</span> (attr.GetType() == <span class="keyword">typeof</span>(AnimalTypeAttribute))</span><br><span class="line">                        Console.WriteLine(</span><br><span class="line">                            <span class="string">"Method &#123;0&#125; has a pet &#123;1&#125; attribute."</span>, </span><br><span class="line">                            mInfo.Name, ((AnimalTypeAttribute)attr).Pet);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><img src="/img/CSharp/CustomAttribute.PNG" alt="CustomAttribute"><br>Note:<br>“all non-abstract attributes must contain at least one public constructor.”(非abstract attributes必须至少有一个public构造函数)</p>
<p><strong>知道了如何自定义Custom Attribute，但Attribute可以用于Assembly,module,type…..，我们如何限制其使用的地方了？</strong><br>AttributeUsageAttribute用于指定Custom Attribute的使用范围。<br>AttributeTargets包含了所有可指定的使用范围。<br>同时AttributeTargets还有连个成员变量，m_allowMultiple,m_inherited,前者决定这个attribute是否允许针对同一个target设定多个，后者决定含该attribute修饰的类的子类是否继承AttributeUsage设定。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(AttributeTargets.Method, Inherited = <span class="keyword">false</span>)]<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnimalTypeAttribute</span> : <span class="title">Attribute</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">AnimaTypeTestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为AnimaTypeAttribute定义了只对Method有效，所以这里对构造函数就无效</span></span><br><span class="line">    <span class="comment">//[AnimalType(Animals.CAT)]</span></span><br><span class="line">    <span class="comment">//AnimaTypeTestClass() &#123; &#125;</span></span><br><span class="line"></span><br><span class="line">    [AnimalType(Animals.DOG)]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DogMethod</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>知道了Custom Attribute的定义和其限制作用，那么Custom Attribute有什么实际意义了？</strong><br>还记得在Enumerated Types and Bit Flags讲到的[FLAG]标记改变了Enum.ToString(),Format()行为吗？<br>正是因为我们动态检查了绑定在Enum上的Flag属性导致的。<br>而实现动态检查的底层方法是通过reflection(反射 — 参见Hosting,AppDomain,Assembly,Reflection章节)<br>还记得之前MSDN的例子是如何检查类里各方法是否定义了Attribute吗(这里就是使用了反射)？<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射去检查AnimalTypeTestClass里的方法是否定义了Attribute</span></span><br><span class="line">AnimalTypeTestClass testClass = <span class="keyword">new</span> AnimalTypeTestClass();</span><br><span class="line">Type type = testClass.GetType();</span><br><span class="line"><span class="comment">// Iterate through all the methods of the class.</span></span><br><span class="line"><span class="keyword">foreach</span>(MethodInfo mInfo <span class="keyword">in</span> type.GetMethods()) &#123;</span><br><span class="line">    <span class="comment">// Iterate through all the Attributes for each method.</span></span><br><span class="line">    <span class="keyword">foreach</span> (Attribute attr <span class="keyword">in</span> </span><br><span class="line">        Attribute.GetCustomAttributes(mInfo)) &#123;</span><br><span class="line">        <span class="comment">// Check for the AnimalType attribute.</span></span><br><span class="line">        <span class="keyword">if</span> (attr.GetType() == <span class="keyword">typeof</span>(AnimalTypeAttribute))</span><br><span class="line">            Console.WriteLine(</span><br><span class="line">                <span class="string">"Method &#123;0&#125; has a pet &#123;1&#125; attribute."</span>, </span><br><span class="line">                mInfo.Name, ((AnimalTypeAttribute)attr).Pet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来我们就可以动态的判断是否定义了Attribute并获取Attribute里定义的信息。<br>.NET里有一个System.Reflection.CustomAttributeExtensions class，这个了定义了真多各个target(module,event,method……)的获取关于自定义信息的三个方法:</p>
<ol>
<li>IsDefined</li>
<li>GetCustomAttributes</li>
<li>GetCustomAttribute<br>第二和第三方法调用的时候会触发Attribute Class的构造函数，那么我们怎么才能在不触发Attribute Class构造函数的情况下获取Attrbute信息了？<br>答案是：System.Reflection.CustomAttributeData的GetCustomAttributes方法(利用反射，但要注意的是CustomAttributeData的GetCustomAttributes只有四个版本分别是Assembly,Module, ParameterInfo and MemberInfo)</li>
</ol>
<p><strong>知道了如何去检查method是否包含Custom Attribute，那么我们怎样去判断两个instances完全一样了(所有Custom Attribute都一样)</strong><br>这里我们可以通过System.Attribute的Equals方法去判断，这里的Equals被重写了，会通过reflection去检查每一个attribute进行比较。<br>除了上述方法我们也可以在自定义的Attribute里重写Equal和Match方法去实现特定比较判断。</p>
<p><strong>使用和定义Custom attribute的时候需要注意的点：</strong></p>
<ol>
<li>“When applying an attribute to a target in source code, the C# compiler allows<br>you to omit the Attribute suffix to reduce programming typing and to improve the<br>readability of the source code.”(注意定义custom attribute的时候，我们可以省略attribute后缀)</li>
<li>“When defining an attribute class’s instance constructor, fields, and properties, you must restrict yourself to a small subset of data types.”(当定义Custom Attribute时，我们只能声明基础类型的fields，properties，constructor(必须符合CLS-compilation))</li>
<li>“Be aware that only Attribute, Type, and MethodInfo classes implement reflection<br>methods that honor the Boolean inherit parameter.”(只有Attribute，Type and MethodInfo实现了反射inherit parameter信息的方法)</li>
</ol>
<h3 id="Exceptions_and_State_Management">Exceptions and State Management</h3><p>What is Exception?<br>“An expcetion is when a member fails to complete the task it is supposed to perform as indicated by ites name.”</p>
<p>Exception-Handling Mechanics<br>The .NET Framework exception handling mechanism is built using the Structured Exception Handling(SEH) mechanism offered by Windows.</p>
<p>首先看一下捕获异常的最基本写法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// Put code requiring graceful recovery and/or cleanup operations here...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(excetion)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Put code that recovers from any kind of exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Put code that cleans up any operations started within the try block here...</span></span><br><span class="line">    <span class="comment">// The code in here ALWAYS executes, regardless of whether an exception is thrown.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Try Block:<br>“A try block contains code that requires common cleanup operations, exception recovery operations, or both.”</p>
<p>Note:<br>“Sometimes developers ask how much code they should put inside a single try<br>block. The answer to this depends on state management.”</p>
<p>Catch Block:<br>“A catch block contains code to execute in response to an exception.”</p>
<p>Note:<br>“When debugging through a catch block by using Microsoft Visual Studio, you can<br>see the currently thrown exception object by adding the special $exception variable name to a watch window.”(当调试catch block的时候，可以通过查看$exception变量名查看异常信息)</p>
<p>Finally Block:<br>“A finally block contains code that’s guaranteed to execute. Typically, the code in a finally block performs the cleanup operations required by actions taken in the try block.”</p>
<p>CLS and Non-CLS Exceptions:<br>CLS(Common Language Specification) — throw Exception-derived objects<br>Non-CLS — throw Exception not derived from Exception</p>
<p>After CLR 2.0:<br>“Microsoft introduced a new RuntimeWrappedException class (defined in the System.Runtime.CompilerServices namespace). This class is derived from Exception, so it is a CLS-compliant exception type. The RuntimeWrappedException class contains a private field of type Object (which can be accessed by using RuntimeWrappedException’s WrappedException read-only property). In CLR 2.0, when a non–CLS-compliant exception is thrown, the CLR automatically constructs an instance of the RuntimeWrappedException class and initializes its private field to refer to the object that was actually thrown.”(CLR 2.0之后，通过RuntimeWrapperdException class把所有的Non-CLS Exception都封装成了CLS Exception)</p>
<p>如果想要就支持2.0之前的行为：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line">[assembly:RuntimeCompatibility(WrapNonExceptionThrows = <span class="keyword">false</span>)]</span><br></pre></td></tr></table></figure></p>
<p>接下来让我们看看Exception的基类：<br>Systen.Exception<br>以下是一些重要的Properties：<br><img src="/img/CSharp/ExceptionProperties.PNG" alt="ExceptionProperties"><br>必要重要的一些Properties：</p>
<ol>
<li>Message(描述了和异常相关的重要信息)</li>
<li>StackTrace(描述了导致抛出异常的方法相关信息)</li>
</ol>
<p>我们也可以通过System.Diagnostics.StackTrace去获取详细的堆栈信息。</p>
<p>但有些时候我们会发现有些方法没有显示在详细的堆栈信息里：<br>原因有两个：</p>
<ol>
<li>the stack is really a record of where the thread should return to, not where the thread has come from. (Stack只记录返回点不记录当前点)</li>
<li>The just-in-time (JIT) compiler can inline methods to avoid the overhead of calling and returning from a separate method(JIT编译器使得一些方法称为了inlie的(在当前方法被调用的地方直接展开)，从而无法记录到Stack里)</li>
</ol>
<p>禁止JIT inlie需要用到System.Runtime.CompilerServices.MethodImplAttribute里的MethodImplOption.NoInlining:<br>``CS<br>[MethodImpl(MethodImplOptions.NoInlining)]<br>public void SomeMethod() {<br>    ……<br>}<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FCL(Framework Class Library)里定义很多现成的Exception。</span><br><span class="line"></span><br><span class="line">Throwing an <span class="attribute">Exception</span>:</span><br><span class="line">当我们需要自己抛出异常的时候，我们需要考虑如下：</span><br><span class="line"><span class="number">1.</span> 哪一个Exccetion <span class="class"><span class="keyword">class</span>我们应该继承(是否使用现有的<span class="title">Exception</span> <span class="title">class</span>)</span></span><br><span class="line"><span class="number">2.</span> 传递什么样的string到exception构造函数里(传递说明为什么方法不能完成要抛出这个异常)</span><br><span class="line"></span><br><span class="line">Defining Your Own Exception <span class="attribute">Class</span>:</span><br><span class="line">自定义Exception类是比较容易出问题且冗长的。</span><br><span class="line">原因如下：</span><br><span class="line"><span class="string">"The main reason for this is because all Exception-derived types should be serializable so that they can cross an AppDomain boundary or be written to a log or database"</span>(我们必须保证自定义的Exception类支持序列化，因为我们可能会跨AppDomain去写入Log或则数据库里)</span><br><span class="line"></span><br><span class="line">Note：</span><br><span class="line"><span class="string">"When you throw an exception, the CLR resets the starting point for the exception;</span><br><span class="line">that is, the CLR remembers only the location where the most recent exception object</span><br><span class="line">was thrown."</span>(当我们再次抛出异常的时候，CLR会重置异常，只记录最近异常Object)</span><br><span class="line"></span><br><span class="line">Guidelines <span class="keyword">and</span> Best <span class="attribute">Practices</span>:</span><br><span class="line"><span class="number">1.</span> Use <span class="keyword">finally</span> Blocks Liberally(finlly always execute, <span class="keyword">do</span> cleanup operations)</span><br><span class="line"><span class="number">2.</span> Do <span class="keyword">not</span> Catch Everything</span><br><span class="line"><span class="number">3.</span> Recovering Gracefully from an Exception(<span class="keyword">catch</span> some exceptions that are known <span class="keyword">in</span> advanced <span class="keyword">and</span> <span class="keyword">try</span> to recover from it)</span><br><span class="line"><span class="number">4.</span> Backing Out <span class="keyword">of</span> a Partially Completed Operation When an Unrecoverble Exception Occus -- Maintaining State</span><br><span class="line">`<span class="javascript"></span>``<span class="javascript">CS</span><br><span class="line">public <span class="keyword">void</span> SerializeObjectGraph(FileStream fs, IFormatter formatter, <span class="built_in">Object</span> rootObj) &#123;</span><br><span class="line">    <span class="comment">// Save the current position of the file.</span></span><br><span class="line">    Int64 beforeSerialization = fs.Position;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Attempt to serialize the object graph to the file.</span></span><br><span class="line">        formatter.Serialize(fs, rootObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123; <span class="comment">// Catch any and all exceptions.</span></span><br><span class="line">        <span class="comment">// If ANYTHING goes wrong, reset the file back to a good state.</span></span><br><span class="line">        fs.Position = beforeSerialization;</span><br><span class="line">        <span class="comment">// Truncate the file.</span></span><br><span class="line">        fs.SetLength(fs.Position);</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The preceding code isn't in a finally block because</span></span><br><span class="line">        <span class="comment">// the stream should be reset only when serialization fails.</span></span><br><span class="line">        <span class="comment">// Let the caller(s) know what happened by re-throwing the SAME exception.</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<pre><code><span class="class">Note</span>：
<span class="comment">"After you’ve caught and handled the exception, don’t swallow it—let the caller know that the exception occurred. You do this by re-throwing the same exception."</span>(特别是写给别人用的时候，再次抛出异常让使用者可以去捕获并知道发生了什么)
</code></pre><ol>
<li>Hiding an Implementation Detail to Maintain a “Contract”<br>“you might find it useful to catch one exception and re-throw a different exception.”(抛出更符合当前API行为的异常。或则增加更多符合当前API的异常的信息。)</li>
</ol>
<p>Unhandled Exceptions：<br>什么时候会出现Unhandled Exceptions？<br>“When an exception is thrown, the CLR climbs up the call stack looking for catch blocks that match the type of the exception object being thrown. If no catch block matches the thrown exception type, an unhandled exception occurs.”(当异常被抛出却没有对应的catch的时候，成为Unhandled Exception)<br>更多内容参考《CLR via C#》 — Unhandled Exceptions</p>
<p>Note:<br>“When the CLR detects that any thread in the process has had an unhandled exception, the CLR terminates the process.”(当CLR检测到任何线程有未处理的异常的时候，CLR会终止进程)</p>
<p>Debugging Exceptions:<br>VS -&gt; Debug -&gt; Exception<br><img src="/img/CSharp/ExceptionWindow.PNG" alt="ExceptionWindow"><br>如果针对特定异常勾选抛出，那么当该异常被抛出的会后，程序会进入断点(帮助我们快速定位特定异常)。不勾选也会进入断点(前提是该异常是unhandled)</p>
<p>也可以通过上述窗口添加自定义的异常。</p>
<p>Exception-Handling Performance Considerations:<br>……</p>
<p>Constrained Excecution Regions(CERs):<br>……</p>
<p>更多内容待学习……</p>
<h3 id="The_Managed_Heap_and_Garbage_Collection">The Managed Heap and Garbage Collection</h3><p>这一小节会讲到CLR里重要的内存管理(GC)。<br>首先要区分栈(Stack)和堆(Heap)。<br>下面堆栈的学习参考<a href="http://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-i/" target="_blank" rel="external">C# Heap(ing) Vs Stack(ing) in .NET: Part I</a><br>栈 — <a href="http://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-i/" target="_blank" rel="external">The Stack is more or less responsible for keeping track of what’s executing in our code (or what’s been “called”).</a><br>这里栈可以理解为用于记录代码执行顺序。<br>Note:<br>栈是LIFO(Last In First Out)原则。<br>堆 — <a href="http://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-i/" target="_blank" rel="external">The Heap is more or less responsible for keeping track of our objects (our data, well… most of it;)</a><br>堆是记录那些动态分配内存的(比如reference type)<br>哪些是分配在栈上，哪些分配在堆上，记住下面两个原则：</p>
<ol>
<li>A Reference Type always goes on the Heap; easy enough, right? (索引类型都是分配在堆上)</li>
<li>Value Types and Pointers always go where they were declared. This is a little more complex and needs a bit more understanding of how the Stack works to figure out where “things” are declared. (值类型和指针是分配在栈上)<br>下面让我们结合实例来看一下是如何分配在栈和堆上的？<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInt</span></span><br><span class="line">&#123;         </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> MyValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyInt <span class="title">AddFive</span>(<span class="params"><span class="keyword">int</span> pValue</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    MyInt result = <span class="keyword">new</span> MyInt();</span><br><span class="line">    result.MyValue = pValue + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当调用AddFive方法的时候，首先函数参数pValue会入栈<br><img src="/img/CSharp/StackAndHeapPart1.PNG" alt="StackAndHeapPart1"><br>然后因为我们创建了索引类型的MyInt实例，这时候MyInt会在堆上分配内存，同时在栈上会生成一个指针指向MyInt在堆上的索引地址<br><img src="/img/CSharp/StackAndHeapPart2.PNG" alt="StackAndHeapPart2"><br>当我们给result.MyValue赋值时，我们通过result Pointer记录的地址去访问堆上的MyValue成员并修改值。<br>最后我们返回result时，栈被清理，只剩下堆上我们分配的数据。<br><img src="/img/CSharp/StackAndHeapPart3.PNG" alt="StackAndHeapPart3"><br>而剩下堆上的数据，就是由CLR的GC来管理了。<br>NOTE :<br>“The method does not live on the stack and is illustrated just for reference.”<br>接下来看看CLR的GC是如何工作的。<br>在了解GC之前，让我们看看C#里在堆上分配内存是如何分配的？<br>这里就不得不提new这个关键字了。<br>当我们通过new去创建reference type的时候，会经历下列步骤:</p>
<ol>
<li>Calculate the number of bytes required for the type’s fields)(计算type所需分配的内存)</li>
<li>Add the bytes required for an object’s overhead(contain a type object pointer and a sync block index)(为type分配object pointer和sync block index所需内存 — 如果是32-bit Application则分配8 bytes，如果是64-bit Application则分配16 bytes)</li>
<li>Zero out the memory start at NextObjPtr(Indicates where the next object is to be allocated within the heap). Return reference. Move on NextObjPtr to next address that is available to be allocated..(根据NextObjPtr指向的可用堆上的起始位置分配内存并清零，然后传递指向type的内存起始位置的NextObjPtr到构造函数去进行初始化，初始化完成后返回type的索引，最后把NextObjPtr指向下一个heap可分配内存的位置。)<br>知道了我们在堆上是如何分配内存，让我们看看GC是如何工作来管理所有堆上分配的内存的？</li>
</ol>
<p>让我们来了解下GC Algorithm：</p>
<ol>
<li>Reference Counting Algorithm(COM use)<br>就是我们平时说的索引计数，通过判断当前所有指针指向特定对象的数量来决定是否要回收该对象内存。<br>缺点：<br>Circular references会导致内存永远无法回收(e.g. A包含了B的索引，B也包含了A的索引)</li>
<li>Reference Tracking Algorithm(<strong>CLR use. Cares only about reference type variables</strong>)<br> 步骤如下：<ol>
<li>Marking Phase<br>CLR first suspends all threads in the process(prevents threads from accessing objects and changing their state while the CLR examines them)<br>Marking All objects to 0(means all objects should be deleted)<br>Scan active roots to marking object(not mark the same object again to avoid circular references)<br>标记阶段，首先悬挂所有线程防止访问Objects和相关状态。<br>然后标记所有在堆上对象的引用为0，然后扫描所有active的roots(即reference type variables — 引用类型的变量)，如果有roots指向任何一个堆上的Object，就标记该Object并对该Object内部的roots进行扫描标记。这里最重要的一点就是对标记过的Object不会再扫描内部root(比如有roots指向了A，我们标记了A，然后检查A内部发现B，因为B还没被标记所以标记B并检查B内部，在B内部又发现了A但因为A已经被标记了，所以不会再次标记A，这样一来如果最初指向A的roots不存在了的话，A和B都会因为没有引用不会被标记而清除。这样一来就避免了Circular references)<br>Note:<br>“Refer to all reference type variables as roots.”</li>
<li>Compacting Phase<br>Shifts the memory consumed by the marked objects down in the heap, compacting all the surviving objects together so that they are contiguous in memory.(reduce application’s working set size &amp;access fast in future &amp; no address space fragmentation issues)<br>CLR resumes all the application’s threads and they continue to access the objects as if the GC never happened at all<br>Note:<br>A static field keeps whatever object it refers to forever or until the AppDomain that the types are loaded into is unloaded<br>在标记阶段完成后，所有标记为0的堆上对象内存都会被回收。<br>压缩阶段主要是为了内存的高效利用(防止内存碎片化)。<br>要注意的是静态变量在内存中的位置不会改变。</li>
</ol>
</li>
</ol>
<p>接下来看看如何提升GC的performance：<br>CLR’s GC assumptions(提升GC性能的最基本假设):<br>The newer an object is, the shorter its lifetime will be(越新的对象lifetime越短)<br>The older an object is, the longer its lifetime will be(越旧的对象lifetime越长)<br>Collecting a portion of the heap is faster than collecting the whole heap(GC一部分heap比GC所有heap快)<br>基于上述理论：<br>Heap被分为了Generation 0,1,2。<br><img src="/img/CSharp/GCGenerations.png" alt="GCGenerations"><br>最初创建的对象会存放在generation 0，GC首先检查Generation 0的对象，objects在通过第一次GC后会提升到generation 1，当generation 1对象数量超过generation 0的时候，GC就会检查generation 0和1，同理当 object从generation 1存活下来后会被存放到generation 2。<br>通过上述方式，我们GC就不必每次都对整个heap的对象进行检查以达到GC优化的目的。<br>Note:<br>The Managed heap supports only three generations: generation 0,1,2<br>The garbage collector fine-tunes itself automatically based on the memory load required by your application.<br>关于更多GC的学习详情参考《CLR vir C#》 — The Managed Heap and Garbage Collection章节<br>Note:<br>Finalize methods are called at the completion of a garbage collection on objects that the GC has determined to be garbage.(Object的Finalize方法是在Object在完成内存被回收之前调用)<br>Finalize is not equal to destructor in C++(Finalize!=C++的析构函数)</p>
<p>参考书籍下载：<br><a href="http://download.csdn.net/download/baiyu9821179/4282298" target="_blank" rel="external">《C#入门经典第五版》</a><br>《CLR Via C# Fourth Edition》 - Jeffrey Richter</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Programming-Language/">Programming Language</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Programming/">Programming</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2015/08/15/CSharp-Study/" data-title="C# Study | 走停人生路" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/26/OpenGL-Study/" title="OpenGL_Study">
  <strong>上一篇：</strong><br/>
  <span>
  OpenGL_Study</span>
</a>
</div>


<div class="next">
<a href="/2015/07/15/Unity-Study/"  title="Unity Study">
 <strong>下一篇：</strong><br/> 
 <span>Unity Study
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/15/CSharp-Study/" data-title="C# Study" data-url="http://tonytang1990.github.io/2015/08/15/CSharp-Study/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#-Net_Framework"><span class="toc-number">1.</span> <span class="toc-text">.Net Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content"><span class="toc-number">1.2.</span> <span class="toc-text">Content</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using_-NET_Framework"><span class="toc-number">1.3.</span> <span class="toc-text">Using .NET Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tools"><span class="toc-number">1.3.1.</span> <span class="toc-text">Tools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关概念"><span class="toc-number">1.3.2.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FCL(Framework_Class_Library)"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">FCL(Framework Class Library)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metadata"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IL(Intermediate_Language)"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">IL(Intermediate Language)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLI(Common_Language_Infrastructure)"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">CLI(Common Language Infrastructure)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLR(Common_Language_Runtime)"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">CLR(Common Language Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CTS(Common_Type_System)"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">CTS(Common Type System)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLS(Common_Language_Specification)"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">CLS(Common Language Specification)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compile_process"><span class="toc-number">1.3.3.</span> <span class="toc-text">Compile process</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Managed_Module"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Managed Module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executing_Assembly_Code"><span class="toc-number">1.3.4.</span> <span class="toc-text">Executing Assembly Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序集"><span class="toc-number">1.3.5.</span> <span class="toc-text">程序集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#托管代码"><span class="toc-number">1.3.6.</span> <span class="toc-text">托管代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收"><span class="toc-number">1.3.7.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接"><span class="toc-number">1.3.8.</span> <span class="toc-text">链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp"><span class="toc-number">2.</span> <span class="toc-text">CSharp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-1"><span class="toc-number">2.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Features"><span class="toc-number">2.2.</span> <span class="toc-text">Features</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Development"><span class="toc-number">2.3.</span> <span class="toc-text">Development</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Language_Study"><span class="toc-number">2.4.</span> <span class="toc-text">Language Study</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delegate"><span class="toc-number">2.4.1.</span> <span class="toc-text">delegate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_&_interface"><span class="toc-number">2.4.2.</span> <span class="toc-text">Class & interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Not_supported_multiple_inherit"><span class="toc-number">2.4.3.</span> <span class="toc-text">Not supported multiple inherit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class_member"><span class="toc-number">2.4.4.</span> <span class="toc-text">Class member</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Struct_&_Class"><span class="toc-number">2.4.5.</span> <span class="toc-text">Struct & Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection_class_(System-Collection)"><span class="toc-number">2.4.6.</span> <span class="toc-text">Collection class (System.Collection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-number">2.4.7.</span> <span class="toc-text">Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparasion"><span class="toc-number">2.4.8.</span> <span class="toc-text">Comparasion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conversion"><span class="toc-number">2.4.9.</span> <span class="toc-text">Conversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generics"><span class="toc-number">2.4.10.</span> <span class="toc-text">Generics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hosting,_AppDomain,_Assembly,_Reflection"><span class="toc-number">2.4.11.</span> <span class="toc-text">Hosting, AppDomain, Assembly, Reflection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hosting"><span class="toc-number">2.4.11.1.</span> <span class="toc-text">Hosting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AppDomain"><span class="toc-number">2.4.11.2.</span> <span class="toc-text">AppDomain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Assembly_Loading"><span class="toc-number">2.4.11.3.</span> <span class="toc-text">Assembly Loading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflection"><span class="toc-number">2.4.11.4.</span> <span class="toc-text">Reflection</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime_Serialization"><span class="toc-number">2.4.12.</span> <span class="toc-text">Runtime Serialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Platform_Invoke"><span class="toc-number">2.4.13.</span> <span class="toc-text">Platform Invoke</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event"><span class="toc-number">2.4.14.</span> <span class="toc-text">Event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chars,_Strings,_and_Working_with_Text"><span class="toc-number">2.4.15.</span> <span class="toc-text">Chars, Strings, and Working with Text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enumerated_and_Bit_Flags"><span class="toc-number">2.4.16.</span> <span class="toc-text">Enumerated and Bit Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom_Attributes"><span class="toc-number">2.4.17.</span> <span class="toc-text">Custom Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exceptions_and_State_Management"><span class="toc-number">2.4.18.</span> <span class="toc-text">Exceptions and State Management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The_Managed_Heap_and_Garbage_Collection"><span class="toc-number">2.4.19.</span> <span class="toc-text">The Managed Heap and Garbage Collection</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game-Engine/" title="Game_Engine">Game_Engine<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sort/" title="Sort">Sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shader/" title="Shader">Shader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Tony Tang. <br/>
			This is my new blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"TonyTang1990"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
