
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Unity_Shader | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="参考书籍《Unity Shader 入门精要》 — 冯乐乐(一位在图形渲染方面很厉害的女生)
使用的Unity版本：Unity 5.4.0f3
Rendering关于图形渲染相关知识以及OpenGL相关学习参见：Computer_Graphic_StudyOpenGL_Study
Unity Shader首先让我们通过官网的一张图来看看Unity Shader里面占据重要地位的3D Model,M">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity_Shader">
<meta property="og:url" content="http://tonytang1990.github.io/2016/12/20/Unity-Shader/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="参考书籍《Unity Shader 入门精要》 — 冯乐乐(一位在图形渲染方面很厉害的女生)
使用的Unity版本：Unity 5.4.0f3
Rendering关于图形渲染相关知识以及OpenGL相关学习参见：Computer_Graphic_StudyOpenGL_Study
Unity Shader首先让我们通过官网的一张图来看看Unity Shader里面占据重要地位的3D Model,M">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/UnityShaderFundamention.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/UnityShaderProperty.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderFlowChart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithAlbedoSetting.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderMaterialEditorWithTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithNormalMap.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithEmssion.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithNegativeExtrusion.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithPositiveExtrusion.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SurfaceShaderWithFinalColorFunction.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/UnityShaderSettingPanel.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/UnityBuildInShaderFolderStructure.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/LightModelShader.JPG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/LightmapChart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/MultipleUVShells.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SingleUIShell.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/UVChart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SpecificObjectUVChart.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/UVChartDistortionAnalysi.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/ClusterPicture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/LightMapParameter.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/LightmapBake.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/LightMapData.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/LightMapRestore.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/TextureMaxSize.JPG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/SimpleTextureShader.JPG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/TextureMipmapImportSetting.JPG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/NormalMappingTextureShader.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RampTexture.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/MaskTexture.PNG">
<meta property="og:updated_time" content="2018-04-01T04:25:27.431Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unity_Shader">
<meta name="twitter:description" content="参考书籍《Unity Shader 入门精要》 — 冯乐乐(一位在图形渲染方面很厉害的女生)
使用的Unity版本：Unity 5.4.0f3
Rendering关于图形渲染相关知识以及OpenGL相关学习参见：Computer_Graphic_StudyOpenGL_Study
Unity Shader首先让我们通过官网的一张图来看看Unity Shader里面占据重要地位的3D Model,M">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">做着独立游戏梦，坚持走在游戏开发道路上的人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/20/Unity-Shader/" title="Unity_Shader" itemprop="url">Unity_Shader</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2016-12-19T16:35:50.000Z" itemprop="datePublished"> 發表於 2016-12-20</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Rendering"><span class="toc-number">1.</span> <span class="toc-text">Rendering</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity_Shader"><span class="toc-number">2.</span> <span class="toc-text">Unity Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Surface_Shaders"><span class="toc-number">2.1.</span> <span class="toc-text">Surface Shaders</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vertex_and_Fragment_Shaders"><span class="toc-number">2.2.</span> <span class="toc-text">Vertex and Fragment Shaders</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity_Shader入门精要"><span class="toc-number">3.</span> <span class="toc-text">Unity Shader入门精要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染管线"><span class="toc-number">3.1.</span> <span class="toc-text">渲染管线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity_Shader基础"><span class="toc-number">3.2.</span> <span class="toc-text">Unity Shader基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#材质和Unity_Shader"><span class="toc-number">3.2.1.</span> <span class="toc-text">材质和Unity Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ShaderLab"><span class="toc-number">3.2.2.</span> <span class="toc-text">ShaderLab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity_Shader结构"><span class="toc-number">3.2.3.</span> <span class="toc-text">Unity Shader结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学相关知识"><span class="toc-number">3.3.</span> <span class="toc-text">数学相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity_Shader学习之旅"><span class="toc-number">3.4.</span> <span class="toc-text">Unity Shader学习之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个最简单的顶点/片元着色器"><span class="toc-number">3.4.1.</span> <span class="toc-text">一个最简单的顶点/片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity内置文件和变量"><span class="toc-number">3.4.2.</span> <span class="toc-text">Unity内置文件和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CG/HLSL语义"><span class="toc-number">3.4.3.</span> <span class="toc-text">CG/HLSL语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader_Debugger"><span class="toc-number">3.4.4.</span> <span class="toc-text">Shader Debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Color_Info"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">Color Info</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity_Frame_Debugger"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">Unity Frame Debugger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VS_Graphics_Debugger"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">VS Graphics Debugger</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NVIDIA_NSight"><span class="toc-number">3.4.5.</span> <span class="toc-text">NVIDIA NSight</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity中的基础光照"><span class="toc-number">3.5.</span> <span class="toc-text">Unity中的基础光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#光照知识回顾"><span class="toc-number">3.5.1.</span> <span class="toc-text">光照知识回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准光照模型"><span class="toc-number">3.5.2.</span> <span class="toc-text">标准光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漫反射光照模型"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">漫反射光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#兰伯特光照模型"><span class="toc-number">3.5.2.1.1.</span> <span class="toc-text">兰伯特光照模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#半兰伯特(Half_Lambert)光照模型"><span class="toc-number">3.5.2.1.2.</span> <span class="toc-text">半兰伯特(Half Lambert)光照模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高光反射光照模型"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">高光反射光照模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lighting_in_Unity"><span class="toc-number">3.5.3.</span> <span class="toc-text">Lighting in Unity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Realtime_Lighting"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">Realtime Lighting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Precomputed_Lighting"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">Precomputed Lighting</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bake_Realtime_Lighting实战"><span class="toc-number">3.5.3.2.1.</span> <span class="toc-text">Bake Realtime Lighting实战</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render_Path"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">Render Path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Color_Space"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">Color Space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High_Dynamic_Range"><span class="toc-number">3.5.4.</span> <span class="toc-text">High Dynamic Range</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础纹理"><span class="toc-number">3.6.</span> <span class="toc-text">基础纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理类型分类"><span class="toc-number">3.6.1.</span> <span class="toc-text">纹理类型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Delfaut(Advanced)"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">Delfaut(Advanced)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal_Map"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">Normal Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sprite"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">Sprite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lightmap"><span class="toc-number">3.6.1.4.</span> <span class="toc-text">Lightmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理大小"><span class="toc-number">3.6.2.</span> <span class="toc-text">纹理大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片格式"><span class="toc-number">3.6.3.</span> <span class="toc-text">图片格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理压缩方式"><span class="toc-number">3.6.4.</span> <span class="toc-text">纹理压缩方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity纹理使用"><span class="toc-number">3.6.5.</span> <span class="toc-text">Unity纹理使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#纹理的基础使用"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">纹理的基础使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mipmap"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">Mipmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#凹凸映射"><span class="toc-number">3.6.5.3.</span> <span class="toc-text">凹凸映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Height_Map"><span class="toc-number">3.6.5.3.1.</span> <span class="toc-text">Height Map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Normal_Mapping"><span class="toc-number">3.6.5.3.2.</span> <span class="toc-text">Normal Mapping</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ramp_Texture(渐变纹理)"><span class="toc-number">3.6.5.3.3.</span> <span class="toc-text">Ramp Texture(渐变纹理)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mask_Texture(遮罩纹理)"><span class="toc-number">3.6.5.3.4.</span> <span class="toc-text">Mask Texture(遮罩纹理)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#透明效果"><span class="toc-number">3.7.</span> <span class="toc-text">透明效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website"><span class="toc-number">4.</span> <span class="toc-text">Reference Website</span></a></li></ol>
		
		</div>
		
		<p>参考书籍《Unity Shader 入门精要》 — 冯乐乐(一位在图形渲染方面很厉害的女生)</p>
<p>使用的Unity版本：<br>Unity 5.4.0f3</p>
<h1 id="Rendering">Rendering</h1><p>关于图形渲染相关知识以及OpenGL相关学习参见：<br><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/">Computer_Graphic_Study</a><br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/">OpenGL_Study</a></p>
<h1 id="Unity_Shader">Unity Shader</h1><p>首先让我们通过官网的一张图来看看Unity Shader里面占据重要地位的3D Model,Material,Shader之间的关系：<br><img src="/img/Unity/UnityShaderFundamention.PNG" alt="UnityShaderFundamention"><br>可以看出Material会决定使用哪些Texture和Shader去渲染Model。<br>Shader是针对Texture和Model去做运算的地方。</p>
<p>Unity Shader最主要的有两种(还有Image Effect Shader,Computer Shader等后续会学习)：</p>
<ol>
<li><p>Surface shader<br>Time to use — “Whenever the material you want to simulate needs to be affected by lights in a realistic way, chances are you’ll need a surface shader. Surface shaders hide the calculations of how light is reflected and allows to specify “intuitive” properties such as the albedo, the normals, the reflectivity and so on in a function called surf.”<br>可以看出Unity的Surface Shader帮我们把光照对物体的影响的计算抽象了出来。我们只需设定一些控制系数，然后通过Surface Shader的surf方法就能触发光照作用对表面的运算。<br>下面简单看下官网给出的Surface Shader Code：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">// Uses the Lambertian lighting model</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line"></span><br><span class="line">sampler2D _MainTex; <span class="comment">// The input texture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Input &#123;</span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>) </span>&#123;</span><br><span class="line">    o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure>
<p> Note:<br> 必须使用#pragma surface去表示是surface shader<br> Surface Shader的Code是包含在SubShader里的并且必须写在CGPROGRAM和ENDCG标识之间。</p>
</li>
<li>Fragment and Vertex Shaders<br>Fragment and Vertex Shaders就跟OpenGL里差不多，model的vertex会经历完整的Shader Pipeline，最终通过计算得出最终的颜色。<br>让我们来看看官网给出的Fragment and Vertex Shaders Code:<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert             </span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> vertInput &#123;</span><br><span class="line">        float4 pos : POSITION;</span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> vertOutput &#123;</span><br><span class="line">        float4 pos : SV_POSITION;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vertOutput <span class="title">vert</span>(<span class="params">vertInput input</span>) </span>&#123;</span><br><span class="line">        vertOutput o;</span><br><span class="line">        o.pos = mul(UNITY_MATRIX_MVP, input.pos);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">half4 <span class="title">frag</span>(<span class="params">vertOutput output</span>) : COLOR </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> half4(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看出vert方法好比OpenGL里vertex shader的main函数入口。<br>frag方法好比OpenGL里fragment shader的main函数入口。<br>这里frag方法return的half4相当于OpenGL FS里的FragColor。<br>可以看出我们还是需要在VS里先将vertex变换到透视投影坐标系，然后最后传递给FS，FS计算出最终的颜色。<br>Note：<br>这里需要注意的一点是，在VS和FS Shader里，code是包含在Pass {…..}里的。</p>
<p>让我们来看看官网给出的Shader的大体结构：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"MyShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The properties of your shaders</span></span><br><span class="line">        <span class="comment">// - textures</span></span><br><span class="line">        <span class="comment">// - colours</span></span><br><span class="line">        <span class="comment">// - parameters</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The code of your shaders</span></span><br><span class="line">        <span class="comment">// - surface shader</span></span><br><span class="line">        <span class="comment">//    OR</span></span><br><span class="line">        <span class="comment">// - vertex and fragment shader</span></span><br><span class="line">        <span class="comment">//    OR</span></span><br><span class="line">        <span class="comment">// - fixed function shader</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Properties:<br>“The properties of your shader are somehow equivalent to the public fields in a C# script; they’ll appear in the inspector of your material, giving you the chance to tweak them.”<br>从这里看出Properties在Unity里相当于OPENGL Shader里定义的Uniform，Sampler，全局变量等，用于作为可控的输入。<br>让我们来看看官网给出的例子<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _MyTexture (<span class="string">"My texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">    _MyNormalMap (<span class="string">"My normal map"</span>, <span class="number">2</span>D) = <span class="string">"bump"</span> &#123;&#125;  <span class="comment">// Grey</span></span><br><span class="line"></span><br><span class="line">    _MyInt (<span class="string">"My integer"</span>, Int) = <span class="number">2</span></span><br><span class="line">    _MyFloat (<span class="string">"My float"</span>, Float) = <span class="number">1.5</span></span><br><span class="line">    _MyRange (<span class="string">"My range"</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    _MyColor (<span class="string">"My colour"</span>, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)    <span class="comment">// (R, G, B, A)</span></span><br><span class="line">    _MyVector (<span class="string">"My Vector4"</span>, Vector) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// (x, y, z, w)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们先看看对应显示在Unity面板是什么模样：<br><img src="/img/Unity/UnityShaderProperty.PNG" alt="UnityShaderProperty"><br>2D代表_MyTexture,_MyNormalMap是texture类型.Color代表颜色。Range代表范围值……<br>可以看到Properties里定义的变量都显示在了Unity面板里用于控制。但是真正通过Shader去访问，我们还需要在SubShader里重新定义对应的变量。<br>SubShader：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code of the shader</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sampler2D _MyTexture;</span><br><span class="line">    sampler2D _MyNormalMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _MyInt;</span><br><span class="line">    <span class="keyword">float</span> _MyFloat;</span><br><span class="line">    <span class="keyword">float</span> _MyRange;</span><br><span class="line">    half4 _MyColor;</span><br><span class="line">    float4 _MyVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code of the shader</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出Texture在Unity Shader里面的定义和在OpenGL Shader里差不多，也是通过sampler2D，只是不再需要加uniform修饰了。<br>这里值得注意的是Color对应的不是Vector4而是half4。<br>还有就是在Properties里定义的变量名在SubShader要一一对应。</p>
<p>接下来让我们看看官网给出的SubShader里Shader具体是怎样的格式：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Tags</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Queue"</span> = <span class="string">"Geometry"</span></span><br><span class="line">        <span class="string">"RenderType"</span> = <span class="string">"Opaque"</span></span><br><span class="line">    &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="comment">// Cg / HLSL code of the shader</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的Shader Code是在CGPROGRAM和ENGCG里。<br>这里需要先提一下Tags的作用，Tags是为了告诉Unity我们Shader的特定属性(比如RenderType-渲染类型，Queue—渲染顺序)。</p>
<h2 id="Surface_Shaders">Surface Shaders</h2><p>让我们看看Surface Shader的大体流程：<br><a href="http://www.alanzucconi.com/2015/06/17/surface-shaders-in-unity3d/" target="_blank" rel="external">下图来源</a><br><img src="/img/Unity/SurfaceShaderFlowChart.PNG" alt="SurfaceShaderFlowChart"><br>从上图可以看出，Surace Shader通过Surface function生成最终参与光照计算所需的数据(rendering properties — e.g. texture……)。</p>
<p>让我们来看看Surface Shader里的关键组成部分：</p>
<ol>
<li>Surface function<br>Surface function把model data作为输入，把rendering properties作为输出，这些rendering properties最后会参与光照的计算得到最终颜色。</li>
<li>Input<br>Input structure一般包含了texture相关的信息(比如 UV坐标信息)，也可以包含一些额外信息(<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html" target="_blank" rel="external">参见</a>)<br>Note:<br>定义texture coordinate的时候必须以uv或者uv2开头加texture名字。</li>
<li><p>SurfaceOutput<br>SurfaceOutput描述了surface的属性，这些属性最终会参与光照计算。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SurfaceOutput</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 Albedo;  <span class="comment">// diffuse color</span></span><br><span class="line">    fixed3 Normal;  <span class="comment">// tangent space normal, if written</span></span><br><span class="line">    fixed3 Emission;</span><br><span class="line">    half Specular;  <span class="comment">// specular power in 0..1 range</span></span><br><span class="line">    <span class="keyword">fixed</span> Gloss;    <span class="comment">// specular intensity</span></span><br><span class="line">    <span class="keyword">fixed</span> Alpha;    <span class="comment">// alpha for transparencies</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 我们可以通过Shader去计算上面参与光照计算的属性去影响Surface的最终效果，从而达到Surface Shader的真正目的。</p>
</li>
<li>Light Model<br>Light Model是真正通过SurfaceOutput属性去计算光照的地方，通过使用或编写不同的Light Model我们可以实现不同的光照影响效果。<br>那么如何定义光照运算函数了？<ol>
<li>half4 Lighting<name> (SurfaceOutput s, half3 lightDir, half atten);<br>因为没有viewDir所以这里是用于不需要知道观察点的Ambient光照计算</name></li>
<li>half4 Lighting<name> (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);<br>因为有了viewDir，知道了观察点信息，我们可以计算出需要知道观察点的Diffuse和Specular光照。</name></li>
<li>half4 Lighting<name>_PrePass (SurfaceOutput s, half4 light);<br>这个用于Deferer Shading(但这里我比较好奇的是如果要计算Diffuse和Specular光照还是需要知道lightDir和viewDir等信息才对。)<br>Note：<br>自定义光照模型的时候，我们不需要定义所有的光照函数，只需定义我们需要的即可。</name></li>
</ol>
</li>
<li><p>Vertex Function<br>Provide the ability to change vertices before sending them to surf.<br>定义方式如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span>(<span class="params">inout appdata_full v</span>)</span>&#123;......&#125;</span><br></pre></td></tr></table></figure>
<p> appdata_full包含了所有vertex相关的信息</p>
</li>
<li>Finalcolor Function<br>用于对经过Surface Shader处理后的pixel进行最后的处理。<br>格式如下：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert finalcolor:mycolor</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mycolor</span> (<span class="params">Input IN, SurfaceOutput o, inout fixed4 color</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    color *= _ColorTint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>接下来让我们通过创建自己的Surface Shader来感受下Surface Shader实际运用效果(这里我拿了SurviveShooter里的模型做输入)：</strong><br>以下学习参考至<a href="http://www.alanzucconi.com/2015/06/17/surface-shaders-in-unity3d/" target="_blank" rel="external">Surface shaders in Unity3D</a><br>我们删掉默认创建的Shader Code，只简单输出Albedo(Diffuse Color)看看效果:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/TonyShader"</span> &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 定义渲染顺序 - RenderType</span></span><br><span class="line">        Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">        </span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// #pragma surface指明是surface shader</span></span><br><span class="line">        <span class="comment">// surf Lambert指明用的光照模式是Lambert(会决定光照是如何计算的)</span></span><br><span class="line">        <span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> Input &#123;</span><br><span class="line">            float2 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>) </span>&#123;</span><br><span class="line">            o.Albedo = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/SurfaceShaderWithAlbedoSetting.PNG" alt="SurfaceShaderWithAlbedoSetting"><br><strong>接下来让我们给Hellephant加上纹理图案：</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/TonyShader"</span> &#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        <span class="comment">// 为了在编辑器里提供控制纹理输入，Properties必须和struct Input里的uv_MainTex对应</span></span><br><span class="line">        _MainTex(<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123; <span class="string">"RenderType"</span> = <span class="string">"Opaque"</span>&#125;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">        <span class="comment">// 提供纹理输入</span></span><br><span class="line">        <span class="keyword">struct</span> Input&#123;</span><br><span class="line">            float2 uv_MainTex</span><br><span class="line">        &#125;;</span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>) </span>&#123;</span><br><span class="line">            o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/SurfaceShaderWithTexture.PNG" alt="SurfaceShaderWithTexture"><br>让我们看看现在对应的Unity Material Editor：<br><img src="/img/Unity/SurfaceShaderMaterialEditorWithTexture.PNG" alt="SurfaceShaderMaterialEditorWithTexture"><br><strong>图像看起来还不真实，没有深度感，接下来我们添加<a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Light_and_Shadow">Normal Mapping 参见</a>：</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/TonyShader"</span> &#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        .....</span><br><span class="line">        _BumpMap(<span class="string">"Bumpmap"</span>, <span class="number">2</span>D) = <span class="string">"bump"</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> Input&#123;</span><br><span class="line">            ......</span><br><span class="line">            float2 uv_BumpMap;</span><br><span class="line">        &#125;;</span><br><span class="line">        ......</span><br><span class="line">        sampler2D _BumpMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>) </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_Bumpmap));</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UnpackNormal接受一个fixed4的输入，并将其转换为所对应的法线值（fixed3）<br>比较有无Normal map的效果，见如下：<br><img src="/img/Unity/SurfaceShaderWithNormalMap.PNG" alt="SurfaceShaderWithNormalMap"><br><img src="/img/Unity/SurfaceShaderWithTexture.PNG" alt="SurfaceShaderWithTexture"><br><strong>接下来让我们通过计算Normal和Viedir的情况去高亮物体：</strong><br>这里需要用到build-in variable viewDir(代表观察者看顶点的方向)<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/TonyShader"</span> &#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        ......</span><br><span class="line">        _RimColor(<span class="string">"Rim Color"</span>, Color) = (<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">        _RimPower(<span class="string">"Rim Power"</span>, Range(<span class="number">0.5</span>, <span class="number">8.0</span>)) = <span class="number">3.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> Input &#123;</span><br><span class="line">            .....</span><br><span class="line">            float3 viewDir;</span><br><span class="line">        &#125;;</span><br><span class="line">        ......</span><br><span class="line">        float4 _RimColor;</span><br><span class="line">        <span class="keyword">float</span> _RimPower;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>) </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            half rim = <span class="number">1.0</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">            o.Emission = _RimColor.rgb * pow(rim, _RimPower);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>saturate的作用是把观察者方向和顶点法线夹角Cos值限定在[0,1]，再用1减去这个值，表明观察者方向和顶点法线夹角越小rim值越小，当夹角大于等于90度的时候达到rim最大值。从而实现高亮边缘的效果(周边和观察者角度往往比较大)。<br><img src="/img/Unity/SurfaceShaderWithEmssion.PNG" alt="SurfaceShaderWithEmssion"><br><strong>接下来我们看看通过vertex function去动态计算新vertex值的效果(这里我们根据顶点法线方向去收缩顶点postion)：</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/TonyShader"</span> &#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        ......</span><br><span class="line">        _Amount(<span class="string">"Extrusion Amount"</span>, Range(-<span class="number">0.5</span>,<span class="number">0.5</span>)) = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// vertex:vert定义了vert方法名</span></span><br><span class="line">        <span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert vertex:vert</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> _Amount;</span><br><span class="line">        <span class="comment">// vert方法定义，根据顶点法线去计算新的顶点位置</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vert</span>(<span class="params">inout appdata_full v</span>)</span>&#123;</span><br><span class="line">            v.vertex.xyz += v.normal * _Amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>) </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/SurfaceShaderWithNegativeExtrusion.PNG" alt="SurfaceShaderWithNegativeExtrusion"><br><img src="/img/Unity/SurfaceShaderWithPositiveExtrusion.PNG" alt="SurfaceShaderWithPositiveExtrusion"><br>在vert function里我们也可以自定义一些成员在surface shader里传递，但这样的话vert必须有两个参数，一个inout appdata_full v,一个out Input o，这里的out Input o回座位surf function的Input IN参数作为输入。<a href="http://docs.unity3d.com/Manual/SL-SurfaceShaderExamples.html" target="_blank" rel="external">Custom Input Member详细用法参见</a><br><strong>接下来让我们看看Light Model对于最终颜色计算的影响：</strong><br>待学习了解<br><strong>最后我们来看看Final Color Function是如何影响最终颜色计算的：</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/TonyShader"</span> &#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        ......</span><br><span class="line">        _ColorTint(<span class="string">"Tint"</span>, Color) = (<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">        </span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// finalcolor:mycolor定义final function name</span></span><br><span class="line">        <span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert vertex:vert finalcolor:mycolor</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        fixed4 _ColorTint;</span><br><span class="line">        <span class="comment">// final color function格式， color会影响所有lightmaps,light probes等的颜色信息</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mycolor</span>(<span class="params">Input IN, SurfaceOutput o, inout fixed4 color</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            color *= _ColorTint;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>) </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/SurfaceShaderWithFinalColorFunction.PNG" alt="SurfaceShaderWithFinalColorFunction"></p>
<h2 id="Vertex_and_Fragment_Shaders">Vertex and Fragment Shaders</h2><p>见后续Shader学习</p>
<h1 id="Unity_Shader入门精要">Unity Shader入门精要</h1><h2 id="渲染管线">渲染管线</h2><p>参考以前的学习：<br><a href="http://tonytang1990.github.io/2015/08/29/Computer-Graphic-Study/">Computer_Graphic_Study</a><br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/">OpenGL_Study</a></p>
<h2 id="Unity_Shader基础">Unity Shader基础</h2><h3 id="材质和Unity_Shader">材质和Unity Shader</h3><p>结合前面的学习，我们知道了在Unity里Material会决定使用那些Texture和Shader去渲染Model。</p>
<p>这里再简单梳理下他们之间的关系：</p>
<ol>
<li>Model(模型) — 最终我们需要通过渲染去实现特定效果的模型。(提供模型数据 e.g. 顶点，法线等)</li>
<li>Texture(贴图数据) — 这里没有直接说成纹理是因为Texture不仅能提供纹理数据，还能提供作为其他计算的数据(e.g. 光照方面的数据等)</li>
<li>Material(材质) — 会决定使用哪些Texture作为数据输入(e.g. 纹理数据，光照计算相关数据等)。通过指定Shader去处理Model和Texture等传入的数据进行处理。而材质面板是与Shader沟通的桥梁，允许我们通过面板暴露Shader暴露出的参数进行渲染控制。</li>
<li>Shader — 处理前面传入的Model，Texture等数据加以处理计算实现各式各样的渲染效果。</li>
</ol>
<p>Unity Shader分类：</p>
<ol>
<li>Standard Surface Shader — 前面我们提到的提供了一个包含标准光照模型计算的表面着色器。(最终还是会被编译成对应图形API接口的Vertex and Fragment Shader)</li>
<li>Unlit Shader — 不包含光照的Vertex and Fragment 。Shader,需要自己编写完整的渲染管线流程代码。</li>
<li>Image Effect Shader — 主要用于实现各种屏幕后处理效果。</li>
<li>Compute Shader — 利用GPU的并行性进行一些与常规渲染流水线无关的计算。</li>
</ol>
<p>这里我们主要学习Unlit Shader。</p>
<p>Shader对于Unity而言也是一种资源文件，所以依然有导入设置：<br><img src="/img/Unity/UnityShaderSettingPanel.PNG" alt="UnityShaderSettingPanel"><br>Note:<br>Unity Shader最终还是会被编译成对应图形编程接口(e.g. DX,OpenGL……)的Shader代码实现真正的渲染。</p>
<h3 id="ShaderLab">ShaderLab</h3><p>“ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。ShaderLab类似于CgFX和DX Effects语言。<br>“(引用自《Unity Shader入门精要》)</p>
<p>ShaderLab帮助我们快速定义Shader编写过程中需要资源和设置等。Unity会最终把ShaderLab编写的Shader编译成对应平台的真正代码和Shader文件，实现跨平台。</p>
<h3 id="Unity_Shader结构">Unity Shader结构</h3><p>这里我们创建一个基本的UnlitShader，结合里面的代码来学习理解(详情参考代码里的注释)：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 材质索引Shader时的路径</span></span><br><span class="line">Shader <span class="string">"Custom/UnlitShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Shader暴露给材质面板的属性用于动态修改控制</span></span><br><span class="line">    <span class="comment">// Properties在Unity里相当于OPENGL Shader里定义的Uniform，Sampler，全局变量等，用于作为可控的输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2D代表_MyTexture,_MyNormalMap是texture类型.Color代表颜色。Range代表范围值，更多内容查官网</span></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个Unity Shader至少要包含一个SubShader(Unity会使用第一个可以在目标平台运行的SubShader用于渲染，如果都不支持则会使用Fallback语义指定的Unity Shader)</span></span><br><span class="line">    <span class="comment">// SubShader定义了真正的Shader相关代码(渲染流程，渲染状态设置等)</span></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Tags是为了告诉Unity我们Shader的特定属性(比如RenderType - 渲染类型，Queue—渲染顺序)。</span></span><br><span class="line">        <span class="comment">// Note:</span></span><br><span class="line">        <span class="comment">// Tag也可以在Pass里声明，但SubShader里的Tags相当于针对所有Pass的Tag设置，优先于Tag本身的Tag设置</span></span><br><span class="line">        Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass代表一次完成的渲染流程</span></span><br><span class="line">        <span class="comment">// 这个好比OpenGL里实现Shadow Map效果时需要先通过First Pass生成光源点角度的Depth Texture，</span></span><br><span class="line">        <span class="comment">// 然后Second Pass通过比较摄像机角度的Depth Texture得出哪些点是Shadow的结论里的Pass一样</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Pass支持定义名字</span></span><br><span class="line">            <span class="comment">// Name "PassName"</span></span><br><span class="line">            <span class="comment">// 我们可以通过这个名字去指定使用特定Pass</span></span><br><span class="line">            <span class="comment">// UsePass "ShaderName/PassName"</span></span><br><span class="line">            <span class="comment">// GrabPass负责抓取屏幕并存储在一张纹理中用于后续Pass处理</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Unity Shader采用的是类似CG的Shader语言编写</span></span><br><span class="line">            <span class="comment">// Shader代码被包含在CGPROGRAM和ENDCG之间</span></span><br><span class="line">            <span class="comment">// Note:</span></span><br><span class="line">            <span class="comment">// 如果想要使用GLSL来编写需要包含在GLSLPROGRAM和ENDGLSL之间</span></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">// 真正的Shader代码从这里开始</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line">            </span><br><span class="line">            <span class="preprocessor">#include "UnityCG.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 映射Properties里暴露给Material材质面板的对象</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Vertex Shader入口</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Fragment Shader入口</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有Pass都不被支持时，我们可以指定最终使用的Pass</span></span><br><span class="line">    <span class="comment">// Fallback "PassName"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数学相关知识">数学相关知识</h2><p>参考书籍:<br>《3D数学基础:图形与游戏开发》<br>《Fundamentals of Computer Graphics (3rd Edition)》 — Peter Shirley, Steve Marschnner<br>《Real-Time Rendering, Third Edition》 — Tomas Akenine-Moller, Eric Haines, Naty Hoffman</p>
<p>这里只说几点DX和OpenGL还有Unity之间需要注意的特殊点:</p>
<ol>
<li>坐标系<br>DX和Unity使用的是左手坐标系。<br>OpenGL使用的是右手坐标系。</li>
<li>行列向量<br>DX使用的是行向量(矩阵乘法是右乘)<br>OpenGL和Unity使用的是列向量(矩阵乘法是左乘)</li>
<li>正交矩阵<br>因为正交矩阵M(T)=M(-1)<br>在提前得知是正交矩阵的前提下可以直接使用M(T)(转置矩阵)快速求的M(-1)(逆矩阵)(e.g. 旋转是正交的)<br>逆矩阵可以用于快速回复之前的矩阵变化</li>
<li>4<em>4矩阵<br>| M(3</em>3)  t(3<em>1)|<br>|  0(1</em>3)    1  |<br>M(3<em>3)代表线性变换(e.g. 旋转，缩放，错切，径向，正交投影…..)<br>t(3</em>1)代表平移变换<br>0(1*3)代表零矩阵<br>1代表标量1</li>
<li>纹理坐标<br>OpenGL中(0,0)是左下角<br>DX中(0,0)是左上角</li>
</ol>
<p>关于渲染流程里的坐标系转换相关知识参考之前的学习:<br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Coordinate_Transformations_&amp;_Perspective_Projection">Coordinate Transformations &amp; Perspective Projection</a></p>
<p>Unity Shader的内置变量参考:<br>UnityShaderVariables.cginc</p>
<h2 id="Unity_Shader学习之旅">Unity Shader学习之旅</h2><p>本人使用的Unity版本为5.4.0f3 Personal</p>
<h3 id="一个最简单的顶点/片元着色器">一个最简单的顶点/片元着色器</h3><p>依然采用代码实战，跟之前Unity Shader结构讲的类似，但更细节一些，相关解释都写在注释里了:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/SimpleShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义Material材质与Shader的交流面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        <span class="comment">// 声明一个Color类型的属性</span></span><br><span class="line">        _Color(<span class="string">"Color Tint"</span>, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义一个与Material面板交流控制的对应属性</span></span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自定义结构体定义vertex shader输入</span></span><br><span class="line">            <span class="keyword">struct</span> a2v &#123;</span><br><span class="line">                <span class="comment">// POSITION告诉Unity，用模型空间的顶点坐标填充vertex变量</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                <span class="comment">// NORMAL告诉Unity，用模型空间的法线方向填充normal变量</span></span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">// TEXTURE0告诉Unity，用模型的第一套纹理坐标填充texcoord变量</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自定义结构体用于vertex shader和fragment shader之间数据传入</span></span><br><span class="line">            <span class="keyword">struct</span> v2f &#123;</span><br><span class="line">                <span class="comment">// SV_POSITION告诉Unity，pos是裁剪空间中的顶点坐标位置信息</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// color存储颜色信息</span></span><br><span class="line">                fixed3 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 声明输出结构体实例</span></span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                <span class="comment">// 将v.normal的顶点法线信息从[-1.0,1.0]到[0.0, 1.0]并存储在颜色信息中</span></span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span> + fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// SV_Target告诉渲染器把用户的输出颜色存储到一个渲染目标中，这里默认是帧缓存中</span></span><br><span class="line">            <span class="comment">// 因为vertex shader是针对顶点运算，fragment shader是针对fragment</span></span><br><span class="line">            <span class="comment">// 所以fragment的输入是顶点数据进行插值后得到的</span></span><br><span class="line">            <span class="comment">// 顶点数据只有三角形的三个顶点，中间的fragment信息通过插值得到</span></span><br><span class="line">            <span class="comment">// i是vertex shader输出后通过插值传递过来的</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// v.normal映射后的颜色信息</span></span><br><span class="line">                fixed3 c = i.color;</span><br><span class="line">                <span class="comment">// 使用Material面板控制的_Color参与最终的fragment颜色运算</span></span><br><span class="line">                c *= _Color.rgb;</span><br><span class="line">                <span class="keyword">return</span> fixed4(c, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Unity内置文件和变量">Unity内置文件和变量</h3><p><a href="http://unity3d.com/cn/get-unity/download/
archive" target="_blank" rel="external">Unity Shader内置文件官网下载地址</a></p>
<p>内置文件包含文件：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include "**.cginc"</span></span><br></pre></td></tr></table></figure></p>
<p>内置Shader目录结构：<br><img src="/img/Unity/UnityBuildInShaderFolderStructure.PNG" alt="UnityBuildInShaderFolderStructure"></p>
<ol>
<li>CGIncludes — 包含所有的内置包含文件</li>
<li>DefaultResources — 包含了一些内置组件或者功能需要的Unity Shader</li>
<li>DefaultResourcesExtra — 包含了所有的Unity中内置的Unity Shader</li>
<li>Editor — 只有一个脚本，定义了Unity 5引入的Standard Shader所有的材质面板</li>
</ol>
<p>常用包含文件介绍：</p>
<ol>
<li>UnityCG.cginc — 包含了常用的帮助函数，宏和结构体等</li>
<li>UnityShaderVariables.cginc — 包含了许多内置的全局变量,e.g. UNITY_MATRIX_MVP</li>
<li>Lighting.cginc — 包含了各种内置的光照模型</li>
<li>HLSLSupport.cginc — 声明了很多用于跨平台编译的宏和定义</li>
</ol>
<p>Note:<br>Unity Shader内置文件如果安装时下载安装了，也可以在Editor\Data\CGIncludes目录下找到所有内置文件</p>
<h3 id="CG/HLSL语义">CG/HLSL语义</h3><p>“语义实际上就是让Shader知道从哪里读取数据，并把数据输出到哪里。”</p>
<p>“SV代表的含义是系统数据(system-value)。DX10以后引入的。大部分时候SV_POSITION和POSITION是等价的。但为了更好的跨平台最好尽量采用SV开头的语义来修饰。”</p>
<p><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html" target="_blank" rel="external">Shader semantics官网查询</a></p>
<h3 id="Shader_Debugger">Shader Debugger</h3><p>欲善其事，必先利其器。<br>在学习Unity Shader之前我们需要知道如何去调试Unity Shader。</p>
<h4 id="Color_Info">Color Info</h4><p>在渲染的时候把数据信息以颜色的方式渲染到物体上，用于了解特定数据信息。</p>
<h4 id="Unity_Frame_Debugger">Unity Frame Debugger</h4><p>Unity提供的的帧调试器，是基于Unity API层面。(Window -&gt; Frame Debug)</p>
<h4 id="VS_Graphics_Debugger">VS Graphics Debugger</h4><p>VS提供的基于渲染API层面的调试器。<br>Unity Shader里要写#pragma enable_d3d11_debug_symbols开启DX11渲染</p>
<p>具体调试方法参考：<br><a href="https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html" target="_blank" rel="external">Implementing Fixed Function TexGen in Shaders Debugging DirectX 11 shaders with Visual Studio</a></p>
<p>Note:<br>Frames can only be captured if Unity is running under DirectX 11(只能基于DX11)</p>
<h3 id="NVIDIA_NSight">NVIDIA NSight</h3><p>NVIDIA公司提供的基于渲染API层面的调试器。<br>之前了解过，好像只支持N卡。具体没有使用过。</p>
<h2 id="Unity中的基础光照">Unity中的基础光照</h2><h3 id="光照知识回顾">光照知识回顾</h3><p>关于光照的基本学习参考之前OpenGL中的学习：<br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Light_and_Shadow">Light and Shadow</a></p>
<p>从上面可以看出Light影响着每一个物体最终颜色的成像计算。</p>
<ol>
<li>环境光(Ambient) — 环境光与光照方向无关，只需考虑方向光的颜色和方向光所占比重，决定着物体的基本颜色。</li>
<li>漫反射(Diffuse) — 与光照的方向和顶点normal有关，决定着不同角度(顶点法线)的顶点反射能力。</li>
<li>镜面反射(Specular) — 与光照的方向和eye观察还有顶点normal有关，决定了不同观察位置的反射高光系数。</li>
</ol>
<h3 id="标准光照模型">标准光照模型</h3><p>“光照模型 — 根据材质属性(如漫反射属性等)，光源信息(如光源方向，辐照度)，使用一个等式去计算沿某个方向的出射度的过程。”</p>
<p><strong>BRDF(Bidirectional Reflectance Distribution Function)光照模型</strong><br>“当给定射入光线的方向和辐射度后，BRDF可以给出在某个出射方向上的光照能量分布。”</p>
<p>那么什么是标准光照模型了？<br>“标准光照模型只关心直接光照，也就是那些直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线。”</p>
<p>标准光照模型有四部分组成：</p>
<ol>
<li>自发光(emissive)</li>
<li>高光反射(specular)</li>
<li>漫反射(diffuse)</li>
<li>环境光(ambient)</li>
</ol>
<p>从这里可以看出之前学习OpenGL的光照计算可以算是基于标准光照模型来计算的，只是没有考虑自发光的光照运算。不难看出所谓的光照模型其实就是不同的光照计算公式。</p>
<p>在之前OpenGL的学习里，都是通过顶点法线插值后在Fragment Shader里计算Specular，Diffuse，Ambient来进行光照运算的，这种技术被称为Phong着色(Phong Shading)。(针对每一个fragment进行光照运算)</p>
<p>我们也可以针对每一个顶点进行光照运算，e.g. 高洛德着色(Gouraud shading)。针对每个顶点计算光照后，通过线性插值后最终输出显示。(因此不适合非线性的光照计算显示)</p>
<p>但上述标准光照模型(这里称为Blinn-Phong模型)无法模拟真实的物理现象的效果。<br>“Blinn-Phong模型是各项同性(isotropic)的，也就是说，当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。各向异性(anisotropic)反射性质的效果需要机遇物理的光照模型来运算。”</p>
<h4 id="漫反射光照模型">漫反射光照模型</h4><h5 id="兰伯特光照模型">兰伯特光照模型</h5><p>c(light) — 光源颜色信息<br>m(diffuse) — 漫反射系数<br>n — 顶点法线<br>l — 光源方向</p>
<p>兰伯特光照模型:<br>c(diffuse) = (c(light)  <em> m(diffuse)) </em> max(0, dot(n,l))</p>
<p>基于顶点的兰伯特光照模型Shader：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_World2Object' with 'unity_WorldToObject'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐顶点的漫反射光照计算Shader</span></span><br><span class="line"><span class="comment">// 逐顶点是在vertex shader里针对每一个vert计算Diffuse光照然后通过顶点颜色插值显示出来</span></span><br><span class="line">Shader <span class="string">"Custom/DiffuseVertexLevelShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Diffuse Light Model</span></span><br><span class="line">    <span class="comment">// c(light) -- 光源颜色信息</span></span><br><span class="line">    <span class="comment">// m(diffuse) -- 漫反射系数</span></span><br><span class="line">    <span class="comment">// n -- 顶点法线</span></span><br><span class="line">    <span class="comment">// l -- 光源方向_WorldToObject</span></span><br><span class="line">    <span class="comment">// c(diffuse) = (c(light)  * m(diffuse)) * max(0, dot(n, l))</span></span><br><span class="line"></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露漫反射系数c(diffuse)用于动态控制漫反射系数</span></span><br><span class="line">        _Diffuse(<span class="string">"Diffuse"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags &#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为是计算基于Vertex Level的漫反射光照模型计算</span></span><br><span class="line">            <span class="comment">// 所以在vertex shader里已经完成了对光照color的运算</span></span><br><span class="line">            <span class="comment">// 这里只需将结果通过插值传递给fragment shader即可</span></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的漫反射系数</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 计算漫反射光</span></span><br><span class="line">                <span class="comment">// 为了确保法线从物体坐标系转换到世界坐标系正确，这里需要乘以object2world矩阵的逆矩阵的转置矩阵</span></span><br><span class="line">                <span class="comment">// _World2Object代表object2world的逆矩阵</span></span><br><span class="line">                <span class="comment">// 因为unity使用的是列向量，所以通过mul()_World2Object作为第二个参数相当于左乘_World2Object的转置矩阵</span></span><br><span class="line">                <span class="comment">// 之所以只乘以3x3的矩阵是因为平移变换不会影响法线方向</span></span><br><span class="line">                fixed3 worldnormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                <span class="comment">// 假设只有一个全局direction light</span></span><br><span class="line">                fixed3 worldlightdir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldnormal, worldlightdir));</span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 将vertex shader计算出的环境光加漫反射颜色显示出来</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于片元计算的兰伯特光照模型Shader：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_World2Object' with 'unity_WorldToObject'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐片元的漫反射光照计算Shader</span></span><br><span class="line"><span class="comment">// 逐片元是在fragment shader里针对每一个fragment计算Diffuse光照</span></span><br><span class="line">Shader <span class="string">"Custom/DiffuseFragLevelShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Diffuse Light Model</span></span><br><span class="line">    <span class="comment">// c(light) -- 光源颜色信息</span></span><br><span class="line">    <span class="comment">// m(diffuse) -- 漫反射系数</span></span><br><span class="line">    <span class="comment">// n -- 顶点法线</span></span><br><span class="line">    <span class="comment">// l -- 光源方向</span></span><br><span class="line">    <span class="comment">// c(diffuse) = (c(light)  * m(diffuse)) * max(0, dot(n, l))</span></span><br><span class="line"></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露漫反射系数c(diffuse)用于动态控制漫反射系数</span></span><br><span class="line">        _Diffuse(<span class="string">"Diffuse"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为是计算基于Fragment Level的漫反射光照模型计算</span></span><br><span class="line">            <span class="comment">// 所以在vertex shader需要把world space的normal传给fragment shader进行diffuse光照运算</span></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的漫反射系数</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                <span class="comment">// 计算漫反射光</span></span><br><span class="line">                <span class="comment">// 为了确保法线从物体坐标系转换到世界坐标系正确，这里需要乘以object2world矩阵的逆矩阵的转置矩阵</span></span><br><span class="line">                <span class="comment">// _World2Object代表object2world的逆矩阵</span></span><br><span class="line">                <span class="comment">// 因为unity使用的是列向量，所以通过mul()_World2Object作为第二个参数相当于左乘_World2Object的转置矩阵</span></span><br><span class="line">                <span class="comment">// 之所以只乘以3x3的矩阵是因为平移变换不会影响法线方向</span></span><br><span class="line">                o.worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));                            </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 假设只有一个全局direction light</span></span><br><span class="line">                fixed3 worldlightdir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(i.worldNormal, worldlightdir));</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="comment">// 将计算出的环境光加漫反射颜色显示出来</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>问题:<br>背光区域没有明暗变化看起来像一个平面。</p>
<h5 id="半兰伯特(Half_Lambert)光照模型">半兰伯特(Half Lambert)光照模型</h5><p>c(light) — 光源颜色信息<br>m(diffuse) — 漫反射系数<br>n — 顶点法线<br>l — 光源方向<br>a — a倍漫反射辐射度<br>b — 漫反射辐射度偏移量</p>
<p>半兰伯特光照模型:<br>c(diffuse) = c(light)  <em> m(diffuse) </em> (a * dot(n,l) + b)</p>
<p>基于片元的半拉伯特特光照模型：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_World2Object' with 'unity_WorldToObject'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐片元的半兰伯特光照模型没有对漫反射辐射度负值做max处理，</span></span><br><span class="line"><span class="comment">// 而是通过a倍缩放加上b偏移量得出最终的漫反射辐射度，</span></span><br><span class="line"><span class="comment">// 这样一来背面漫反射辐射度也会被映射到不同的值而非0，从而拥有不同的漫反射效果。</span></span><br><span class="line">Shader <span class="string">"Custom/HalfLambertShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Half Labert Model</span></span><br><span class="line">    <span class="comment">// c(light) -- 光源颜色信息</span></span><br><span class="line">    <span class="comment">// m(diffuse) -- 漫反射系数</span></span><br><span class="line">    <span class="comment">// n -- 顶点法线</span></span><br><span class="line">    <span class="comment">// l -- 光源方向</span></span><br><span class="line">    <span class="comment">// a -- a倍漫反射辐射度</span></span><br><span class="line">    <span class="comment">// b -- 漫反射辐射度偏移量</span></span><br><span class="line">    <span class="comment">// 半兰伯特光照模型 :</span></span><br><span class="line">    <span class="comment">// c(diffuse) = c(light)  * m(diffuse) * (a * dot(n, l) + b)</span></span><br><span class="line">        </span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露漫反射系数c(diffuse)用于动态控制漫反射系数</span></span><br><span class="line">        _Diffuse(<span class="string">"Diffuse"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为是计算基于Fragment Level的漫反射光照模型计算</span></span><br><span class="line">            <span class="comment">// 所以在vertex shader需要把world space的normal传给fragment shader进行diffuse光照运算</span></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的漫反射系数</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                <span class="comment">// 计算漫反射光</span></span><br><span class="line">                <span class="comment">// 为了确保法线从物体坐标系转换到世界坐标系正确，这里需要乘以object2world矩阵的逆矩阵的转置矩阵</span></span><br><span class="line">                <span class="comment">// _World2Object代表object2world的逆矩阵</span></span><br><span class="line">                <span class="comment">// 因为unity使用的是列向量，所以通过mul()_World2Object作为第二个参数相当于左乘_World2Object的转置矩阵</span></span><br><span class="line">                <span class="comment">// 之所以只乘以3x3的矩阵是因为平移变换不会影响法线方向</span></span><br><span class="line">                o.worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 假设只有一个全局direction light</span></span><br><span class="line">                fixed3 worldlightdir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// (dot(i.worldNormal, worldlight) * 0.5 + 0.5)将漫反射辐射度映射到[0,1]，背面不再全是0</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * (dot(i.worldNormal, worldlightdir) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="comment">// 将计算出的环境光加漫反射颜色显示出来</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>半兰伯特光照模型没有对漫反射辐射度负值做max处理，而是通过a倍缩放加上b偏移量得出最终的漫反射辐射度，这样一来背面漫反射辐射度也会被映射到不同的值，从而拥有不同的漫反射效果。</p>
<h4 id="高光反射光照模型">高光反射光照模型</h4><p>c(light) — 光源颜色信息<br>m(specular) — 材质高光反射系数<br>v — 视角方向<br>r — 反射方向<br>n — 顶点法线<br>l — 光源方向<br>m(gloss) — 发光系数</p>
<p>r可以通过n和l计算出来：<br>r = 2 <em> dot(-n,l) </em> n + l<br>跟OpenGL一样，Unity提供了直接计算反射光线方向的API:reflect(i,n)</p>
<p>c(specular) = (c(light) <em> m(specular)) </em> pow(max(0,dot(v,r)), m(gloss))<br>上面这个公式和之前在OpenGL之前学习的高光反射并没有太多出入，<a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Light_and_Shadow">详情参考</a></p>
<p>这里主要要区分Phong光照模型和Blinn-Phong光照模型：</p>
<ol>
<li>Phong光照模型<br>c(specular) = (c(light) <em> m(specular)) </em> pow(max(0,dot(v,r)), m(gloss))<br>dot(v,r) — 是指观察者所在位置和完美反射光线之间夹角</li>
<li>Blinn-Phong光照模型<br>h = (v + l) / |v + l|<br>c(specular) = (c(light) <em> m(specular)) </em> pow(max(0,dot(n,h)), m(gloss))<br>dot(n,h) — 是指将v和l向量归一化后的向量与n之间的夹角</li>
</ol>
<p>可以看出来两者在计算高光反射的发光基准系数时采用了不同的运算方式。虽然两者都是经验模型，但后者是对于前者的一种改进方式。</p>
<p>跟漫反射一样，高光反射的计算依然有基于顶点和基于片元之分。<br>基于片元的Phhong高光反射光照模型代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_World2Object' with 'unity_WorldToObject'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐顶点的环境光+漫反射+Phong高光反射光照计算Shader</span></span><br><span class="line">Shader <span class="string">"Custom/LightModel/PhongSpecularFragLevelShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specular Light Model</span></span><br><span class="line">    <span class="comment">// c(light) -- 光源颜色信息</span></span><br><span class="line">    <span class="comment">// m(specular) -- 材质高光反射系数</span></span><br><span class="line">    <span class="comment">// v -- 视角方向</span></span><br><span class="line">    <span class="comment">// r -- 光线反射方向</span></span><br><span class="line">    <span class="comment">// n -- 顶点法线</span></span><br><span class="line">    <span class="comment">// l -- 光源方向</span></span><br><span class="line">    <span class="comment">// m(gloss) -- 发光系数</span></span><br><span class="line">    <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(v,r)), m(gloss))</span></span><br><span class="line"></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露漫反射系数c(diffuse)用于动态控制漫反射系数</span></span><br><span class="line">        _Diffuse(<span class="string">"Diffuse"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光范围</span></span><br><span class="line">        _Gloss(<span class="string">"Gloss"</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;           <span class="comment">// 投影坐标系的顶点位置</span></span><br><span class="line">                float3 worldNormal : NORMAL;        <span class="comment">// 世界坐标系的法线</span></span><br><span class="line">                float3 worldPos : TEXCOORD0;        <span class="comment">// 世界坐标系的顶点位置</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的漫反射系数</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射系数</span></span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光范围</span></span><br><span class="line">            <span class="keyword">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                <span class="comment">// 计算漫反射光</span></span><br><span class="line">                <span class="comment">// 为了确保法线从物体坐标系转换到世界坐标系正确，这里需要乘以object2world矩阵的逆矩阵的转置矩阵</span></span><br><span class="line">                <span class="comment">// _World2Object代表object2world的逆矩阵</span></span><br><span class="line">                <span class="comment">// 因为unity使用的是列向量，所以通过mul()_World2Object作为第二个参数相当于左乘_World2Object的转置矩阵</span></span><br><span class="line">                <span class="comment">// 之所以只乘以3x3的矩阵是因为平移变换不会影响法线方向</span></span><br><span class="line">                o.worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 假设只有一个全局direction light</span></span><br><span class="line">                fixed3 worldlightdir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(i.worldNormal, worldlightdir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 光线反射方向</span></span><br><span class="line">                fixed3 reflectdir = normalize(reflect(-worldlightdir, i.worldNormal));</span><br><span class="line">                <span class="comment">// 世界坐标系下的从顶点到观察点的观察方向v</span></span><br><span class="line">                fixed3 viewdir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="comment">// 计算高光反射的颜色信息</span></span><br><span class="line">                <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(v,r)), m(gloss))</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectdir, viewdir)), _Gloss);</span><br><span class="line">                <span class="comment">// 将高光反射的颜色信息输出到最终的顶点颜色</span></span><br><span class="line">                fixed3 color = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将计算出的环境光+漫反射+Phong高光反射颜色显示出来</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于片元的Blinn-Phhong高光反射光照模型代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_World2Object' with 'unity_WorldToObject'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐顶点的环境光+漫反射+BlinnPhong高光反射光照计算Shader</span></span><br><span class="line">Shader <span class="string">"Custom/LightModel/BlinnPhongSpecularFragLevelShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specular Light Model</span></span><br><span class="line">    <span class="comment">// c(light) -- 光源颜色信息</span></span><br><span class="line">    <span class="comment">// m(specular) -- 材质高光反射系数</span></span><br><span class="line">    <span class="comment">// v -- 视角方向</span></span><br><span class="line">    <span class="comment">// r -- 光线反射方向</span></span><br><span class="line">    <span class="comment">// n -- 顶点法线</span></span><br><span class="line">    <span class="comment">// l -- 光源方向</span></span><br><span class="line">    <span class="comment">// m(gloss) -- 发光系数</span></span><br><span class="line">    <span class="comment">// h = (v + l) / |v + l|</span></span><br><span class="line">    <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(n,h)), m(gloss))</span></span><br><span class="line"></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露漫反射系数c(diffuse)用于动态控制漫反射系数</span></span><br><span class="line">        _Diffuse(<span class="string">"Diffuse"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光范围</span></span><br><span class="line">        _Gloss(<span class="string">"Gloss"</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;           <span class="comment">// 投影坐标系的顶点位置</span></span><br><span class="line">                float3 worldNormal : NORMAL;        <span class="comment">// 世界坐标系的法线</span></span><br><span class="line">                float3 worldPos : TEXCOORD0;        <span class="comment">// 世界坐标系的顶点位置</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的漫反射系数</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射系数</span></span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光范围</span></span><br><span class="line">            <span class="keyword">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                <span class="comment">// 计算漫反射光</span></span><br><span class="line">                <span class="comment">// 为了确保法线从物体坐标系转换到世界坐标系正确，这里需要乘以object2world矩阵的逆矩阵的转置矩阵</span></span><br><span class="line">                <span class="comment">// _World2Object代表object2world的逆矩阵</span></span><br><span class="line">                <span class="comment">// 因为unity使用的是列向量，所以通过mul()_World2Object作为第二个参数相当于左乘_World2Object的转置矩阵</span></span><br><span class="line">                <span class="comment">// 之所以只乘以3x3的矩阵是因为平移变换不会影响法线方向</span></span><br><span class="line">                o.worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 假设只有一个全局direction light</span></span><br><span class="line">                fixed3 worldlightdir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(i.worldNormal, worldlightdir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 世界坐标系下的从顶点到观察点的观察方向v</span></span><br><span class="line">                fixed3 viewdir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="comment">// h = (v + l) / |v + l| v和l向量归一化后的向量</span></span><br><span class="line">                fixed3 halfdir = normalize(worldlightdir + viewdir);</span><br><span class="line">                <span class="comment">// 计算高光反射的颜色信息</span></span><br><span class="line">                <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(n,h)), m(gloss))</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(i.worldNormal, halfdir)), _Gloss);</span><br><span class="line">                <span class="comment">// 将高光反射的颜色信息输出到最终的顶点颜色</span></span><br><span class="line">                fixed3 color = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将计算出的环境光+漫反射+BlinnPhong高光反射颜色显示出来</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="/img/Unity/LightModelShader.JPG" alt="LightModelShader"></p>
<p>Note:<br>“如果没有全局光照技术，这些自发光的表面并不会真的着凉周围的物体，而是它本身看起来更亮了而已。”<br><strong>计算机图形学的第一定律：如果它看起来是对的，那么它就是对的。</strong></p>
<p>上面的运算都是我们通过基础的向量，矩阵运算来实现。在Unity中我们可以使用Unity内置的函数来帮助我们快速的计算得到指定结果。详情查看UnityCG.cginc。</p>
<p>Note:<br>“如果没有全局光照技术，这些自发光的表面并不会真的着凉周围的物体，而是它本身看起来更亮了而已。”<br><strong>计算机图形学的第一定律：如果它看起来是对的，那么它就是对的。</strong></p>
<h3 id="Lighting_in_Unity">Lighting in Unity</h3><p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/introduction-lighting-and-rendering?playlist=17102" target="_blank" rel="external">Global illumination, or ‘GI’, is a term used to describe a range of techniques and mathematical models which attempt to simulate the complex behaviour of light as it bounces and interacts with the world.</a>(GI代表通过技术或者数学模型模拟光照运算交互。e.g. 半兰伯特(Half Lambert)光照模型</p>
<p>Light在Unity主要分为Realtime(相当于Forward Rendering)和Precomputed(预先生成相关光照贴图数据参与光照计算)</p>
<h4 id="Realtime_Lighting">Realtime Lighting</h4><p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-lighting-technique?playlist=17102" target="_blank" rel="external">directional, spot and point, are realtime. This means that they contribute direct light to the scene and update every frame.</a>(实时的顾名思义实时计算光照)</p>
<p>有了实时光照计算为什么还需要Precomputed了？<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-lighting-technique?playlist=17102" target="_blank" rel="external">Unfortunately, the light rays from Unity’s realtime lights do not bounce when they are used by themselves. In order to create more realistic scenes using techniques such as global illumination we need to enable Unity’s precomputed lighting solutions.</a>(从官方原文来看，实时光照并没有计算光照被其他物体反弹之后的运算量，要想更加真实的光照所以需要Precomputed Lighting)</p>
<h4 id="Precomputed_Lighting">Precomputed Lighting</h4><p>Static Lightmap(Baked GI Lighting):<br>Lightmap — <a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-lighting-technique?playlist=17102" target="_blank" rel="external">When ‘baking’ a ‘lightmap’, the effects of light on static objects in the scene are calculated and the results are written to textures which are overlaid on top of scene geometry to create the effect of lighting.</a>(Bake GI Light会生成一张LightMap，这张Lightmap记录了场景里所有静态物体的光照运算结果。)</p>
<p>Note：<br>静态Lightmap一旦生成就不能再被运行时修改，实现不了场景里光照动态变化的效果</p>
<p>Realtime Lightmap(Baked Realtime GI Lighting):<br>Realtime GI Lightmap弥补了Static Lightmap的不足，可以实现预先计算所有实时光照(这里的实时光照是指全局光照(含间接光照的影响计算)))需要的数据去参与运行时全局光照计算。</p>
<p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-lighting-technique?playlist=17102" target="_blank" rel="external">To speed up the precompute further Unity doesn’t directly work on lightmaps texels, but instead creates a low resolution approximation of the static geometry in the world, called ‘clusters’.</a>(Unity为了加快Precompute速度，Lightmap的运算并不是texels级而是clusters级，可以理解成相对粗糙一点的精确度)</p>
<p>具体使用哪种光照策略取决于用户实际情况(显存，内存，GPU，CPU等)。</p>
<p>Baked Light Rules:</p>
<ol>
<li>Only Static GameObject才会参与Baked Lighting。</li>
<li>Light Bake Mode取决于光照的Bake设置。</li>
<li>Mixed的Bake Mode即会参与Bake也会参与Realtime。</li>
<li>具体Bake设置见Window -&gt; Lighting(设置Bake Static Lightmap还是Realtime)</li>
</ol>
<p>Note:<br>Precomputed Lighting是个典型空间换时间的例子。通过预算生成大量的光照信息Lightmap来避免大量的实时光照运算。</p>
<p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-lighting-technique?playlist=17102" target="_blank" rel="external">Using both Baked GI and Precomputed Realtime GI together in your scene can be detrimental to performance. A good practise is to ensure that only one system is used at a time, by disabling the other globally. </a>(官方建议，Baked GI和Precomputed Realtime GI两者选其一不建议同时使用，避免性能问题)</p>
<h5 id="Bake_Realtime_Lighting实战">Bake Realtime Lighting实战</h5><ol>
<li>Realtime Resolution<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/realtime-resolution?playlist=17102" target="_blank" rel="external">Realtime Resolution is the number of realtime lightmap texels (texture pixels) used per world unit.</a>(一个world unit使用多少个纹理贴图的像素)</li>
</ol>
<p>这个参数会影响最终Bake出来的光照采样计算结果，同时也会影响Precompute的时间消耗。合适的值取决于场景对于光照采样精度的需求与Bake时间之间的平衡。如果场景小(比如室内)且光源很多那么精度高一点Bake时间长一点是有意义的。如果场景大(比如室外)光源变化不大，那么精度高对最终的采样光照计算结果并没有太大影响只会增加Bake时间，那这样是不值得的。</p>
<ol>
<li>Chart(光照图)<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/understanding-charts?playlist=17102" target="_blank" rel="external">a Chart is an area of a lightmap texture to which we map the lightmap UVs of a given Scene object. We can think of this as a small tile containing an image of the lighting affecting that object.</a>(Chart表示一个光照贴图，用于映射特定Object的Lightmap UV的信息)</li>
</ol>
<p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/understanding-charts?playlist=17102" target="_blank" rel="external">A Chart is made up of two parts: irradiance (lighting) and directionality (encoding the dominant light direction).</a>(Chart由两部分组成:辐射度和光照方向)</p>
<p><img src="/img/Unity/LightmapChart.PNG" alt="LightmapChart"></p>
<p>Note:<br>Unity Unit设置的不同对于Realtime Resolution的选择也会有影响。</p>
<p>Baked GI是生成一张Lightmap Texture用于运行时参与光照计算。Baked Realtime Lighting是将信息存到Lighting Data Asset(包含了运行时生成低分辨率lightmap的相关信息)里用于运行时生成低解析度的光照图。</p>
<p>Chart is a minimum of 4x4 texels(Chart最小是4*4像素)。</p>
<p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/unwrapping-and-chart-reduction?playlist=17102" target="_blank" rel="external">Charts are created to encompass the UV lightmap coordinates of a Static Mesh Renderer. The number of Charts that an object requires is therefore largely determined by the number of UV shells (pieces) needed to unwrap the object in question.</a>(光照图(Charts)的目的主要是用来包住静态网格着色器(Static Mesh Renderer)的UV贴图坐标。一个物件所需要的光照图数量主要是看物体有多少片UI Shell需要拆解。)</p>
<p>降低Chart的数量是减少Precompute Time的关键因素之一。<br>除了选择合适的Realtime Resolution，还有什么方式可以帮助我们降低Chart数量了？</p>
<ol>
<li>降低Static物体的UV Shells(相当于减少特定物体所需的Lightmap Chart)</li>
<li>减少Static物体(用Lighting Probe实现)</li>
<li>减少Clusters数量(PRGI基础运算单元)</li>
</ol>
<p>在减少UV Shells数量之前，先了解下背后的原理，以及相关帮助和查看窗口：<br>官方的UV Shells拆分示例：<br><img src="/img/Unity/MultipleUVShells.PNG" alt="MultipleUVShells"></p>
<p><img src="/img/Unity/SingleUIShell.PNG" alt="SingleUIShell"></p>
<p>查看LightmapChart:<br>Scene -&gt; Draw Mode -&gt; GI -&gt; UV Chart<br><img src="/img/Unity/UVChart.PNG" alt="UVChart"></p>
<p>查看特定物件的UV Chart:</p>
<ol>
<li>选中要查看的物体</li>
<li>Window -&gt; Lighting -&gt; Obejct</li>
<li>左上角选择Chart模式</li>
</ol>
<p><img src="/img/Unity/SpecificObjectUVChart.PNG" alt="SpecificObjectUVChart"><br><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unitygi-6.html" target="_blank" rel="external">Charting模式的预览视窗会用不同的颜色的格子表示光照图，并用浅蓝色的线表示UV贴图。</a></p>
<p>更多关于UV Chart生成相关的因素，参考:<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/unwrapping-and-chart-reduction?playlist=17102" target="_blank" rel="external">Unwrapping and Chart reduction</a></p>
<p>这里简单提一下:<br>Mesh Renderer上面的:</p>
<ol>
<li>Auto UV Max Distance(自動最大UV距離)</li>
<li>Auto UV Max Angle(自動最大UV角度)</li>
<li>Preserve UVs(保留UV)</li>
<li>Ignore Normals(忽略法線)</li>
</ol>
<p>开启Auto Lighting，然后调节相关数值通过UV Chart Preview帮助我们快速查看UV Chart实时效果。</p>
<p>如何通过UV Chats判定失真程度？<br><img src="/img/Unity/UVChartDistortionAnalysi.PNG" alt="UVChartDistortionAnalysi"><br><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unitygi-6.html" target="_blank" rel="external">当启用UI Charts绘制模式时，失真的程度能从场景里的棋盘圆拉扯状况来评估。</a></p>
<p>如何正确使用Probe Lighting减少Static物体参与PRGI？<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/probe-lighting?playlist=17102" target="_blank" rel="external">Probe lighting is a fast technique for approximating lighting in realtime rendering applications such as games.</a>(光照探测技术是一个能在游戏里让即时光照更逼真的快速演算法)</p>
<p>原理：<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/probe-lighting?playlist=17102" target="_blank" rel="external">Probe lighting works by sampling the incoming lighting at a specific point in 3D space and encoding this information across a sphere using mathematical functions known as spherical harmonics. These coefficients have low storage cost and can be then be quickly ‘unpacked’ at gameplay and used by shaders within the Scene to approximate surface lighting.</a>(光照探测的原理是透过放在3D空间里的探针来接受照明信息，然后用像球鞋函数(spherical harmonics)的数学算法将结果编码在一个球体上，这些信息暂用空间很小，但在游戏运行时解包很快，并参与表面光照计算)</p>
<p>Note:<br><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unitygi-5.html" target="_blank" rel="external">我們的目的是取样场景里的间接或反射光照。为了让每个光照探头效能花在刀口上， 尽量确保他们对一些变化明显的地方进行采样</a></p>
<p>如何减少Cluster数量？<br>让我们先通过查看贴图了解下Cluster真实情况：<br><img src="/img/Unity/ClusterPicture.PNG" alt="ClusterPicture"></p>
<p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/understanding-clusters?playlist=17102" target="_blank" rel="external">Clusters sample the albedo of the Static geometry to which they are mapped. Then, during the Light Transport stage of the precompute, the relationship between these Clusters is calculated so that light can be propagated throughout the Cluster network.</a><br>(Cluster会对静态物体表面的反射率(Albedo)进行采样，在光照传递计算阶段计算Cluster之间的关系好让光在整个Cluster网之间传递)</p>
<p><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unitygi-7.html" target="_blank" rel="external">一旦与计算完成后，你就可以修改Skybox或光线的位置，强度和颜色，不需要重新与计算，光线就会透过这些Cluster网信息，联通场景材质和发光材质一并考虑计算光照反射。</a></p>
<p><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unitygi-7.html" target="_blank" rel="external">Clustering或Lit Clustering Scene Mode模式来观察Cluster分布</a></p>
<p>了解了Cluster相关知识概念后，那么如何真正降低Cluster数量了？<br>Lightmap Parameters控制，用于公用。<br>Asset &gt; Create &gt; Lightmap Parameters<br>通过GameObejct -&gt; Mesh Renderer -&gt; Lightmao Parameters指定<br><img src="/img/Unity/LightMapParameter.PNG" alt="LightMapParameter"></p>
<p>具体参数详细学习参考:<br><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unitygi-8.html" target="_blank" rel="external">Unity預計算即時GI - 8.微調光照參數</a></p>
<p>PRGI实战：</p>
<ol>
<li>设置需要Bake的物体为Static(规划好层级可快速批量设置Static)</li>
<li>Window -&gt; Lighting -&gt; Build(勾选Auto，自动触发Precompute)</li>
<li>减少Lightmap Chart数量(部分物体(比如凸起的小物件)用Lighting Probe技术而非Static)</li>
<li>管理Lighting Probe(创建GameObject &gt; Light &gt; Light Probe Group)</li>
<li>放置Lighting Probe(GameObject &gt; Light &gt; Light Probe Group -&gt; Edit Light Probes)</li>
</ol>
<p>Baked Lighting AssetBundle实战：<br>目标：</p>
<ol>
<li>Baked Lighting，通过打包AB的形式加载还原Baked Lighting</li>
<li>支持Reflection Probe的AB加载还原(这个只是单纯加载了依赖的Cubemap没有做任何的还原操作，暂时表现是对的，具体待学习了解)</li>
</ol>
<p>实战：</p>
<ol>
<li>新建一个场景，添加必要的物件与光照</li>
<li>设置需要Bake的物体为Static</li>
<li>减少Lightmap Chart数量(部分物体(比如凸起的小物件)用Lighting Probe技术而非Static)</li>
<li>设置所有需要参与Bake的光照为Baked模式(只用于Baked Lighting)</li>
<li>Window -&gt; Lighting -&gt; Build(勾选Auto，自动触发Precompute Lightmap)</li>
<li>删除所有完成静态烘焙的Light</li>
<li>记录场景里所使用的光照信息(LightmapSettings.lightmaps)以及所有参与了静态光照的静态物体所使用的光照图信息(Renderer.lightmapIndex和Renderer.lightmapScaleOffset)</li>
<li>运行时加载所有依赖的光照贴图信息，并还原所有静态物体使用的光照贴图信息</li>
</ol>
<p>烘焙之后的场景光照使用信息:<br><img src="/img/Unity/LightmapBake.PNG" alt="LightmapBake"></p>
<p>烘焙之后记录下场景使用的光照信息运行时还原:</p>
<p>打包场景AB以及光照信息记录代码:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sceneasset = AssetDatabase.LoadAssetAtPath&lt;Object&gt;(abfullpath);</span><br><span class="line">AssetImporter assetimporter = AssetImporter.GetAtPath(abfullpath);</span><br><span class="line"><span class="keyword">var</span> abname = ABPackageHelper.Singleton.getABTypeCorrespondingName(EABType.E_AB_SCENE, sceneasset.name);</span><br><span class="line">assetimporter.assetBundleName = abname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录Lightmap相关信息，加载场景时用于还原Lightmap</span></span><br><span class="line"><span class="keyword">var</span> scenename = Path.GetFileNameWithoutExtension(abfullpath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开需要打包的场景</span></span><br><span class="line"><span class="keyword">var</span> scene = EditorSceneManager.OpenScene(abfullpath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scenego = GameObject.Find(scenename);</span><br><span class="line"><span class="keyword">var</span> lmr = scenego.GetComponent&lt;LightMapRestore&gt;();</span><br><span class="line"><span class="keyword">if</span> (lmr != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    GameObject.DestroyImmediate(lmr);</span><br><span class="line">&#125;</span><br><span class="line">lmr = scenego.AddComponent&lt;LightMapRestore&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录Lightmap使用信息</span></span><br><span class="line">Debug.Log(<span class="keyword">string</span>.Format(<span class="string">"LightmapSettings.lightmaps.Length = &#123;0&#125;"</span>, LightmapSettings.lightmaps.Length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试目的，暂时只默认只有一个Lightmap</span></span><br><span class="line">lmr.LightMapColor = LightmapSettings.lightmaps[<span class="number">0</span>].lightmapColor == <span class="keyword">null</span> ? <span class="keyword">string</span>.Empty : LightmapSettings.lightmaps[<span class="number">0</span>].lightmapColor.name;</span><br><span class="line">lmr.LightMapDir = LightmapSettings.lightmaps[<span class="number">0</span>].lightmapDir == <span class="keyword">null</span> ? <span class="keyword">string</span>.Empty : LightmapSettings.lightmaps[<span class="number">0</span>].lightmapDir.name;</span><br><span class="line">lmr.LightMapDataList = <span class="keyword">new</span> List&lt;LightMapData&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有烘焙对象的Lightmap相关信息(测试查看)</span></span><br><span class="line"><span class="keyword">var</span> allrootgos = scene.GetRootGameObjects();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; allrootgos.Length; m++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> allmeshcom = allrootgos[m].transform.GetComponentsInChildren&lt;Renderer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; allmeshcom.Length; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        LightMapData lmd = <span class="keyword">new</span> LightMapData();</span><br><span class="line">        lmd.RendererObject = allmeshcom[n];</span><br><span class="line">        lmd.LightMapIndex = allmeshcom[n].lightmapIndex;</span><br><span class="line">        lmd.LightMapScaleOffset = allmeshcom[n].lightmapScaleOffset;</span><br><span class="line">        lmr.LightMapDataList.Add(lmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存场景</span></span><br><span class="line">EditorSceneManager.SaveScene(scene);</span><br><span class="line"></span><br><span class="line">AssetDatabase.Refresh();</span><br></pre></td></tr></table></figure></p>
<p>还原代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightMapData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Renderer RendererObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> LightMapIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector4 LightMapScaleOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> 静态光照烘焙还原</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightMapRestore</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LightMapColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LightMapDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;LightMapData&gt; LightMapDataList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// 还原各静态烘焙物体的lightmap信息</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> lmd <span class="keyword">in</span> LightMapDataList)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="keyword">string</span>.Format(<span class="string">"还原&#123;0&#125;Lightmap信息:LightMapIndex:&#123;1&#125; LightMapScaleOffset:&#123;2&#125;"</span>, lmd.RendererObject.name, lmd.LightMapIndex, lmd.LightMapScaleOffset));</span><br><span class="line">            lmd.RendererObject.lightmapIndex = lmd.LightMapIndex;</span><br><span class="line">            lmd.RendererObject.lightmapScaleOffset = lmd.LightMapScaleOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>光照信息记录:<br><img src="/img/Unity/LightMapData.PNG" alt="LightMapData"></p>
<p>加载还原后的效果:<br><img src="/img/Unity/LightMapRestore.PNG" alt="LightMapRestore"></p>
<p>那如何Bake多份Lightmap进行动态切换了？<br>Unity 5.X如果想Bake多份Lightmap，需要复制保留之前Bake出的Texture，然后通过修改LightmapSetting的值即可(因为是同一个场景，静态物体的lightmapIndex和lightmapScaleOffset值都没变，所以直接切换LightmapSetting里的lightmaps即可)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lightmaptex = TextureResourceLoader.getInstance().loadTexture(newlightmapname);</span><br><span class="line"><span class="keyword">var</span> newlightmapdata = <span class="keyword">new</span> LightmapData();</span><br><span class="line">newlightmapdata.lightmapColor = lightmaptex;</span><br><span class="line">LightmapSettings.lightmaps = <span class="keyword">new</span> LightmapData[] &#123; newlightmapdata &#125;;</span><br></pre></td></tr></table></figure>
<p>参考文章：<br><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unity-gi-1.html" target="_blank" rel="external">Introduction to Precomputed Realtime GI</a><br><a href="http://unitytaiwan.blogspot.co.uk/2016/12/unity-gi-1.html" target="_blank" rel="external">Unity預計算即時GI</a></p>
<h4 id="Render_Path">Render Path</h4><p>Forward Rendering<br>实时光照运算，计算量跟灯光数量成正比</p>
<p>Deffered Rendering<br>实时光照运算，计算量跟Pixels数量成正比而非光照</p>
<p>Edit -&gt; Project Setting -&gt; Player -&gt; Rendering -&gt; Rendering Path</p>
<h4 id="Color_Space">Color Space</h4><p>Linear Color Space<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-color-space?playlist=17102" target="_blank" rel="external">A significant advantage of using Linear space is that the colors supplied to shaders within your scene will brighten linearly as light intensities increase.</a></p>
<p>Gamma Color Space<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/choosing-color-space?playlist=17102" target="_blank" rel="external">Gamma’ Color Space, brightness will quickly begin to turn to white as values go up, which is detrimental to image quality.</a></p>
<p>Edit -&gt; Project Setting -&gt; Player -&gt; Rendering -&gt; Color Space</p>
<h3 id="High_Dynamic_Range">High Dynamic Range</h3><p><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/high-dynamic-range-hdr?playlist=17102" target="_blank" rel="external">HDR(High Dynamic Range) defines how extremely bright or dark colors are captured by scene cameras.</a>(HDR决定光照颜色信息精度)</p>
<p>Note:<br><a href="https://unity3d.com/cn/learn/tutorials/topics/graphics/high-dynamic-range-hdr?playlist=17102" target="_blank" rel="external"> HDR is unsupported by some mobile hardware. It is also not supported in Forward Rendering when using techniques such as multi-sample anti-aliasing (MSAA).</a>(Forward Rendering使用MSAA时不支持HDR)</p>
<p>待续</p>
<h2 id="基础纹理">基础纹理</h2><h3 id="纹理类型分类">纹理类型分类</h3><p>一下以Unity支持的导入设置纹理格式来分(一下只重点关注几个重要的)：<br>Note:<br>随着Unity版本的变化，以下格式可能有细微变化(比如5.4里面的Adavanced已经没有了，取而代之的是细分到其他几个类型里)</p>
<h4 id="Delfaut(Advanced)">Delfaut(Advanced)</h4><p>这个是Unity在高版本默认的纹理格式，也是平时我们最常用的纹理格式之一。</p>
<p>如果要想将2D纹理图片作为纹理渲染到3D物体上，我们需要选择Default进行纹理格式的基本导入设置。</p>
<p>这里只提几个比较重要的设置，后续会讲到相关的概念。</p>
<ol>
<li>Non Power of 2(用于将不是2的倍数的纹理图片进行优化处理成2的倍数的宽高)</li>
<li>Generate Mip Maps(预生成多个不同大小的纹理图片，用于不同距离是显示，解决很大的纹理在显示很小的时候失真和浪费的问题)</li>
<li>Wrap Mode(用于设置处理在tiled纹理图片时的方式)</li>
</ol>
<h4 id="Normal_Map">Normal Map</h4><p>在之前的OpenGL学习中已经接触过Normal Map了，这里只是简单说一下什么是和为什么需要Normal Map。</p>
<p>什么是Normal Map?<br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Normal_Mapping">Normal Mapping也叫做Dot3 Bump Mapping,它也是Bump Mapping的一种，区别在于Normal Mapping技术直接把Normal存到一张NormalMap里面，从NormalMap里面采回来的值就是Normal，不需要像HeightMap那样再经过额外的计算。<br>值得注意的是，NormalMap存的Normal是基于切线空间的，因此要进行光照计算时，需要把Normal,Light Direction,View direction统一到同一坐标空间中。</a></p>
<p>至于什么是Bump Mapping，为什么normal map的normal值是存在tangent space，什么是tangent space，详情参考：<br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Normal_Mapping">Normal Map</a></p>
<p>为什么需要Normal Map？<br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Normal_Mapping">如果要在几何体表面表现出凹凸不平的细节，那么在建模的时候就会需要很多的三角面，如果用这样的模型去实时渲染，出来的效果是非常好，只是性能上很有可能无法忍受。Bump Mapping不需要增加额外的几何信息,就可以达到增强被渲染物体的表面细节的效果，可以大大地提高渲染速度，因此得到了广泛的应用。</a></p>
<h4 id="Sprite">Sprite</h4><p>这个是我们制作UI和2D游戏最常用的格式。</p>
<p>这里也将几个Sprite比较重要的设置：</p>
<ol>
<li>Packing Tag(Unity自带的打包图集工具所使用用于决定哪些图片时打在同一个图集里的标识。采用TexturePacker单独处理图片格式以及图集见后面)</li>
<li>Pixels Per Unit(用于决定图片在屏幕上的映射显示大小，这个以及Camera Orthographic Size会影响我们制作Sprite时的大小标准以及Pixel Perfect显示。详情参考之前的学习<a href="http://tonytang1990.github.io/2015/07/15/Unity-Study/#Unity_Unit_&amp;_Pixel_Per_Unit">Unity Unit &amp; Pixel Per Unit</a>和<a href="http://tonytang1990.github.io/2016/12/11/Unity-Plugins/#NGUI_2-7屏幕自适应">NGUI 2.7屏幕自适应</a>)</li>
<li>Generate Mip Maps(这个概念和前面Default提到的一样，但大部分时候UI和2D游戏都不需要设置这个，因为UI一般不会有太大的大小变化，2D游戏里的图片同理)</li>
</ol>
<h4 id="Lightmap">Lightmap</h4><p>待学习</p>
<p>更多的纹理格式还有Editor GUI and Legacy, Cursor, Cookier, Single Channel这里就不一一详解了，详情参见<a href="https://docs.unity3d.com/Manual/TextureTypes.html" target="_blank" rel="external">TextureTypes]</a></p>
<h3 id="纹理大小">纹理大小</h3><p><a href="https://docs.unity3d.com/Manual/ImportingTextures.html#TextureSizes" target="_blank" rel="external">Ideally, Texture dimension sizes should be powers of two on each side (that is, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048 pixels (px), and so on). The Textures do not have to be square; that is the width can be different from height.</a></p>
<p>上面是Unity官方给出的建议，Texture纹理大小宽高最好是2的N次方倍数。</p>
<p>那么为什么会有Power Of 2这个原则了？</p>
<ol>
<li>硬件GPU(以前的GPU还不支持Non Power Of 2大小的Texture加载。现在虽然支持了但Power Of 2的加载速度始终要比Non Power Of 2快)</li>
<li>内存使用(None Power Of 2的Texture在分配内存时始终会分配最近的Power Of 2大小，如果不采用Power Of 2的Texture会浪费部分内存分配)</li>
<li>纹理压缩格式支持(有些纹理压缩格式只支持特定宽高的纹理图片，比如DXT1只支持mutilple of 4的Texture Size压缩)</li>
</ol>
<p>Texture的最大Size受限于渲染API(相当于硬件所支持的API)等级有关：<br><img src="/img/Unity/TextureMaxSize.JPG" alt="TextureMaxSize"></p>
<p>Note:<br>如果我们想在Unity里使用Non Power Of 2的Texture，我们需要在导入Texture时手动设置成NPO2，不然Unity会自动帮我们转换成Power Of 2的Texture。</p>
<p>参考文章：<br><a href="https://software.intel.com/en-us/articles/opengl-performance-tips-power-of-two-textures-have-better-performance" target="_blank" rel="external">OpenGL* Performance Tips: Power of Two Textures Have Better Performance</a></p>
<h3 id="图片格式">图片格式</h3><p>图片是游戏里使用最基础也是最频繁的资源，图片的格式是决定内存占用多少的关键。</p>
<p>所以这里需要了解为什么图片格式会影响最终的内存占用以及如何选择正确的图片格式达到最低的内存占用实现我们所需的效果。以及相关工具帮助我们优化图片内存占用的问题。</p>
<p>图片加载内存计算方式？<br>图片宽度 <em> 图片高度 </em> 每个像素点的位数 = 内存大小</p>
<p>图片格式决定了每个像素点的位数的多少，比如RGBA8888（32-bit图）代表每个像素点存储了8 bit的R,G,B,A(分别代表红绿蓝透明通道)，总共32 bit即4 byte大小。</p>
<p>所以1024 <em> 1024大小的RGBA8888的图片所需内存占用计算如下：<br>1024 </em> 1024 * 4byte = 4M</p>
<p>图片格式有哪些？<br>以下引用至<a href="http://blog.csdn.net/u011476173/article/details/38712031" target="_blank" rel="external">图片格式及内存占用</a>:<br>(1)RGBA8888(32-bit)<br>    RGBA 4个通道各占8位，如果想获得最好的图片质量，使用这种格式最靠谱，但他占用的内存会比16位的纹理多一倍，加载速度相对较慢。<br>（2）RGBA4444(16-bit)<br>    RGBA 4个通道各占4位，他对每个通道都有不错的支持，还能保证相对良好的图片质量，以及加载速度和内存占用。<br>（3）RGB5A1   (16-bit)<br>    RGB 3个通道各占5位，A通道仅占一位，RGB通道表现良好，A通道只有透明和不透明两种，加载速度和内存占用表现良好。<br>（4）RGB565   (16-bit)<br>    RGB 3个通道分别占5、6、5位，没有A通道，在16为纹理中，图片质量最好。</p>
<p>如何选择正确的图片格式？<br>了解各个图片格式的详细信息后，图片格式的选取根据具体需求而定。取舍主要在于内存占用和显示质量。待深入度研究。</p>
<p>参考文章：<br><a href="http://blog.csdn.net/u011476173/article/details/38712031" target="_blank" rel="external">图片格式及内存占用</a></p>
<h3 id="纹理压缩方式">纹理压缩方式</h3><p><a href="https://docs.unity3d.com/Manual/class-TextureImporterOverride.html" target="_blank" rel="external">While Unity supports many common image formats as source files for importing your Textures (such as JPG, PNG, PSD and TGA), these formats are not used during realtime rendering by 3D graphics hardware such as a graphics card or mobile device. 3D graphics hardware requires Textures to be compressed in specialized formats which are optimised for fast Texture sampling. The various different platforms and devices available each have their own different proprietary formats.</a></p>
<p>从上述官网描述可以看出，我们游戏最终使用的纹理格式并非最初我们导入的JPG,PNG,PSD or TGA，而是经过特定压缩方式(ETC,PVRTC,ATC,DXT……)压缩后的指定纹理格式的Texture，目的是为了运行使用Texture时更高效，内存占用和显示质量上可以做取舍。</p>
<p>各平台主流通用的纹理压缩方式：<br>PC — DXT<br>Android — ETC<br>IOS — PVRTC</p>
<h3 id="Unity纹理使用">Unity纹理使用</h3><p>下面是个人总结的部分知识点：<br>Unity最终使用的不是我们最初导入到项目工程里的JPG,PNG等，而是通过根据指定压缩方式(e.g. ETC)得到的特定纹理格式(e.g. RGBA8888)的纹理图片，目的是为了减少内存开销以及加快GPU的纹理采样速度。</p>
<p>如何选择正确的纹理格式？<br>了解各个纹理格式的详细信息后，纹理格式的选取根据具体需求而定。取舍主要在于内存占用和显示质量之间。</p>
<p>那么有什么相关工具可以帮助我们优化图片使用过程中的内存占用问题吗？<br>答案是：SpritePacker(Unity官方自带工具，最新的Unity 2017貌似推出了Sprite Atlas，打包图集更加灵活) 和 TexturePacker(第三方工具，打包图集(优化空白处减少内存开销，指定图集导出格式减少内存占用，减少drawcall等好处))</p>
<p>那么使用哪一个(Sprite Packer or Texture Packer)用于Unity图集打包工具更好了？<br>Unity通过SpritePacker模糊了图集的概念，通过Sprite Packer设置Tag打包的图集只有在最后打包的时候才会被打进包里。Sprite Packer虽然与Unity开发结合的比较紧密，但灵活度上有所欠缺，Unity 2017推出的Sprite Atlas在灵活度上加强了不少。<br>TexturePacker作为第三方工具，结合Unity使用灵活度更高，可以自定义图集打包的各项参数等，最终放到Unity里的图集是已经打包好的图集。<br>就当前5.4版本的Unity而言，在没有Sprite Altas的前提下，个人觉得采用Texture Packer会更灵活一些，通过Texture Packer我们可以预先打出图集，然后直接将图集打包成ab。</p>
<h4 id="纹理的基础使用">纹理的基础使用</h4><p>纹理最基础的应用是用于模型外观。</p>
<p>我们直接来看看BlinnPhong光照模型结合纹理贴图的使用代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Blinn-Phong光照模型结合单独的纹理使用Shader</span></span><br><span class="line">Shader <span class="string">"Custom/Texture/SingleTextureShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光范围</span></span><br><span class="line">        _Gloss(<span class="string">"Gloss"</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">        <span class="comment">// 给Material面板暴露纹理图片</span></span><br><span class="line">        _MainTex (<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="preprocessor">#include "UnityCG.cginc"</span></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;       <span class="comment">// 物体坐标系顶点位置</span></span><br><span class="line">                float3 normal : NORMAL;         <span class="comment">// 物体坐标系法线</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">// 纹理</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;       <span class="comment">// 投影坐标系顶点位置</span></span><br><span class="line">                float3 worldnormal : TEXCOORD0; <span class="comment">// 世界坐标系法线</span></span><br><span class="line">                float3 worldpos : TEXCOORD1;    <span class="comment">// 世界坐标系顶点位置</span></span><br><span class="line">                float2 uv : TEXCOORD2;          <span class="comment">// 纹理映射信息</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射系数</span></span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光范围</span></span><br><span class="line">            <span class="keyword">float</span> _Gloss; </span><br><span class="line">            <span class="comment">// 对应材质面板的纹理贴图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="comment">// 纹理材质的纹理属性(e.g. 纹理缩放值，偏移值)</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                o.worldnormal = normalize(UnityObjectToWorldNormal(v.normal));</span><br><span class="line">                o.worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 通过纹理基础信息和纹理属性得出纹理映射UV坐标</span></span><br><span class="line">                <span class="comment">// TRANSFORM_TEX() == (tex.xy * name##_ST.xy + name##_ST.zw)</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 使用纹理贴图的颜色信息作为漫反射系数</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                <span class="comment">// 顶点光线入射向量</span></span><br><span class="line">                fixed3 worldlightdir = normalize(UnityWorldSpaceLightDir(i.worldpos.xyz));</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(i.worldnormal, worldlightdir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 高光反射</span></span><br><span class="line">                <span class="comment">// 世界坐标系下的从顶点到观察点的观察方向v</span></span><br><span class="line">                fixed3 viewdir = normalize(UnityWorldSpaceViewDir(i.worldpos.xyz));</span><br><span class="line">                <span class="comment">// h = (v + l) / |v + l| v和l向量归一化后的向量</span></span><br><span class="line">                fixed3 halfdir = normalize(worldlightdir + viewdir);</span><br><span class="line">                <span class="comment">// 计算高光反射的颜色信息</span></span><br><span class="line">                <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(n,h)), m(gloss))</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(i.worldnormal, halfdir)), _Gloss);</span><br><span class="line">                <span class="comment">// 将高光反射的颜色信息输出到最终的顶点颜色</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Specular"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Unity/SimpleTextureShader.JPG" alt="BlinnPhong光照模型的纹理使用"></p>
<h4 id="Mipmap">Mipmap</h4><p>说到纹理的使用，这里不得不提的就是Mipmap的应用：<br><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Texture_Mapping">mipmap主要是由于物体在场景中因为距离的缘故会在屏幕显示的大小有变化，如果我们在物体很远，只需要显示很小一块的时候还依然采用很大的纹理贴图，最终显示在屏幕上的纹理会很不清晰（失真）。为了解决这个问题，mipmap应运而生，通过事先生成或指定多个级别的同一纹理贴图，然后在程序运作的过程中通过计算算出应该使用哪一个等级的纹理贴图来避免大纹理小色块失真的问题。</a></p>
<p>在Unity为Texture开启Mipmap，我们需要把纹理类型设置成Advanced，然后勾选Generate Mip Map即可：<br><img src="/img/Unity/TextureMipmapImportSetting.JPG" alt="TextureMipmapImportSetting"></p>
<p>需要注意的是，Unity开启Mipmap后会导致资源纹理内存占用增加。关于Advanced纹理的各个详细参数信息参考<a href="https://docs.unity3d.com/Manual/TextureTypes.html" target="_blank" rel="external">Texture Import Setting</a></p>
<p>Note:<br>注意纹理在DX和OpenGL里的起点不一样，DX是左上角(0,0)，OpenGL和Unity是左下角(0,0)。</p>
<h4 id="凹凸映射">凹凸映射</h4><p>这里的凹凸映射指的就是之前OpenGL学习的Normal Mapping和Bump Mapping，这里直接使用之前的总结：高模normal map用于低模模型上，即不增加渲染负担又能增加渲染细节。</p>
<p>还有一个凹凸映射叫做高度纹理(Height Map)，一般用于存储地形高度信息。</p>
<h5 id="Height_Map">Height Map</h5><p>用于存储高度信息，通常用于地形的Height Map。</p>
<h5 id="Normal_Mapping">Normal Mapping</h5><p>关于Normal Mapping要注意的地方主要是两点：</p>
<ol>
<li>存储的法线信息是基于切线空间的，需要转换计算位于世界坐标系的法线信息。</li>
<li>纹理贴图的信息范围是[0,1]，而法线信息时[-1,1]需要通过映射转换。</li>
</ol>
<p><a href="http://tonytang1990.github.io/2015/08/26/OpenGL-Study/#Normal_Mapping">Normal Mapping详细信息参考</a></p>
<p>这里直接给出使用Unity编写Normal Mapping的使用代码和效果(以下代码采用的是将切线空间的法线转换到世界坐标系参与光照计算的方法)：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line"></span><br><span class="line">Shader <span class="string">"Custom/Texture/NormalMappingShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露主纹理</span></span><br><span class="line">        _MainTex(<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">        <span class="comment">// 给Material面板暴露法线贴图</span></span><br><span class="line">        <span class="comment">// bump是Unity自带的法线纹理</span></span><br><span class="line">        _NormalMap(<span class="string">"Normal Map"</span>, <span class="number">2</span>D) = <span class="string">"bump"</span> &#123;&#125;</span><br><span class="line">        <span class="comment">// 法线贴图的有效程度，用于控制凹凸程度</span></span><br><span class="line">        _BumpScale(<span class="string">"Bump Scale"</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光范围</span></span><br><span class="line">        _Gloss(<span class="string">"Gloss"</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "UnityCG.cginc"</span></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;       <span class="comment">// 物体坐标系顶点位置</span></span><br><span class="line">                float3 normal : NORMAL;         <span class="comment">// 物体坐标系法线</span></span><br><span class="line">                float4 tangent : TANGENT;       <span class="comment">// 切线空间的顶点切线(用于计算切线空间的坐标系)</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">// 纹理位置信息(用于通过采样获取纹理的UV信息)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;       <span class="comment">// 投影坐标系顶点位置</span></span><br><span class="line">                float4 uv : TEXCOORD0;          <span class="comment">// 主纹理和法线纹理的UV坐标信息(xy为主纹理的UV，zw为法线纹理的UV，用于后续的纹理采样)</span></span><br><span class="line">                float4 ttow0 : TEXCOORD1;       <span class="comment">// 切线空间y轴转换到世界坐标系后的y轴</span></span><br><span class="line">                float4 ttow1 : TEXCOORD2;       <span class="comment">// 切线空间x轴转换到世界坐标系后的x轴</span></span><br><span class="line">                float4 ttow2 : TEXCOORD3;       <span class="comment">// 切线空间z轴转换到到世界坐标系后的z轴</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的纹理贴图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="comment">// 纹理材质的纹理属性(e.g. 纹理缩放值，偏移值)</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="comment">// 对应材质面板法线贴图</span></span><br><span class="line">            sampler2D _NormalMap;</span><br><span class="line">            <span class="comment">// 法线贴图材质的纹理属性(e.g. 纹理缩放值，偏移值)</span></span><br><span class="line">            float4 _NormalMap_ST;</span><br><span class="line">            <span class="comment">// 对应材质面板法线贴图有效程度参数</span></span><br><span class="line">            <span class="keyword">float</span> _BumpScale;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射系数</span></span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光范围</span></span><br><span class="line">            <span class="keyword">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 通过tangent和normal值计算出将tangent转换到世界坐标系的矩阵(世界坐标系下的XYZ轴)</span></span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// **_ST</span></span><br><span class="line">                <span class="comment">// x contains X tiling value</span></span><br><span class="line">                <span class="comment">// y contains Y tiling value</span></span><br><span class="line">                <span class="comment">// z contains X offset value</span></span><br><span class="line">                <span class="comment">// w contains Y offset value</span></span><br><span class="line">                <span class="comment">// 主纹理的UV信息</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">// 法线纹理的UV信息</span></span><br><span class="line">                o.uv.zw = v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                float3 worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 世界坐标系下的normal(相当于y轴)</span></span><br><span class="line">                fixed3 worldnormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                <span class="comment">// 世界坐标系下的tangent(相当于x轴)</span></span><br><span class="line">                fixed3 worldtangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                <span class="comment">// 世界坐标系下的normal和tangent计算出binormal</span></span><br><span class="line">                <span class="comment">// 世界坐标系下的binormal(相当于z轴)</span></span><br><span class="line">                fixed3 worldbinormal = cross(worldnormal, worldtangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 填充从tangent space转换到world space的矩阵</span></span><br><span class="line">                <span class="comment">// 注意因为是列向量，所以注意填充方式</span></span><br><span class="line">                <span class="comment">// worldpos填充在w后续使用</span></span><br><span class="line">                o.ttow0 = float4(worldtangent.x, worldbinormal.x, worldnormal.x, worldpos.x);</span><br><span class="line">                o.ttow1 = float4(worldtangent.y, worldbinormal.y, worldnormal.y, worldpos.y);</span><br><span class="line">                o.ttow2 = float4(worldtangent.z, worldbinormal.z, worldnormal.z, worldpos.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 世界坐标系顶点位置</span></span><br><span class="line">                fixed3 worldpos = float3(i.ttow0.w,i.ttow1.w,i.ttow2.w);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算世界坐标系的法线信息</span></span><br><span class="line">                <span class="comment">// bump为切线空间的法线信息</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_NormalMap, i.uv.zw));</span><br><span class="line"></span><br><span class="line">                bump.xy *= _BumpScale;</span><br><span class="line">                bump.z = sqrt(<span class="number">1.0</span> - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将切线空间空间的法线信息转换到世界坐标系下</span></span><br><span class="line">                bump = normalize(half3(dot(i.ttow0.xyz, bump), dot(i.ttow1.xyz, bump), dot(i.ttow2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 利用转换到世界坐标系的法线信息，正式开始光照计算</span></span><br><span class="line">                <span class="comment">// 使用纹理贴图的颜色信息作为漫反射系数</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 漫反射</span></span><br><span class="line">                <span class="comment">// 顶点光线入射向量</span></span><br><span class="line">                fixed3 worldlightdir = normalize(UnityWorldSpaceLightDir(worldpos));</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(bump, worldlightdir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 高光反射</span></span><br><span class="line">                <span class="comment">// 世界坐标系下的从顶点到观察点的观察方向v</span></span><br><span class="line">                fixed3 viewdir = normalize(UnityWorldSpaceViewDir(worldpos));</span><br><span class="line">                <span class="comment">// h = (v + l) / |v + l| v和l向量归一化后的向量</span></span><br><span class="line">                fixed3 halfdir = normalize(worldlightdir + viewdir);</span><br><span class="line">                <span class="comment">// 计算高光反射的颜色信息</span></span><br><span class="line">                <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(n,h)), m(gloss))</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(bump, halfdir)), _Gloss);</span><br><span class="line">                <span class="comment">// 将高光反射的颜色信息输出到最终的顶点颜色</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Specular"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/NormalMappingTextureShader.PNG" alt="BlinnPhong光照模型的Normal Mapping纹理使用"></p>
<h5 id="Ramp_Texture(渐变纹理)">Ramp Texture(渐变纹理)</h5><p>比较普遍的用法是使用渐变纹理来控制漫反射光照运算。<br>让我们直接看代码和效果图。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"Custom/Texture/RampTextureShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露渐变纹理贴图</span></span><br><span class="line">        _RampTex(<span class="string">"Ramp Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光范围</span></span><br><span class="line">        _Gloss(<span class="string">"Gloss"</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "UnityCG.cginc"</span></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;       <span class="comment">// 物体坐标系顶点位置</span></span><br><span class="line">                float3 normal : NORMAL;         <span class="comment">// 物体坐标系法线</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">// 纹理位置信息(用于通过采样获取纹理的UV信息)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;       <span class="comment">// 投影坐标系顶点位置</span></span><br><span class="line">                float3 worldnormal : TEXCOORD0; <span class="comment">// 世界坐标系下的法线</span></span><br><span class="line">                float3 worldpos : TEXCOORD1;    <span class="comment">// 世界坐标系下的顶点位置</span></span><br><span class="line">                float2 uv : TEXCOORD2;          <span class="comment">// 渐变纹理的UV坐标信息</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板渐变纹理贴图</span></span><br><span class="line">            sampler2D _RampTex;</span><br><span class="line">            <span class="comment">// 渐变纹理贴图的纹理属性(e.g. 纹理缩放值，偏移值)</span></span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射系数</span></span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光范围</span></span><br><span class="line">            <span class="keyword">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 通过tangent和normal值计算出将tangent转换到世界坐标系的矩阵(世界坐标系下的XYZ轴)</span></span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                o.worldnormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                fixed3 worldnormal = normalize(i.worldnormal);</span><br><span class="line">                fixed3 worldlightdir = normalize(UnityWorldSpaceLightDir(i.worldpos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 半兰伯特反漫射光照模型</span></span><br><span class="line">                <span class="keyword">fixed</span> halflambert = dot(i.worldnormal, worldlightdir) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// 利用半兰伯特得到的[0,1]范围值渐变纹理采样</span></span><br><span class="line">                fixed3 diffusecolor = tex2D(_RampTex, fixed2(halflambert, halflambert)).rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                fixed3 diffuse = _LightColor0 * diffusecolor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 高光反射</span></span><br><span class="line">                <span class="comment">// 世界坐标系下的从顶点到观察点的观察方向v</span></span><br><span class="line">                fixed3 viewdir = normalize(UnityWorldSpaceViewDir(i.worldpos));</span><br><span class="line">                <span class="comment">// h = (v + l) / |v + l| v和l向量归一化后的向量</span></span><br><span class="line">                fixed3 halfdir = normalize(worldlightdir + viewdir);</span><br><span class="line">                <span class="comment">// 计算高光反射的颜色信息</span></span><br><span class="line">                <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(n,h)), m(gloss))</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(i.worldnormal, halfdir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将高光反射的颜色信息输出到最终的顶点颜色</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Specular"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/RampTexture.PNG" alt="渐变纹理"><br>可以看出利用半兰伯特把法线映射到[0,1]后，作为渐变纹理采样的uv，这样一来面向光照方向的顶点会更靠纹理采样的1，反之完全与光照相反方向的顶点会更靠近纹理采样的0的位置，然后把渐变纹理的采样信息作为漫反射的基础颜色信息参与光照运算。</p>
<h5 id="Mask_Texture(遮罩纹理)">Mask Texture(遮罩纹理)</h5><p>“遮罩允许我们可以保护某些区域，使它们免于修改。遮罩纹理已经不止限于保护区域避免修改，而是存储我们希望逐像素控制的表面属性。”<br>让我们直接看代码和效果图：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced '_Object2World' with 'unity_ObjectToWorld'</span></span><br><span class="line">Shader <span class="string">"Custom/Texture/MaskTextureShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 给Material面板暴露主纹理</span></span><br><span class="line">        _MainTex(<span class="string">"Texture"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">        <span class="comment">// 给Material面板暴露法线贴图</span></span><br><span class="line">        <span class="comment">// bump是Unity自带的法线纹理</span></span><br><span class="line">        _NormalMap(<span class="string">"Normal Map"</span>, <span class="number">2</span>D) = <span class="string">"bump"</span> &#123;&#125;</span><br><span class="line">        <span class="comment">// 法线贴图的有效程度，用于控制凹凸程度</span></span><br><span class="line">        _BumpScale(<span class="string">"Bump Scale"</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射遮罩纹理</span></span><br><span class="line">        _SpecularMask(<span class="string">"Specular Mask"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光反射系数</span></span><br><span class="line">        _Specular(<span class="string">"Specular"</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 给Material面板暴露高光范围</span></span><br><span class="line">        _Gloss(<span class="string">"Gloss"</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定Pass用于Forward Rendering中的Light计算</span></span><br><span class="line">        Tags&#123; <span class="string">"LightMode"</span> = <span class="string">"ForwardBase"</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="preprocessor">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="preprocessor">#include "UnityCG.cginc"</span></span><br><span class="line">            <span class="preprocessor">#include "Lighting.cginc"</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;       <span class="comment">// 物体坐标系顶点位置</span></span><br><span class="line">                float3 normal : NORMAL;         <span class="comment">// 物体坐标系法线</span></span><br><span class="line">                float4 tangent : TANGENT;       <span class="comment">// 切线空间的顶点切线(用于计算切线空间的坐标系)</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">// 纹理位置信息(用于通过采样获取纹理的UV信息)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;       <span class="comment">// 投影坐标系顶点位置</span></span><br><span class="line">                float2 uv : TEXCOORD0;          <span class="comment">// 主纹理和法线纹理和遮罩纹理公用一个UV坐标信息</span></span><br><span class="line">                float4 ttow0 : TEXCOORD1;       <span class="comment">// 切线空间y轴转换到世界坐标系后的y轴</span></span><br><span class="line">                float4 ttow1 : TEXCOORD2;       <span class="comment">// 切线空间x轴转换到世界坐标系后的x轴</span></span><br><span class="line">                float4 ttow2 : TEXCOORD3;       <span class="comment">// 切线空间z轴转换到到世界坐标系后的z轴</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对应材质面板的纹理贴图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="comment">// 纹理材质的纹理属性(e.g. 纹理缩放值，偏移值)</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="comment">// 对应材质面板法线贴图</span></span><br><span class="line">            sampler2D _NormalMap;</span><br><span class="line">            <span class="comment">// 对应材质面板法线贴图有效程度参数</span></span><br><span class="line">            <span class="keyword">float</span> _BumpScale;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射遮罩纹理</span></span><br><span class="line">            sampler2D _SpecularMask;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光反射系数</span></span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="comment">// 对应材质面板的高光范围</span></span><br><span class="line">            <span class="keyword">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 通过tangent和normal值计算出将tangent转换到世界坐标系的矩阵(世界坐标系下的XYZ轴)</span></span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 公用的纹理UV信息</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">                float3 worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 世界坐标系下的normal(相当于y轴)</span></span><br><span class="line">                fixed3 worldnormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                <span class="comment">// 世界坐标系下的tangent(相当于x轴)</span></span><br><span class="line">                fixed3 worldtangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                <span class="comment">// 世界坐标系下的normal和tangent计算出binormal</span></span><br><span class="line">                <span class="comment">// 世界坐标系下的binormal(相当于z轴)</span></span><br><span class="line">                fixed3 worldbinormal = cross(worldnormal, worldtangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 填充从tangent space转换到world space的矩阵</span></span><br><span class="line">                <span class="comment">// 注意因为是列向量，所以注意填充方式</span></span><br><span class="line">                <span class="comment">// worldpos填充在w后续使用</span></span><br><span class="line">                o.ttow0 = float4(worldtangent.x, worldbinormal.x, worldnormal.x, worldpos.x);</span><br><span class="line">                o.ttow1 = float4(worldtangent.y, worldbinormal.y, worldnormal.y, worldpos.y);</span><br><span class="line">                o.ttow2 = float4(worldtangent.z, worldbinormal.z, worldnormal.z, worldpos.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="comment">// 世界坐标系顶点位置</span></span><br><span class="line">                fixed3 worldpos = float3(i.ttow0.w,i.ttow1.w,i.ttow2.w);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算世界坐标系的法线信息</span></span><br><span class="line">                <span class="comment">// bump为切线空间的法线信息</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_NormalMap, i.uv));</span><br><span class="line"></span><br><span class="line">                bump.xy *= _BumpScale;</span><br><span class="line">                bump.z = sqrt(<span class="number">1.0</span> - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将切线空间空间的法线信息转换到世界坐标系下</span></span><br><span class="line">                bump = normalize(half3(dot(i.ttow0.xyz, bump), dot(i.ttow1.xyz, bump), dot(i.ttow2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 利用转换到世界坐标系的法线信息，正式开始光照计算</span></span><br><span class="line">                <span class="comment">// 使用纹理贴图的颜色信息作为漫反射系数</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 漫反射</span></span><br><span class="line">                <span class="comment">// 顶点光线入射向量</span></span><br><span class="line">                fixed3 worldlightdir = normalize(UnityWorldSpaceLightDir(worldpos));</span><br><span class="line">                <span class="comment">// 得到世界坐标系的顶点法线和direction light方向后可以开始计算漫反射</span></span><br><span class="line">                <span class="comment">// _LightColor0代表全局唯一的direction light光照的颜色信息</span></span><br><span class="line">                <span class="comment">// 点乘世界坐标系的法线和光源方向得到漫反射辐射度</span></span><br><span class="line">                <span class="comment">// saturate防止负值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(bump, worldlightdir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 高光反射</span></span><br><span class="line">                <span class="comment">// 世界坐标系下的从顶点到观察点的观察方向v</span></span><br><span class="line">                fixed3 viewdir = normalize(UnityWorldSpaceViewDir(worldpos));</span><br><span class="line">                <span class="comment">// h = (v + l) / |v + l| v和l向量归一化后的向量</span></span><br><span class="line">                fixed3 halfdir = normalize(worldlightdir + viewdir);</span><br><span class="line">                <span class="comment">// 高光遮罩纹理采样信息(这里只是用了r红色通道信息作为mask)</span></span><br><span class="line">                <span class="keyword">fixed</span> specularmask = tex2D(_SpecularMask, i.uv).r;</span><br><span class="line">                <span class="comment">// 计算高光反射的颜色信息(高光遮罩纹理参与过滤)</span></span><br><span class="line">                <span class="comment">// c(specular) = (c(light) * m(specular)) * pow(max(0, dot(n,h)), m(gloss))</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(bump, halfdir)), _Gloss) * specularmask;</span><br><span class="line">                <span class="comment">// 将高光反射的颜色信息输出到最终的顶点颜色</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">"Specular"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/Unity/MaskTexture.PNG" alt="高光遮罩纹理"><br>可以看到我们利用遮罩纹理的R颜色信息作为高光的过滤依据，也就是说遮罩纹理里R信息为0的顶点将不会计算高光反射。</p>
<h2 id="透明效果">透明效果</h2><h1 id="Reference_Website">Reference Website</h1><p><a href="http://www.alanzucconi.com/2015/06/17/surface-shaders-in-unity3d/" target="_blank" rel="external">Surface shaders in Unity3D</a><br><a href="http://unity3d.com/cn/get-unity/download/
archive" target="_blank" rel="external">Unity Shader内置文件官网下载地址</a><br><a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html" target="_blank" rel="external">Shader semantics官网查询</a><br><a href="http://candycat1992.github.io/unity_shaders_book/unity_shaders_book_corrigenda.html" target="_blank" rel="external">Unity Shader入门精要勘误</a><br><a href="https://github.com/candycat1992/Unity_Shaders_Book" target="_blank" rel="external">Unity Shader入门级你要源代码</a><br><a href="https://en.wikipedia.org/wiki/Gouraud_shading" target="_blank" rel="external">Gouraud Shading</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Rendering/">Rendering</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2016/12/20/Unity-Shader/" data-title="Unity_Shader | 走停人生路" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/02/17/SublimeText3使用/" title="SublimeText3使用">
  <strong>上一篇：</strong><br/>
  <span>
  SublimeText3使用</span>
</a>
</div>


<div class="next">
<a href="/2016/12/11/Unity原生&第三方插件/"  title="Unity原生&amp;第三方插件">
 <strong>下一篇：</strong><br/> 
 <span>Unity原生&amp;第三方插件
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/12/20/Unity-Shader/" data-title="Unity_Shader" data-url="http://tonytang1990.github.io/2016/12/20/Unity-Shader/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Rendering"><span class="toc-number">1.</span> <span class="toc-text">Rendering</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity_Shader"><span class="toc-number">2.</span> <span class="toc-text">Unity Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Surface_Shaders"><span class="toc-number">2.1.</span> <span class="toc-text">Surface Shaders</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vertex_and_Fragment_Shaders"><span class="toc-number">2.2.</span> <span class="toc-text">Vertex and Fragment Shaders</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity_Shader入门精要"><span class="toc-number">3.</span> <span class="toc-text">Unity Shader入门精要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染管线"><span class="toc-number">3.1.</span> <span class="toc-text">渲染管线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity_Shader基础"><span class="toc-number">3.2.</span> <span class="toc-text">Unity Shader基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#材质和Unity_Shader"><span class="toc-number">3.2.1.</span> <span class="toc-text">材质和Unity Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ShaderLab"><span class="toc-number">3.2.2.</span> <span class="toc-text">ShaderLab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity_Shader结构"><span class="toc-number">3.2.3.</span> <span class="toc-text">Unity Shader结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学相关知识"><span class="toc-number">3.3.</span> <span class="toc-text">数学相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity_Shader学习之旅"><span class="toc-number">3.4.</span> <span class="toc-text">Unity Shader学习之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个最简单的顶点/片元着色器"><span class="toc-number">3.4.1.</span> <span class="toc-text">一个最简单的顶点/片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity内置文件和变量"><span class="toc-number">3.4.2.</span> <span class="toc-text">Unity内置文件和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CG/HLSL语义"><span class="toc-number">3.4.3.</span> <span class="toc-text">CG/HLSL语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader_Debugger"><span class="toc-number">3.4.4.</span> <span class="toc-text">Shader Debugger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Color_Info"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">Color Info</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity_Frame_Debugger"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">Unity Frame Debugger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VS_Graphics_Debugger"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">VS Graphics Debugger</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NVIDIA_NSight"><span class="toc-number">3.4.5.</span> <span class="toc-text">NVIDIA NSight</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity中的基础光照"><span class="toc-number">3.5.</span> <span class="toc-text">Unity中的基础光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#光照知识回顾"><span class="toc-number">3.5.1.</span> <span class="toc-text">光照知识回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准光照模型"><span class="toc-number">3.5.2.</span> <span class="toc-text">标准光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漫反射光照模型"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">漫反射光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#兰伯特光照模型"><span class="toc-number">3.5.2.1.1.</span> <span class="toc-text">兰伯特光照模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#半兰伯特(Half_Lambert)光照模型"><span class="toc-number">3.5.2.1.2.</span> <span class="toc-text">半兰伯特(Half Lambert)光照模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高光反射光照模型"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">高光反射光照模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lighting_in_Unity"><span class="toc-number">3.5.3.</span> <span class="toc-text">Lighting in Unity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Realtime_Lighting"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">Realtime Lighting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Precomputed_Lighting"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">Precomputed Lighting</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bake_Realtime_Lighting实战"><span class="toc-number">3.5.3.2.1.</span> <span class="toc-text">Bake Realtime Lighting实战</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Render_Path"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">Render Path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Color_Space"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">Color Space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#High_Dynamic_Range"><span class="toc-number">3.5.4.</span> <span class="toc-text">High Dynamic Range</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础纹理"><span class="toc-number">3.6.</span> <span class="toc-text">基础纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理类型分类"><span class="toc-number">3.6.1.</span> <span class="toc-text">纹理类型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Delfaut(Advanced)"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">Delfaut(Advanced)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal_Map"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">Normal Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sprite"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">Sprite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lightmap"><span class="toc-number">3.6.1.4.</span> <span class="toc-text">Lightmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理大小"><span class="toc-number">3.6.2.</span> <span class="toc-text">纹理大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片格式"><span class="toc-number">3.6.3.</span> <span class="toc-text">图片格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理压缩方式"><span class="toc-number">3.6.4.</span> <span class="toc-text">纹理压缩方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity纹理使用"><span class="toc-number">3.6.5.</span> <span class="toc-text">Unity纹理使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#纹理的基础使用"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">纹理的基础使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mipmap"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">Mipmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#凹凸映射"><span class="toc-number">3.6.5.3.</span> <span class="toc-text">凹凸映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Height_Map"><span class="toc-number">3.6.5.3.1.</span> <span class="toc-text">Height Map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Normal_Mapping"><span class="toc-number">3.6.5.3.2.</span> <span class="toc-text">Normal Mapping</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ramp_Texture(渐变纹理)"><span class="toc-number">3.6.5.3.3.</span> <span class="toc-text">Ramp Texture(渐变纹理)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mask_Texture(遮罩纹理)"><span class="toc-number">3.6.5.3.4.</span> <span class="toc-text">Mask Texture(遮罩纹理)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#透明效果"><span class="toc-number">3.7.</span> <span class="toc-text">透明效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference_Website"><span class="toc-number">4.</span> <span class="toc-text">Reference Website</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Automation/" title="Automation">Automation<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Editor/" title="Editor">Editor<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game-Engine/" title="Game_Engine">Game_Engine<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Resource/" title="Resource">Resource<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Editor/" title="Editor">Editor<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Optimization/" title="Optimization">Optimization<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HotUpdate/" title="HotUpdate">HotUpdate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sort/" title="Sort">Sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GameDesignPattern/" title="GameDesignPattern">GameDesignPattern<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Art/" title="Art">Art<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Network/" title="Network">Network<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Prefab/" title="Prefab">Prefab<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Rendering/" title="Rendering">Rendering<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/VersionControl/" title="VersionControl">VersionControl<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shader/" title="Shader">Shader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Tony Tang. <br/>
			This is my new blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"TonyTang1990"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
