
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>异步编程 | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="前言游戏开发过程中为了无论资源加载异步还是逻辑异步，异步都是不可或缺的一部分。本章节是为了深入理解C#的异步编程以及Unity里异步编程使用而编写。 异步编程Unity里最初的模拟异步编程概念的当之无愧是携程，但携程实际上是单线程通过每帧等待实现异步模拟运行的而非真正的异步编程。 异步编程的过程中我们往往会采用回调式的方式来编写代码，这回导致回调地狱，导致代码理解起来比较困难，有了Task异步编程">
<meta property="og:type" content="article">
<meta property="og:title" content="异步编程">
<meta property="og:url" content="http://tonytang1990.github.io/2022/10/12/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="前言游戏开发过程中为了无论资源加载异步还是逻辑异步，异步都是不可或缺的一部分。本章节是为了深入理解C#的异步编程以及Unity里异步编程使用而编写。 异步编程Unity里最初的模拟异步编程概念的当之无愧是携程，但携程实际上是单线程通过每帧等待实现异步模拟运行的而非真正的异步编程。 异步编程的过程中我们往往会采用回调式的方式来编写代码，这回导致回调地狱，导致代码理解起来比较困难，有了Task异步编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Async/TaskBasicUsing.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/CSharp/Async/AwaitTaskUsing.PNG">
<meta property="article:published_time" content="2022-10-12T02:43:00.000Z">
<meta property="article:modified_time" content="2025-12-22T03:53:03.000Z">
<meta property="article:author" content="Tony Tang">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tonytang1990.github.io/img/CSharp/Async/TaskBasicUsing.PNG">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">做着独立游戏梦，坚持走在游戏开发道路上的人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/10/12/异步编程/" title="异步编程" itemprop="url">异步编程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2022-10-12T02:43:00.000Z" itemprop="datePublished"> 发表于 2022-10-12</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Task-based-Asynchronous-Pattern-TAP"><span class="toc-number">2.1.</span> <span class="toc-text">Task-based Asynchronous Pattern(TAP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task"><span class="toc-number">2.3.</span> <span class="toc-text">Task</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">Task基础使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E4%BD%BF%E7%94%A8Async%E5%92%8CAwait%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E7%AD%89%E5%BE%85"><span class="toc-number">2.3.2.</span> <span class="toc-text">Task使用Async和Await实现异步方法定义和等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E5%BC%82%E6%AD%A5%E5%8F%96%E6%B6%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">Task异步取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.4.</span> <span class="toc-text">Task总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-AsyncTaskMethodBuilder"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">深入理解 AsyncTaskMethodBuilder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">异步方法的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C"><span class="toc-number">2.3.5.</span> <span class="toc-text">使用体验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Task"><span class="toc-number">2.4.</span> <span class="toc-text">自定义Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-UniTask"><span class="toc-number">2.5.</span> <span class="toc-text">进阶(UniTask)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">重点知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Github"><span class="toc-number">5.</span> <span class="toc-text">Github</span></a></li></ol>
		
		</div>
		
		<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏开发过程中为了无论资源加载异步还是逻辑异步，异步都是不可或缺的一部分。本章节是为了深入理解C#的异步编程以及Unity里异步编程使用而编写。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>Unity里最初的模拟异步编程概念的当之无愧是携程，但携程实际上是单线程通过每帧等待实现异步模拟运行的而非真正的异步编程。</p>
<p>异步编程的过程中我们往往会采用回调式的方式来编写代码，这回导致回调地狱，导致代码理解起来比较困难，有了Task异步编程我们可以实现类似同步式的代码编写来编写异步代码。</p>
<p>而本章节的重点是真正深入了解异步编程，C#里的最新的异步编程主要是通过Task</p>
<h3 id="Task-based-Asynchronous-Pattern-TAP"><a href="#Task-based-Asynchronous-Pattern-TAP" class="headerlink" title="Task-based Asynchronous Pattern(TAP)"></a>Task-based Asynchronous Pattern(TAP)</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/async">The core of async programming is the <code>Task</code> and <code>Task</code> objects, which model asynchronous operations. They are supported by the <code>async</code> and <code>await</code> keywords. </a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">TAP uses a single method to represent the initiation and completion of an asynchronous operation. </a></p>
<p>从上面的介绍可以看出异步编程的核心是Task实现了异步操作，并且支持async和await关键词，其次<strong>TAP</strong>通过方法定义就完成了所有的异步操作初始化和方法定义。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>await can only be used inside an async method.(await只能用在async标记的方法内)</strong></li>
<li><strong>async methods need to have an await keyword in their body or they will never yield!(async标记的方法需要一个await关键词在方法定义内，不然这个异步方法不会暂停会同步执行)</strong></li>
</ol>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-7.0">The Task class represents a single operation that does not return a value and that usually executes asynchronously. Task objects are one of the central components of the task-based asynchronous pattern first introduced in the .NET Framework 4. Because the work performed by a Task object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the Status property, as well as the IsCanceled, IsCompleted, and IsFaulted properties, to determine the state of a task. </a></p>
<p>从介绍可以看出，异步编程主要是通过Task类的抽象，而Task的异步编程底层伴随着线程池，我们使用的人可以不用关心底层线程池的优化调度问题。通过Task抽象异步编程，Task可以返回异步运行状态IsCanceled,IsCompleted,IsFaulted等来查看异步运行状态。</p>
<p>通过实战使用，了解下Task的基础使用以及底层跨线程的设计:</p>
<h4 id="Task基础使用"><a href="#Task基础使用" class="headerlink" title="Task基础使用"></a>Task基础使用</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 响应基础Task使用按钮点击</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBtnBasicTaskUsingClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个Task1但不开始</span></span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(mTaskActionDelegate, <span class="string">&quot;Task1&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过Task工厂创建一个Task2并等待完成</span></span><br><span class="line">    Task task2 = Task.Factory.StartNew(mTaskActionDelegate, <span class="string">&quot;Task2&quot;</span>);</span><br><span class="line">    task2.Wait();</span><br><span class="line">    <span class="comment">// Task1开始</span></span><br><span class="line">    task1.Start();</span><br><span class="line">    Debug.Log(<span class="string">$&quot;Task1 has been launched. Main Thread:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="comment">// 等待Task1完成</span></span><br><span class="line">    task1.Wait();</span><br><span class="line">    <span class="comment">// 通过Task.Run创建Task3并等待完成</span></span><br><span class="line">    Task task3 = Task.Run(()=&gt;</span><br><span class="line">                          &#123;</span><br><span class="line">                              Debug.Log(<span class="string">$&quot;ActionName:Task3&quot;</span>);</span><br><span class="line">                              Debug.Log(<span class="string">$&quot;Task:<span class="subst">&#123;Task.CurrentId&#125;</span> Thread:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">                          &#125;);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;Task3 has been launched. Main Thread:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">    task3.Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Task使用方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;actionName&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TaskAction</span>(<span class="params"><span class="built_in">object</span> actionName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;ActionName:<span class="subst">&#123;actionName&#125;</span>&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;Task:<span class="subst">&#123;Task.CurrentId&#125;</span> Thread:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CSharp/Async/TaskBasicUsing.PNG" alt="TaskBasicUsing"></p>
<p>从上面的Task尝试可以看出，Task是在不同线程开启的，其次Task如果是单独的New是不会自动开始的，Task.Run和Task.Factory.StartNew才会直接开始一个Task。</p>
<h4 id="Task使用Async和Await实现异步方法定义和等待"><a href="#Task使用Async和Await实现异步方法定义和等待" class="headerlink" title="Task使用Async和Await实现异步方法定义和等待"></a>Task使用Async和Await实现异步方法定义和等待</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 响应Task等待按钮点击 </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnBtnAwaitTaskUsingClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> awaitTask = Task.Run(AwaitTaskAction);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitTaskAction has been launched. Main Thread:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> sumResult = <span class="keyword">await</span> awaitTask;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;sumResult:<span class="subst">&#123;sumResult&#125;</span>&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 等待的Task方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AwaitTaskAction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitTaskAction Start&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitTaskAction After Task.Delay(1)&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitTaskAction End&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/CSharp/Async/AwaitTaskUsing.PNG" alt="AwaitTaskUsing"></p>
<p>通过Async关键词，我把OnBtnAwaitTaskUsingClick和AwaitTaskAction方法都定义成了异步方法(既可以通过Task异步调用的方法)。然后结合Await关键词实现了等待异步方法AwaitTaskAction执行完后返回运算结果并打印的效果，可以看到这样一来我们的异步代码编写结合Await关键词就跟同步代码一般是一个线性流程，同时异步方法内通过Task.Delay等类似携程的等待方法实现指定时间指定条件的等待。</p>
<p>那么Async和Await关键词是如何实现异步等待效果的了，让我们结合反编译看一下底层实现:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AsyncStateMachine(typeof (GameLauncher.&lt;OnBtnAwaitTaskUsingClick&gt;d__9))</span>]</span><br><span class="line">[<span class="meta">DebuggerStepThrough</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBtnAwaitTaskUsingClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GameLauncher.&lt;OnBtnAwaitTaskUsingClick&gt;d__9 stateMachine = <span class="keyword">new</span> GameLauncher.&lt;OnBtnAwaitTaskUsingClick&gt;d__9();</span><br><span class="line">    stateMachine.&lt;&gt;<span class="number">4</span>__this = <span class="keyword">this</span>;</span><br><span class="line">    stateMachine.&lt;&gt;t__builder = AsyncVoidMethodBuilder.Create();</span><br><span class="line">    stateMachine.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">    stateMachine.&lt;&gt;t__builder.Start&lt;GameLauncher.&lt;OnBtnAwaitTaskUsingClick&gt;d__9&gt;(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">AsyncStateMachine(typeof (GameLauncher.&lt;AwaitTaskAction&gt;d__10))</span>]</span><br><span class="line">[<span class="meta">DebuggerStepThrough</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AwaitTaskAction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GameLauncher.&lt;AwaitTaskAction&gt;d__10 stateMachine = <span class="keyword">new</span> GameLauncher.&lt;AwaitTaskAction&gt;d__10();</span><br><span class="line">    stateMachine.&lt;&gt;<span class="number">4</span>__this = <span class="keyword">this</span>;</span><br><span class="line">    stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder&lt;<span class="built_in">int</span>&gt;.Create();</span><br><span class="line">    stateMachine.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">    stateMachine.&lt;&gt;t__builder.Start&lt;GameLauncher.&lt;AwaitTaskAction&gt;d__10&gt;(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">    <span class="keyword">return</span> stateMachine.&lt;&gt;t__builder.Task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">OnBtnAwaitTaskUsingClick</span>&gt;<span class="title">d__9</span> : <span class="title">IAsyncStateMachine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">    <span class="keyword">public</span> AsyncVoidMethodBuilder &lt;&gt;t__builder;</span><br><span class="line">    <span class="keyword">public</span> GameLauncher &lt;&gt;<span class="number">4</span>__this;</span><br><span class="line">    <span class="keyword">private</span> Task&lt;<span class="built_in">int</span>&gt; &lt;awaitTask&gt;<span class="number">5</span>__1;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;sumResult&gt;<span class="number">5</span>__2;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;s__3;</span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter&lt;<span class="built_in">int</span>&gt; &lt;&gt;u__1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;OnBtnAwaitTaskUsingClick&gt;d__9()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>..Ector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num1 = <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskAwaiter&lt;<span class="built_in">int</span>&gt; awaiter;</span><br><span class="line">            <span class="built_in">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (num1 != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.&lt;awaitTask&gt;<span class="number">5</span>__1 = Task.Run&lt;<span class="built_in">int</span>&gt;(<span class="keyword">new</span> Func&lt;Task&lt;<span class="built_in">int</span>&gt;&gt;((<span class="built_in">object</span>) <span class="keyword">this</span>.&lt;&gt;<span class="number">4</span>__this, __methodptr(AwaitTaskAction)));</span><br><span class="line">                Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;AwaitTaskAction has been launched. Main Thread:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">                awaiter = <span class="keyword">this</span>.&lt;awaitTask&gt;<span class="number">5</span>__1.GetAwaiter();</span><br><span class="line">                <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = num2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;u__1 = awaiter;</span><br><span class="line">                    GameLauncher.&lt;OnBtnAwaitTaskUsingClick&gt;d__9 stateMachine = <span class="keyword">this</span>;</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;t__builder.AwaitUnsafeOnCompleted&lt;TaskAwaiter&lt;<span class="built_in">int</span>&gt;, GameLauncher.&lt;OnBtnAwaitTaskUsingClick&gt;d__9&gt;(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> stateMachine);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                awaiter = <span class="keyword">this</span>.&lt;&gt;u__1;</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;u__1 = <span class="keyword">new</span> TaskAwaiter&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = num2 = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;s__3 = awaiter.GetResult();</span><br><span class="line">            <span class="keyword">this</span>.&lt;sumResult&gt;<span class="number">5</span>__2 = <span class="keyword">this</span>.&lt;&gt;s__3;</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;sumResult:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) <span class="keyword">this</span>.&lt;sumResult&gt;<span class="number">5</span>__2));</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;DateTime.Now.Millisecond:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) DateTime.Now.Millisecond));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">this</span>.&lt;awaitTask&gt;<span class="number">5</span>__1 = (Task&lt;<span class="built_in">int</span>&gt;) <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;t__builder.SetException(ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">this</span>.&lt;awaitTask&gt;<span class="number">5</span>__1 = (Task&lt;<span class="built_in">int</span>&gt;) <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.&lt;&gt;t__builder.SetResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">AwaitTaskAction</span>&gt;<span class="title">d__10</span> : <span class="title">IAsyncStateMachine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">    <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="built_in">int</span>&gt; &lt;&gt;t__builder;</span><br><span class="line">    <span class="keyword">public</span> GameLauncher &lt;&gt;<span class="number">4</span>__this;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;sum&gt;<span class="number">5</span>__1;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;i&gt;<span class="number">5</span>__2;</span><br><span class="line">    <span class="keyword">private</span> TaskAwaiter &lt;&gt;u__1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;AwaitTaskAction&gt;d__10()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>..Ector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num1 = <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">        <span class="built_in">int</span> sum51;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskAwaiter awaiter1;</span><br><span class="line">            <span class="built_in">int</span> num2;</span><br><span class="line">            TaskAwaiter awaiter2;</span><br><span class="line">            <span class="keyword">if</span> (num1 != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (num1 != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.Log((<span class="built_in">object</span>) <span class="string">&quot;AwaitTaskAction Start&quot;</span>);</span><br><span class="line">                    Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;DateTime.Now.Millisecond:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) DateTime.Now.Millisecond));</span><br><span class="line">                    awaiter1 = Task.Delay(<span class="number">1000</span>).GetAwaiter();</span><br><span class="line">                    <span class="keyword">if</span> (!awaiter1.IsCompleted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = num2 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;u__1 = awaiter1;</span><br><span class="line">                        GameLauncher.&lt;AwaitTaskAction&gt;d__10 stateMachine = <span class="keyword">this</span>;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;t__builder.AwaitUnsafeOnCompleted&lt;TaskAwaiter, GameLauncher.&lt;AwaitTaskAction&gt;d__10&gt;(<span class="keyword">ref</span> awaiter1, <span class="keyword">ref</span> stateMachine);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter2 = <span class="keyword">this</span>.&lt;&gt;u__1;</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;u__1 = <span class="keyword">new</span> TaskAwaiter();</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = num2 = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">goto</span> label_12;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                awaiter1 = <span class="keyword">this</span>.&lt;&gt;u__1;</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;u__1 = <span class="keyword">new</span> TaskAwaiter();</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = num2 = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            awaiter1.GetResult();</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="string">&quot;AwaitTaskAction After Task.Delay(1)&quot;</span>);</span><br><span class="line">            DateTime now = DateTime.Now;</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;DateTime.Now.Millisecond:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) now.Millisecond));</span><br><span class="line">            <span class="keyword">this</span>.&lt;sum&gt;<span class="number">5</span>__1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__2 = <span class="number">0</span>; <span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__2 &lt; <span class="number">1000000000</span>; ++<span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__2)</span><br><span class="line">                ++<span class="keyword">this</span>.&lt;sum&gt;<span class="number">5</span>__1;</span><br><span class="line">            awaiter2 = Task.Delay(<span class="number">2000</span>).GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (!awaiter2.IsCompleted)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = num2 = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;u__1 = awaiter2;</span><br><span class="line">                GameLauncher.&lt;AwaitTaskAction&gt;d__10 stateMachine = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;t__builder.AwaitUnsafeOnCompleted&lt;TaskAwaiter, GameLauncher.&lt;AwaitTaskAction&gt;d__10&gt;(<span class="keyword">ref</span> awaiter2, <span class="keyword">ref</span> stateMachine);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            label_12:</span><br><span class="line">            awaiter2.GetResult();</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="string">&quot;AwaitTaskAction After Task.Delay(2)&quot;</span>);</span><br><span class="line">            now = DateTime.Now;</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;DateTime.Now.Millisecond:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) now.Millisecond));</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="string">&quot;AwaitTaskAction End&quot;</span>);</span><br><span class="line">            now = DateTime.Now;</span><br><span class="line">            Debug.Log((<span class="built_in">object</span>) <span class="built_in">string</span>.Format(<span class="string">&quot;DateTime.Now.Millisecond:&#123;0&#125;&quot;</span>, (<span class="built_in">object</span>) now.Millisecond));</span><br><span class="line">            sum51 = <span class="keyword">this</span>.&lt;sum&gt;<span class="number">5</span>__1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;t__builder.SetException(ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">this</span>.&lt;&gt;t__builder.SetResult(sum51);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">    <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面的代码是通过dotPeek(NetReflector也可以是付费软件，使用结束后就用不了了)才反编译出来的，之前试过ILSpy和DnSpy都得不到<OnBtnAwaitTaskUsingClick>d__9类定义相关反编译代码。</strong></p>
<p>通过上面的代码可以看到，<strong>通过async定义异步方法后，编译器帮我们生成了继承至IAsyncStateMachine的<OnBtnAwaitTaskUsingClick>d__9和<AwaitTaskAction>d__10类，这个两个类正是实现异步的一个关键抽象(个人理解有点像携程里的迭代器封装逻辑代码调用)。</strong></p>
<ul>
<li>触发OnBtnAwaitTaskUsingClick()方法调用</li>
<li>构建<OnBtnAwaitTaskUsingClick>d__9类实例对象状态机，初始化&lt;&gt;t_builder()(AsyncVoidMethodBuilder类型–异步任务构建器，用于保存异步任务结果相关)，这里因为OnBtnAwaitTaskUsingClick是void返回类型，所以构建的是AsyncVoieMethodBuilder类对象。<strong>初始化状态机&lt;&gt;1__state值为-1</strong></li>
<li>调用stateMachine.&lt;&gt;t__builder.Start&lt;GameLauncher.<OnBtnAwaitTaskUsingClick>d__9&gt;(ref stateMachine)触发状态机的MoveNext()的代码执行。</li>
<li>因为&lt;&gt;1__state状态值为-1，所以执行构建<awaitTask>5__1(Task<int>类型)的异步AwaitTaskAction执行(<strong>默认Task.Run走线程池，所以会运行在不同线程</strong>)</li>
<li>这一步AwaitTaskAction异步代码就开始执行了，首先构建<AwaitTaskAction>d__10类实例对象状态机，初始化&lt;&gt;t__builder(<strong>AsyncTaskMethodBuilder<int>类型–异步任务构造器，用于保存异步任务结果相关</strong>)，这里是因为AwaitTaskAction是Task<int>返回类型，所以构建的是AsyncTaskMethodBuilder<int>类型对象。<strong>初始化状态机&lt;&gt;1__state值为-1</strong></li>
<li>调用stateMachine.&lt;&gt;t__builder.Start&lt;GameLauncher.<AwaitTaskAction>d__10&gt;(ref stateMachine)触发状态机的MoveNext()的代码执行，然后通过<AwaitTaskAction>d__10.&lt;&gt;t__builder.Task返回AwaitTaskAction的异步任务对象</li>
<li>因为&lt;&gt;1___state状态值为-1，所以首先执行**”AwaitTaskAction Start”**打印，然后获取延迟1秒Task.Delay(1).GetAwaiter()的异步等待完成对象awaiter1</li>
<li><strong>因为Task.Run默认走线程池，所以这里可能回到主线程执行</strong>，触发**”AwaitTaskAction has been launched. Main Thread:{Thread.CurrentThread.ManagedThreadId}”**的打印</li>
<li>接着<awaitTask>5__1.GetAwaiter()获取AwaitTaskAction的异步等待完成对象(<strong>TaskAwaiter<int>类型继承至ICriticalNotifyCompletion</strong>)，<awaitTask>5__1.IsCompleted判定异步没有完成，将&lt;&gt;1__state状态机值设置成0,并保存<awaitTask>5__1(AwaitTaskAction的异步任务)到&lt;&gt;u__1</li>
<li>然后调用<OnBtnAwaitTaskUsingClick>d__9.&lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref statemachine)触发等待AwaitTaskAction等待异步任务完成(<strong>异步任务完成后会自动触发状态机的MoveNext()触发状态机继续执行</strong>)</li>
<li>主线程<OnBtnAwaitTaskUsingClick>d__9状态机在等待AwaitTaskAction异步任务完成，所以Task.Run在另一个线程运行的<AwaitTaskAction>d__10状态机又得到机会运行</li>
<li><AwaitTaskAction>d__10.awaiter1.IsCompleted判定异步没有完成，<strong>状态机&lt;&gt;1__state值设置为0</strong>，<AwaitTaskAction>d__10的异步等待完成对象&lt;&gt;u__1设置成awaiter1(即Task.Delay(1)的异步任务等待完成对象)，然后调用&lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter1, ref statemachine)触发等待一秒等待异步任务完成(<strong>异步任务完成后会自动触发状态机的MoveNext()触发状态机继续执行</strong>)</li>
<li>等待一秒过后，Task.Delay(1)异步任务完成，触发__<AwaitTaskAction>d__10状态机的MoveNext执行，此时状态机&lt;&gt;1__state值为0，将Task.Delay(1).GetAwaiter()对象保存到awaiter1，&lt;&gt;u__1构建一个新的TaskAwaiter()对象，<strong>&lt;&gt;1__state状态机值设置成-1</strong>，然后调用awaiter1.GetResult()结束异步任务完成等待(因为是Task.Delay(1)所以没有结果需要保存)，此时打印**”AwaitTaskAction After Task.Delay(1)**</li>
<li>然后开始计算for循环累加的代码，初始化<sum>5__1为0，执行<sum>5__1的循环累加</li>
<li>累加执行完成后执行Task.Delay(2)，此时保存Task.Delay(2).GetAwaiter()的异步等待完成对象到awaiter2，awaiter2.IsCompleted判定异步没有完成，将&lt;&gt;1__state状态机值设置成1,并保存Task.Delay(2).GetAwaiter()到&lt;&gt;u__1，然后调用&lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter2, ref statemachine)触发等待两秒等待异步任务完成(<strong>异步任务完成后会自动触发状态机的MoveNext()触发状态机继续执行</strong>)</li>
<li>等待两秒过后，Task.Delay(2)异步任务完成，触发__<AwaitTaskAction>d__10状态机的MoveNext执行，此时状态机&lt;&gt;1__state值为1，执行awaiter2保存&lt;&gt;u__1(Task.Delay(2).GetAwaiter()的异步任务等待完成对象)，同时构建一个新的TaskAwaiter()赋值给&lt;&gt;u__1，并设置**&lt;&gt;1__stat状态机值到-1**</li>
<li>然后直接跳转到代码label_12标签片段，此时Task.Delay(2)异步任务已经完成，调用awaiter.GetResult()直接触发异步任务完成等待</li>
<li>紧接着打印**”AwaitTaskAction After Task.Delay(2)”<strong>并将累加结果<sum>5__1保存到sum51成员变量，然后将状态机</strong>&lt;&gt;1__state值设置成-2**同时将累加结果sum51通过&lt;&gt;t__builder(**AsyncTaskMethodBuilder<int>类型)调用SetResult(sum51)将AwaitTaskAction()方法调用的返回结果设置到异步任务构建器里</li>
<li>上面一套流程下来，AwaitTaskAction的异步代码就算是执行完成了(即<OnBtnAwaitTaskUsingClick>d__9状态机里Task.Run<int>(new Func&lt;Task<int>&gt;((object) this.&lt;&gt;4__this, __methodptr(AwaitTaskAction)))的异步方法执行完成了)，<OnBtnAwaitTaskUsingClick>d__9.&lt;&gt;t__builder.AwaitUnsafeOnCompleted()监听到异步任务完成，触发<OnBtnAwaitTaskUsingClick>d__9的MoveNext()执行</li>
<li>此时<OnBtnAwaitTaskUsingClick>d__9.&lt;&gt;1__state状态机值为0，执行awaiter保存&lt;&gt;u__1(AwaitTaskAction的异步任务等待完成对象)，新创建一个TaskAwaiter<int>异步任务等待完成对象并设置给&lt;&gt;u__1，同时&lt;&gt;1__state状态机值设置成-1</li>
<li>调用awaiter.GetResult()获取AwaitTaskAction异步任务结果并存储到<OnBtnAwaitTaskUsingClick>d__9.&lt;&gt;s__3和<OnBtnAwaitTaskUsingClick>d__9.<sumResult>5__2</li>
<li>打印**”sumResult:{sumResult}”**，将&lt;&gt;1__state状态机值设置成-2，<awaitTask>5__1存储的AwaitTaskAction异步任务置空</li>
<li>最后通过<OnBtnAwaitTaskUsingClick>d__9.&lt;&gt;t__builder:SetResult()标记OnBtnAwaitTaskUsingClick的异步任务完成和设置结果(<strong>因为OnBtnAwaitTaskUsingClick是void返回所以无需设置结果值</strong>)</li>
</ul>
<p>就这样我们所有的异步线性流程都通过代码生成状态机运行的方式，变成了一个一个的状态按顺序执行。</p>
<p>可以看到异步线性流程和核心由两部分组成:</p>
<ol>
<li><strong>Task异步运行机制</strong></li>
<li><strong>异步状态机代码生成</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/async">On the C# side of things, the compiler transforms your code into a state machine that keeps track of things like yielding execution when an <code>await</code> is reached and resuming execution when a background job has finished.</a></p>
<h4 id="Task异步取消"><a href="#Task异步取消" class="headerlink" title="Task异步取消"></a>Task异步取消</h4><p>Task异步的取消是通过<strong>Cancellation Token</strong>来完成的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 响应开启等待取消Task按钮点击</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OnBtnWaitCancelTaskUsingClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mTaskCancelTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    <span class="keyword">var</span> taskToken = mTaskCancelTokenSource.Token;</span><br><span class="line">    <span class="keyword">var</span> awaitTask = Task.Run(() =&gt;</span><br><span class="line">                             &#123;</span><br><span class="line">                                 <span class="keyword">return</span> AwaitCancelTaskAction(taskToken);</span><br><span class="line">                             &#125;, taskToken);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction has been launched. Main Thread:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sumResult = <span class="keyword">await</span> awaitTask;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction sumResult:<span class="subst">&#123;sumResult&#125;</span>&quot;</span>);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (OperationCanceledException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(e);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;e.CancelLlationToken.Equals(taskCancelToken):<span class="subst">&#123;e.CancellationToken.Equals(taskToken&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        mTaskCancelTokenSource.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 等待取消的Task方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;taskToken&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AwaitCancelTaskAction</span>(<span class="params">CancellationToken taskToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检测异步Task是否已经取消</span></span><br><span class="line">    taskToken.ThrowIfCancellationRequested();</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction Start&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>  Thread Id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 检测异步Task是否已经取消</span></span><br><span class="line">    taskToken.ThrowIfCancellationRequested();</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction After Task.Delay(1)&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 检测异步Task是否已经取消</span></span><br><span class="line">    taskToken.ThrowIfCancellationRequested();</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction After Task.Delay(2)&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;DateTime.Now.Millisecond:<span class="subst">&#123;DateTime.Now.Millisecond&#125;</span>&quot;</span>);</span><br><span class="line">    Debug.Log(<span class="string">$&quot;AwaitCancelTaskAction End&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 响应Task取消按钮点击</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBtnCancelTaskUsingClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mTaskCancelTokenSource?.Cancel();</span><br><span class="line">    Debug.Log(<span class="string">$&quot;取消异步Task&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看到，我们在开启一个需要支持取消的异步Task时需要以下步骤:</p>
<ol>
<li><strong>申请创建了一个CancellationTokenSource对象</strong>，这个对象会包含我们异步Task取消所需的token。</li>
<li><strong>将CancellationTokenSource.token传递给需要异步执行的Task(多层调用要一直传递下去，确保Task正确异步取消</strong>)</li>
<li><strong>在需要异步打断的Task里判定token是否已经取消(token.ThrowIfCancellationRequested())</strong></li>
<li><strong>try catch异步await，确保释放token source(CancellationTokenSource.Dispose())</strong></li>
</ol>
<p>在上面的使用中可以看到，<strong>Task异步是多线程</strong>的，通过Task.Run()我们启用了一个新的线程执行任务，所以打印出的Thread Id和Main Thread Id不一样。</p>
<p>为了确保Task取消后异步逻辑能正确停止，我们在异步逻辑里关键地方都在判定taskToken.ThrowIfCancellationRequested()通知Task进入取消状态。</p>
<h4 id="Task总结"><a href="#Task总结" class="headerlink" title="Task总结"></a>Task总结</h4><p>以下总结来源:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Bob-luo/p/18518463">深入解析C#异步编程：await 关键字背后的实现原理 </a></p>
<h5 id="深入理解-AsyncTaskMethodBuilder"><a href="#深入理解-AsyncTaskMethodBuilder" class="headerlink" title="深入理解 AsyncTaskMethodBuilder"></a>深入理解 AsyncTaskMethodBuilder</h5><p><code>AsyncTaskMethodBuilder</code> 是一个辅助类，用于构建和管理异步方法的任务。它提供了以下方法：</p>
<ul>
<li><code>Create</code>：创建一个新的 <code>AsyncTaskMethodBuilder</code> 实例。</li>
<li><code>Start</code>：开始执行异步方法，调用状态机的 <code>MoveNext</code> 方法。</li>
<li><code>AwaitUnsafeOnCompleted</code>：注册回调函数，当任务完成时触发回调。</li>
<li><code>SetResult</code>：设置任务的结果。</li>
<li><code>SetException</code>：设置任务的异常。</li>
</ul>
<h5 id="异步方法的生命周期"><a href="#异步方法的生命周期" class="headerlink" title="异步方法的生命周期"></a>异步方法的生命周期</h5><ol>
<li><strong>初始化</strong>：创建状态机实例，初始化状态和任务构建器。</li>
<li><strong>开始执行</strong>：调用 <code>Start</code> 方法开始执行异步方法。</li>
<li><strong>执行方法体</strong>：在 <code>MoveNext</code> 方法中，根据当前状态执行相应的代码。</li>
<li><strong>遇到 <code>await</code></strong>：检查任务是否完成，如果未完成则注册回调并暂停方法执行。</li>
<li><strong>任务完成</strong>：回调被触发，重新调用 <code>MoveNext</code> 方法，恢复异步方法的执行。</li>
<li><strong>方法完成</strong>：所有异步操作完成，设置任务的结果或异常。</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li><strong>异步方法的基本概念</strong>：<code>async</code> 和 <code>await</code> 关键字用于编写异步代码。</li>
<li><strong>状态机的生成</strong>：编译器为每个异步方法生成一个状态机，包含所有局部变量和状态信息。</li>
<li><strong><code>MoveNext</code> 方法的执行</strong>：<code>MoveNext</code> 方法是状态机的核心，负责管理和执行异步操作。</li>
<li>回调函数的注册和触发：<ul>
<li>当遇到 <code>await</code> 关键字时，编译器会生成代码来检查任务是否已经完成。</li>
<li>如果任务未完成，注册回调并暂停方法执行。</li>
<li>当任务完成时，回调函数会被触发，重新调用状态机的 <code>MoveNext</code> 方法，从而恢复异步方法的执行。</li>
</ul>
</li>
<li><strong><code>AwaitUnsafeOnCompleted</code> 方法的作用</strong>：在任务完成时注册一个回调函数，回调函数会在任务完成后被触发，从而恢复异步方法的执行。</li>
</ol>
<h4 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h4><p>通过上面的学习使用，这里个人讲讲个人Task的使用心得。</p>
<p>好处:</p>
<ol>
<li>通过Task异步我们能将<strong>异步逻辑跟同步逻辑一样方便的线性流程编写</strong>，不再需要编写回调嵌套(<strong>回调地狱</strong>)的代码。</li>
</ol>
<p>不方便处:</p>
<ol>
<li>Task异步需要定义async关键字，导致所有异步方法都需要加上async关键字(<strong>async传染</strong>)</li>
<li>Task异步取消时，使用者在异步逻辑里需要关心 taskToken是否已经取消(<strong>taskToken.ThrowIfCancellationRequested()</strong>)，这样代码写起来还是比较麻烦</li>
<li>开启一个异步Task需要通过Task.Run或者Task.Factory.StartNew方法，这样导致我们<strong>嵌套调用异步方法传递token时被迫用上闭包这种方式</strong></li>
<li><strong>Task异步是多线程，需要考虑数据多线程访问问题，对开发者多线程相关知识要求更高</strong></li>
</ol>
<h3 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h3><p>通过上面的学习我们了解了Task和async，await关键词是如何组合起来实现异步等待的。但Task默认相关都是带线程池的，如果我们想实现一个单线程的异步Task(好比UniTask)应该如何实现了？</p>
<p>核心需求如下:</p>
<ol>
<li><strong>支持async和await的自定义Task</strong></li>
<li><strong>类似UniTask的单线程Task</strong></li>
<li><strong>支持常规的单帧等待，指定时长等待Task</strong></li>
<li><strong>支持Unity不同Update模式的更新驱动选择</strong></li>
<li><strong>支持异步任务取消</strong></li>
<li><strong>支持带返回T类型数据和void返回类型的异步任务</strong></li>
</ol>
<p>以下实现思路参考来源:</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/12674069664">每个人都能写UniTask!!!自定义一个TaskLike并完成一个简单的Delay延时教程</a></p>
<p>在开始实现自定义Task之前，我们首先先设计好类图，明确各个类的功能。</p>
<ol>
<li><p><strong>CustomVoidTask</strong></p>
<p>自定义void返回类型的Task</p>
</li>
<li><p><strong>CustomAsyncVoidMethodBuilder</strong></p>
<p>用于生成返回void类型的Task结构体的自定义异步任务构造器(struct)，通过在对应Task定义添加[AsyncMethodBuilder(typeof(CustomAsyncVoidMethodBuilder))]标签标记指定异步任务构造器</p>
</li>
<li><p><strong>CustomTaskAwaiter</strong></p>
<p>抽象自定义void返回类型的异步任务等待器</p>
</li>
<li><p><strong>ICustomTaskSource</strong></p>
<p>抽象一层任务数据，通过依赖反转实现上层DIY的自定义任务void类型(比如CustomDelayTask)不影响整体自定义Task框架。</p>
</li>
<li><p>**CustomVoidTaskCompletionSource **</p>
<p>自定义返回void类型的任务完成数据抽象(CustomAsyncVoidMethodBuilder会构建)，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/12674069664">这个类很重要，是我们包装每一个async函数都要生成的一个类，它用来记录整个async函数的完成情况（注意是整个，这个很重要），完成后的回调，以及异常、取消等实现。</a></p>
</li>
<li><p><strong>CustomTaskLoopManager</strong></p>
<p>自定义任务循环管理单例类，负责需要注入Update驱动的统一管理(比如实现CustomTask.Delay()和CustomTask.Yield()等效果)</p>
</li>
<li><p><strong>CustomTaskLoopType</strong></p>
</li>
</ol>
<p>自定义任务循环枚举，用于支持类似Unity里不同Update的定义</p>
<ol start="8">
<li><strong>CustomTaskStatus</strong></li>
</ol>
<p>​		自定义异步任务状态枚举 </p>
<ol start="9">
<li><strong>CancellationTokenSource</strong>和<strong>CancellationToken</strong></li>
</ol>
<p><strong>采用原生定义的结构辅助设计异步任务取消，ICustomTaskSource子类通过定义SetCanceled方法实现自定义相关的异步任务取消逻辑，CancellationTokenSource和CancellationToken主要用于解决异步嵌套的一系列义务任务打断判定和回调注入</strong></p>
<ol start="10">
<li><p><strong>CustomTask<T></strong></p>
<p>自定义T返回类型的Task</p>
</li>
<li><p><strong>CustomAsyncMethodBuilder<T></strong></p>
<p>用于生成返回T类型的Task结构体的自定义异步任务构造器(struct)，通过在对应Task定义添加[AsyncMethodBuilder(typeof(<strong>CustomAsyncMethodBuilder<T></strong>))]标签标记指定异步任务构造器</p>
</li>
<li><p><strong>CustomTaskAwaiter<T></strong></p>
<p>抽象自定义T返回类型的异步任务等待器</p>
</li>
<li><p><strong>ICustomTaskSource<T></strong></p>
<p>抽象一层任务数据，通过依赖反转实现上层DIY的自定义任务返回T类型不影响整体自定义Task框架。</p>
</li>
<li><p><strong>CustomTaskCompletionSource<T></strong></p>
<p>自定义返回T类型的任务完成数据抽象(CustomAsyncMethodBuilder<T>会构建)，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/12674069664">这个类很重要，是我们包装每一个async函数都要生成的一个类，它用来记录整个async函数的完成情况（注意是整个，这个很重要），完成后的回调，以及异常、取消等实现。</a></p>
</li>
<li><p><strong>CustomDelayTask</strong></p>
<p>自定义延迟指定毫秒Task</p>
</li>
<li><p><strong>CustomYieldTask</strong></p>
<p>自定义延迟指定帧数Task</p>
</li>
</ol>
<h3 id="进阶-UniTask"><a href="#进阶-UniTask" class="headerlink" title="进阶(UniTask)"></a>进阶(UniTask)</h3><p>了解Task异步的基础使用和设计，接下来让我们看看UniTask是如何实现Unity内更优的异步框架设计的。</p>
<p>官网介绍:</p>
<p><strong>UniTask的特点</strong></p>
<ul>
<li>为 Unity 提供有效的无GC async&#x2F;await集成。</li>
<li>基于Struct <code>UniTask&lt;T&gt;</code> 的自定义 AsyncMethodBuilder，实现零GC,使所有Unity的异步操作和协程可以await</li>
<li>基于PlayerLoop的Task（ <code>UniTask.Yield</code>、 <code>UniTask.Delay</code>、 <code>UniTask.DelayFrame</code> 等）这使得能够替换所有协程操作</li>
<li>MonoBehaviour 消息事件和 uGUI 事件为可使用Await&#x2F;AsyncEnumerable</li>
<li>完全在 Unity 的 PlayerLoop 上运行，因此不使用线程，可在 WebGL、wasm 等平台上运行。</li>
<li>异步 LINQ，具有Channel和 AsyncReactiveProperty</li>
<li>防止内存泄漏的 TaskTracker (Task追踪器)窗口</li>
<li>与Task&#x2F;ValueTask&#x2F;IValueTaskSource 的行为高度兼容</li>
</ul>
<p>上面提到UniTask没有使用多线程，这一点对于Unity单线程开发理念更加适合。</p>
<p><strong>更多学习使用待添加……(TODO)</strong></p>
<h2 id="重点知识"><a href="#重点知识" class="headerlink" title="重点知识"></a>重点知识</h2><ol>
<li><strong>Unity子线程内不可访问游戏对象或者组件以及相关方法，只用于处理数据或者逻辑，任何要与主线程发生关系的地方都必须进行回调和上下文切换。</strong></li>
<li><strong>await和async关键词并不一定触发多线程，是否多线程是与使用的具体方式而定(比如Task.Run)</strong></li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/async">Asynchronous programming</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">Task-based Asynchronous Pattern(TAP)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Bob-luo/p/18518463">深入解析C#异步编程：await 关键字背后的实现原理 </a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/12674069664">每个人都能写UniTask!!!自定义一个TaskLike并完成一个简单的Delay延时教程</a></p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a target="_blank" rel="noopener" href="https://github.com/Cysharp/UniTask">UniTask</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Programming/">Programming</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Programming/">Programming</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2022/10/12/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" data-title="异步编程 | 走停人生路" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2023/03/10/EmmyLua注释生成工具/" title="EmmyLua注释生成工具">
  <strong>上一篇：</strong><br/>
  <span>
  EmmyLua注释生成工具</span>
</a>
</div>


<div class="next">
<a href="/2022/08/12/红点系统/"  title="红点系统">
 <strong>下一篇：</strong><br/> 
 <span>红点系统
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Task-based-Asynchronous-Pattern-TAP"><span class="toc-number">2.1.</span> <span class="toc-text">Task-based Asynchronous Pattern(TAP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task"><span class="toc-number">2.3.</span> <span class="toc-text">Task</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">Task基础使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E4%BD%BF%E7%94%A8Async%E5%92%8CAwait%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%92%8C%E7%AD%89%E5%BE%85"><span class="toc-number">2.3.2.</span> <span class="toc-text">Task使用Async和Await实现异步方法定义和等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E5%BC%82%E6%AD%A5%E5%8F%96%E6%B6%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">Task异步取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.4.</span> <span class="toc-text">Task总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-AsyncTaskMethodBuilder"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">深入理解 AsyncTaskMethodBuilder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">异步方法的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C"><span class="toc-number">2.3.5.</span> <span class="toc-text">使用体验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Task"><span class="toc-number">2.4.</span> <span class="toc-text">自定义Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-UniTask"><span class="toc-number">2.5.</span> <span class="toc-text">进阶(UniTask)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">重点知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Github"><span class="toc-number">5.</span> <span class="toc-text">Github</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/AI/" title="AI">AI<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Art/" title="Art">Art<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Automation/" title="Automation">Automation<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Collision/" title="Collision">Collision<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Database/" title="Database">Database<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Editor/" title="Editor">Editor<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Excel/" title="Excel">Excel<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game/" title="Game">Game<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/HotUpdate/" title="HotUpdate">HotUpdate<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Lua/" title="Lua">Lua<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Math/" title="Math">Math<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Native/" title="Native">Native<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Network/" title="Network">Network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Optimization/" title="Optimization">Optimization<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Other/" title="Other">Other<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Plugin/" title="Plugin">Plugin<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming/" title="Programming">Programming<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Resource/" title="Resource">Resource<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Unity/" title="Unity">Unity<sup>7</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Editor/" title="Editor">Editor<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Other/" title="Other">Other<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Resource/" title="Resource">Resource<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Art/" title="Art">Art<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UI/" title="UI">UI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C#">C#<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Database/" title="Database">Database<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shader/" title="Shader">Shader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SubmlineText3/" title="SubmlineText3">SubmlineText3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Rendering/" title="Rendering">Rendering<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Native/" title="Native">Native<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Prefab/" title="Prefab">Prefab<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Plugin/" title="Plugin">Plugin<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2026 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
