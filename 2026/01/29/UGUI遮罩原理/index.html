
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>UGUI遮罩原理 | 走停人生路</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Tony Tang">
    

    
    <meta name="description" content="前言Unity游戏开发过程中，2D UI上常常会通过添加Mask或者RectMask2D组件进行UI遮罩显示。本章是为了深入学习理解Mask和RectMask2D原理相关知识，思考3D粒子，模型和UI混合显示方案。 MaskMask是指通过遮罩控制可见显示区域的一种遮罩显示。 UGUI里常见的遮罩有两种：  Mask Rect2DMask  虽然都是实现Mask效果，但两个组件的底层遮罩实现原理却">
<meta property="og:type" content="article">
<meta property="og:title" content="UGUI遮罩原理">
<meta property="og:url" content="http://tonytang1990.github.io/2026/01/29/UGUI%E9%81%AE%E7%BD%A9%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="走停人生路">
<meta property="og:description" content="前言Unity游戏开发过程中，2D UI上常常会通过添加Mask或者RectMask2D组件进行UI遮罩显示。本章是为了深入学习理解Mask和RectMask2D原理相关知识，思考3D粒子，模型和UI混合显示方案。 MaskMask是指通过遮罩控制可见显示区域的一种遮罩显示。 UGUI里常见的遮罩有两种：  Mask Rect2DMask  虽然都是实现Mask效果，但两个组件的底层遮罩实现原理却">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/StencilTestCompareValue.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/StencilTestReplaceValue.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/BeforeMaskComponentUsing.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/MaskComponentUsing.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/AfterMaskComponentUsing.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/MaskFrameDebugDrawPreview.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/AfterMaskGraphRenderStatus.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/MaskChildGraphicStencilSetting.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/RenderMaskChildGraphicStatus.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UnmaskMaterialStatus.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/MainUIInvertMaskInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/InvertMaskInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/InvertMaskFinalResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/BtnMaskClickLog.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/InverMask2Inspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/InvertMaskFinalResult2.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/PenetrateImageInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/PenetrateRawImageInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleAdditiveInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleAdditiveShowResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleAdditiveMaskInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleAdditiveMaskShowResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleAdditiveMaskFrameDebugger.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMatInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskMatInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskedMatInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskSceneAndHierachy.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskGame.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskFrameDebugger.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskParticleSystemFrameDebugger.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskSecondCanvasFrameDebugger.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIDefaultMaskFrontImgFrameDebugger.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/CreateEmptyUIParticleGameObject.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIParticleRefreshButton.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/CreateUIParticleFromGameObject.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUIMaskInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUIMaskShowResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUIMaskFrameDebugger.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUICancelPSRenderer.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUIRectMask2DInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUIRectMask2DShowResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUILayerInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleEffectForUGUILayerShowResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIParticleAttractorInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/UIParticleAttractorShowResult.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/RectMask2DAndParticleClipInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/ParticleClipAdditiveMaskShaderInspector.PNG">
<meta property="og:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/RectMask2DAndParticleClipShowResult.PNG">
<meta property="article:published_time" content="2026-01-29T15:00:00.000Z">
<meta property="article:modified_time" content="2026-02-09T03:52:30.001Z">
<meta property="article:author" content="Tony Tang">
<meta property="article:tag" content="Rendering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tonytang1990.github.io/img/Unity/RenderOrder/StencilTestCompareValue.PNG">

    
    <link rel="alternative" href="/atom.xml" title="走停人生路" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="走停人生路" title="走停人生路"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="走停人生路">走停人生路</a></h1>
				<h2 class="blog-motto">做着独立游戏梦，坚持走在游戏开发道路上的人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:tonytang1990.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2026/01/29/UGUI遮罩原理/" title="UGUI遮罩原理" itemprop="url">UGUI遮罩原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Tony Tang" target="_blank" itemprop="author">Tony Tang</a>
		
  <p class="article-time">
    <time datetime="2026-01-29T15:00:00.000Z" itemprop="datePublished"> 发表于 2026-01-29</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mask"><span class="toc-number">2.</span> <span class="toc-text">Mask</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mask%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Mask组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stencil-Buffer"><span class="toc-number">2.1.1.</span> <span class="toc-text">Stencil Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mask-UI%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">Mask+UI组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask%E6%8C%96%E6%B4%9E-UI%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Mask挖洞+UI组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E7%82%B9%E5%87%BB-UI%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">Mask透明区域是否可点击+UI组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mask-%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">Mask+粒子特效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask-%E8%87%AA%E5%B8%A6ParticleAdditive-Shader"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">Mask+自带ParticleAdditive Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask-%E4%BF%AE%E6%94%B9ParticleAdditive-Mask-Shader"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">Mask+修改ParticleAdditive Mask Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6UI-Default-Shader"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">仅使用自带UI Default Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParticleEffectForUGUI"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">ParticleEffectForUGUI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ParticleEffectForUGUI%E5%AF%BC%E5%85%A5"><span class="toc-number">2.1.3.4.1.</span> <span class="toc-text">ParticleEffectForUGUI导入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88Shader%E6%94%AF%E6%8C%81Stencil%E5%92%8CClip"><span class="toc-number">2.1.3.4.2.</span> <span class="toc-text">扩展粒子特效Shader支持Stencil和Clip</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88GameObject"><span class="toc-number">2.1.3.4.3.</span> <span class="toc-text">制作粒子特效GameObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticle%E7%BC%A9%E6%94%BE"><span class="toc-number">2.1.3.4.4.</span> <span class="toc-text">UIParticle缩放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticle%E9%81%AE%E7%BD%A9"><span class="toc-number">2.1.3.4.5.</span> <span class="toc-text">UIParticle遮罩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticle%E5%B1%82%E7%BA%A7"><span class="toc-number">2.1.3.4.6.</span> <span class="toc-text">UIParticle层级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticleAttractor"><span class="toc-number">2.1.3.4.7.</span> <span class="toc-text">UIParticleAttractor</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RectMask2D%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">RectMask2D组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0CanvasRenderer%E9%87%8C%E5%8E%BB%E6%B8%B2%E6%9F%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">将粒子特效重定向到CanvasRenderer里去渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%BC%A0%E9%80%92RectMask2D%E8%A3%81%E5%89%AA%E5%8C%BA%E5%9F%9F%E5%88%B0%E7%B2%92%E5%AD%90Shader"><span class="toc-number">2.2.2.</span> <span class="toc-text">手动传递RectMask2D裁剪区域到粒子Shader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3D%E5%92%8C2D%E6%B7%B7%E5%90%88%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">3D和2D混合显示及决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Extra-3D-Model-Camera"><span class="toc-number">3.1.</span> <span class="toc-text">Extra 3D Model Camera</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D-Camera-Render-Texture"><span class="toc-number">3.2.</span> <span class="toc-text">3D Camera + Render Texture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">学习总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Github"><span class="toc-number">5.</span> <span class="toc-text">Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">6.</span> <span class="toc-text">Reference</span></a></li></ol>
		
		</div>
		
		<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Unity游戏开发过程中，2D UI上常常会通过添加Mask或者RectMask2D组件进行UI遮罩显示。本章是为了<strong>深入学习理解Mask和RectMask2D原理相关知识，思考3D粒子，模型和UI混合显示方案</strong>。</p>
<h1 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h1><p>Mask是指通过遮罩控制可见显示区域的一种遮罩显示。</p>
<p>UGUI里常见的遮罩有两种：</p>
<ol>
<li><strong>Mask</strong></li>
<li><strong>Rect2DMask</strong></li>
</ol>
<p>虽然都是实现Mask效果，但两个组件的底层遮罩实现原理却大不相同，接下来让我们深入Mask和Rect2DMask底层实现，深入理解Mask底层的相关知识，会后续3D和2D混合显示遮罩打下基础。</p>
<h2 id="Mask组件"><a href="#Mask组件" class="headerlink" title="Mask组件"></a>Mask组件</h2><p>在深入了解Mask组件之前，我们需要了解一下什么是Stencil Buffer(模板缓存)，<strong>Stencil Buffer是实现遮罩的底层渲染原理。</strong></p>
<h3 id="Stencil-Buffer"><a href="#Stencil-Buffer" class="headerlink" title="Stencil Buffer"></a>Stencil Buffer</h3><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Stencil.html">The stencil buffer stores an 8-bit integer value for each <strong>pixel</strong> in the frame buffer. Before executing the fragment <strong>shader</strong> for a given pixel, the GPU can compare the current value in the stencil buffer against a given reference value. This is called a stencil test. If the stencil test passes, the GPU performs the depth test. If the stencil test fails, the GPU skips the rest of the processing for that pixel. This means that you can use the stencil buffer as a mask to tell the GPU which pixels to draw, and which pixels to discard.</a></p>
<p>从上面的介绍可以看出，<strong>Stencil Buffer(模板缓存)不同于深度Buffer和颜色Buffer，不是用来存储深度或颜色信息的，而是一个每个像素分配8bit(0-255)用来存储Stencil比较值的地方。如果一个pixel通不过Stencil Test(类似Depth Test，但是是用来比较Stencil Buffer值的方式)，那么这个pixel将不会再走后续渲染流程(Depth Test)。</strong></p>
<p>Unity Stencil有很多参数，这里调几个重要的参数介绍：</p>
<ul>
<li><p><strong>comparisonOperation(Stencil值比较方式)</strong></p>
<p><img src="/img/Unity/RenderOrder/StencilTestCompareValue.PNG" alt="StencilTestCompareValue"></p>
<p><strong>Stencil Test比较公式:</strong></p>
<p>​        <strong>(ref &amp; readMask) comparisonFunction (stencilBufferValue &amp; readMask)</strong></p>
</li>
<li><p><strong>passOperation(Stencil值通过替换方式)</strong></p>
<p><img src="/img/Unity/RenderOrder/StencilTestReplaceValue.PNG" alt="StencilTestReplaceValue"></p>
</li>
<li><p><strong>ref(引用参考值)</strong></p>
<p><strong>用于Stencil值比较或Stencil Pass后值替换等</strong></p>
</li>
<li><p><strong>ReadMask(Stencil比较掩码)</strong></p>
<p><strong>用于Stencil Test时值比较过滤，从上面的Stencil Test公式可以看到Ref和Stencil Buffer Value值都与ReadMask与之后在进行比较的</strong></p>
</li>
<li><p><strong>WriteMask(Stencil写掩码)</strong></p>
<p><strong>用于Stencil Test通过后passOperation值写入过滤，即与passOperation后的值进行比较过滤再写入Stencil Buffer</strong></p>
</li>
</ul>
<p>更多参数参考官网：</p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Stencil.html">ShaderLab command: Stencil</a></p>
<p>Note:</p>
<ol>
<li><strong>Stencil Test发生Depth Test之前，Aplha Test和fragment shader之后。顺序是：Alpha Test -&gt; fragment shader -&gt; Stencil Test -&gt; depth test</strong></li>
<li><strong>模板缓冲可以用来制作物体的遮罩、轮廓描边、阴影、遮挡显示等等效果</strong></li>
</ol>
<h3 id="Mask-UI组件"><a href="#Mask-UI组件" class="headerlink" title="Mask+UI组件"></a>Mask+UI组件</h3><p>先让我们尝试一下Mask组件的使用：</p>
<p>使用Mask组件前：</p>
<p><img src="/img/Unity/RenderOrder/BeforeMaskComponentUsing.PNG" alt="BeforeMaskComponentUsing"></p>
<p>使用Mask组件后：</p>
<p><img src="/img/Unity/RenderOrder/MaskComponentUsing.PNG" alt="MaskComponentUsing"></p>
<p><img src="/img/Unity/RenderOrder/AfterMaskComponentUsing.PNG" alt="AfterMaskComponentUsing"></p>
<p>可以看到通过使用一个圆形遮罩我们成功的将√实现了圆形的遮罩显示，当同时右上角Status数据也可以看到，激活Mask给我们增加了1个Batches和2个SetPass calls，至于原因后续会讲到。</p>
<p>那么第一个疑问，我们想知道的是Mask组件式如何实现遮罩的了？</p>
<p>首先我打开FrameDebug看了下Image是实际绘制流程：</p>
<p><img src="/img/Unity/RenderOrder/MaskFrameDebugDrawPreview.PNG" alt="MaskFrameDebugDrawPreview"></p>
<p>可以看到1个Mask和1张图绘制总共分为3步，绘制了3次Mesh。</p>
<p>打开Mask.cs源码，我们会看到两个跟材质挂钩的代码:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> Stencil calculation time!    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mask</span> : <span class="title">UIBehaviour</span>, <span class="title">ICanvasRaycastFilter</span>, <span class="title">IMaterialModifier</span></span><br><span class="line">   &#123;</span><br><span class="line">       ******</span><br><span class="line"></span><br><span class="line">       [<span class="meta">NonSerialized</span>]</span><br><span class="line">	<span class="keyword">private</span> Material m_MaskMaterial;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">NonSerialized</span>]</span><br><span class="line">	<span class="keyword">private</span> Material m_UnmaskMaterial;</span><br><span class="line">    	</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (!MaskEnabled())</span><br><span class="line">               <span class="keyword">return</span> baseMaterial;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> rootSortCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">           <span class="keyword">var</span> stencilDepth = MaskUtilities.GetStencilDepth(transform, rootSortCanvas);</span><br><span class="line">           <span class="keyword">if</span> (stencilDepth &gt;= <span class="number">8</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               Debug.LogWarning(<span class="string">&quot;Attempting to use a stencil mask with depth &gt; 8&quot;</span>, gameObject);</span><br><span class="line">               <span class="keyword">return</span> baseMaterial;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">int</span> desiredStencilBit = <span class="number">1</span> &lt;&lt; stencilDepth;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// if we are at the first level...</span></span><br><span class="line">           <span class="comment">// we want to destroy what is there</span></span><br><span class="line">           <span class="keyword">if</span> (desiredStencilBit == <span class="number">1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">var</span> maskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Replace, CompareFunction.Always, m_ShowMaskGraphic ? ColorWriteMask.All : <span class="number">0</span>);</span><br><span class="line">               StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">               m_MaskMaterial = maskMaterial;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">var</span> unmaskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Zero, CompareFunction.Always, <span class="number">0</span>);</span><br><span class="line">               StencilMaterial.Remove(m_UnmaskMaterial);</span><br><span class="line">               m_UnmaskMaterial = unmaskMaterial;</span><br><span class="line">               graphic.canvasRenderer.popMaterialCount = <span class="number">1</span>;</span><br><span class="line">               graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> m_MaskMaterial;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//otherwise we need to be a bit smarter and set some read / write masks</span></span><br><span class="line">           <span class="keyword">var</span> maskMaterial2 = StencilMaterial.Add(baseMaterial, desiredStencilBit | (desiredStencilBit - <span class="number">1</span>), StencilOp.Replace, CompareFunction.Equal, m_ShowMaskGraphic ? ColorWriteMask.All : <span class="number">0</span>, desiredStencilBit - <span class="number">1</span>, desiredStencilBit | (desiredStencilBit - <span class="number">1</span>));</span><br><span class="line">           StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">           m_MaskMaterial = maskMaterial2;</span><br><span class="line"></span><br><span class="line">           graphic.canvasRenderer.hasPopInstruction = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">var</span> unmaskMaterial2 = StencilMaterial.Add(baseMaterial, desiredStencilBit - <span class="number">1</span>, StencilOp.Replace, CompareFunction.Equal, <span class="number">0</span>, desiredStencilBit - <span class="number">1</span>, desiredStencilBit | (desiredStencilBit - <span class="number">1</span>));</span><br><span class="line">           StencilMaterial.Remove(m_UnmaskMaterial);</span><br><span class="line">           m_UnmaskMaterial = unmaskMaterial2;</span><br><span class="line">           graphic.canvasRenderer.popMaterialCount = <span class="number">1</span>;</span><br><span class="line">           graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> m_MaskMaterial;</span><br><span class="line">       &#125;</span><br><span class="line">       ******</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看到，Mask组件实现了IMaterialModifier接口。</p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/UI.IMaterialModifier.html">IMaterialModifier is Interface which allows for the modification of the Material used to render a Graphic before they are passed to the CanvasRenderer.</a></p>
<p>UGUI我们是通过Canvas统一进行绘制渲染的，从上面的介绍可以看出要实现IMaterialModifier允许我们在传递给CanvasRenderer绘制渲染UI(Graphic)之前进行材质处理，而IMaterialModifier.GetModifiedMaterial()正是这么个接口。</p>
<p>打开StencilMaterial.cs查看源码StencilMaterials.Add()接口:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Add a new material using the specified base and stencil ID.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Material <span class="title">Add</span>(<span class="params">Material baseMat, <span class="built_in">int</span> stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask, <span class="built_in">int</span> readMask, <span class="built_in">int</span> writeMask</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((stencilID &lt;= <span class="number">0</span> &amp;&amp; colorWriteMask == ColorWriteMask.All) || baseMat == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!baseMat.HasProperty(<span class="string">&quot;_Stencil&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Material &quot;</span> + baseMat.name + <span class="string">&quot; doesn&#x27;t have _Stencil property&quot;</span>, baseMat);</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!baseMat.HasProperty(<span class="string">&quot;_StencilOp&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Material &quot;</span> + baseMat.name + <span class="string">&quot; doesn&#x27;t have _StencilOp property&quot;</span>, baseMat);</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!baseMat.HasProperty(<span class="string">&quot;_StencilComp&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Material &quot;</span> + baseMat.name + <span class="string">&quot; doesn&#x27;t have _StencilComp property&quot;</span>, baseMat);</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!baseMat.HasProperty(<span class="string">&quot;_StencilReadMask&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Material &quot;</span> + baseMat.name + <span class="string">&quot; doesn&#x27;t have _StencilReadMask property&quot;</span>, baseMat);</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!baseMat.HasProperty(<span class="string">&quot;_StencilWriteMask&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Material &quot;</span> + baseMat.name + <span class="string">&quot; doesn&#x27;t have _StencilWriteMask property&quot;</span>, baseMat);</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!baseMat.HasProperty(<span class="string">&quot;_ColorMask&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Material &quot;</span> + baseMat.name + <span class="string">&quot; doesn&#x27;t have _ColorMask property&quot;</span>, baseMat);</span><br><span class="line">        <span class="keyword">return</span> baseMat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_List.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        MatEntry ent = m_List[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ent.baseMat == baseMat</span><br><span class="line">            &amp;&amp; ent.stencilId == stencilID</span><br><span class="line">            &amp;&amp; ent.operation == operation</span><br><span class="line">            &amp;&amp; ent.compareFunction == compareFunction</span><br><span class="line">            &amp;&amp; ent.readMask == readMask</span><br><span class="line">            &amp;&amp; ent.writeMask == writeMask</span><br><span class="line">            &amp;&amp; ent.colorMask == colorWriteMask)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ent.count;</span><br><span class="line">            <span class="keyword">return</span> ent.customMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newEnt = <span class="keyword">new</span> MatEntry();</span><br><span class="line">    newEnt.count = <span class="number">1</span>;</span><br><span class="line">    newEnt.baseMat = baseMat;</span><br><span class="line">    newEnt.customMat = <span class="keyword">new</span> Material(baseMat);</span><br><span class="line">    newEnt.customMat.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">    newEnt.stencilId = stencilID;</span><br><span class="line">    newEnt.operation = operation;</span><br><span class="line">    newEnt.compareFunction = compareFunction;</span><br><span class="line">    newEnt.readMask = readMask;</span><br><span class="line">    newEnt.writeMask = writeMask;</span><br><span class="line">    newEnt.colorMask = colorWriteMask;</span><br><span class="line">    newEnt.useAlphaClip = operation != StencilOp.Keep &amp;&amp; writeMask &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    newEnt.customMat.name = <span class="built_in">string</span>.Format(<span class="string">&quot;Stencil Id:&#123;0&#125;, Op:&#123;1&#125;, Comp:&#123;2&#125;, WriteMask:&#123;3&#125;, ReadMask:&#123;4&#125;, ColorMask:&#123;5&#125; AlphaClip:&#123;6&#125; (&#123;7&#125;)&quot;</span>, stencilID, operation, compareFunction, writeMask, readMask, colorWriteMask, newEnt.useAlphaClip, baseMat.name);</span><br><span class="line"></span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_Stencil&quot;</span>, stencilID);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_StencilOp&quot;</span>, (<span class="built_in">int</span>)operation);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_StencilComp&quot;</span>, (<span class="built_in">int</span>)compareFunction);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_StencilReadMask&quot;</span>, readMask);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_StencilWriteMask&quot;</span>, writeMask);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_ColorMask&quot;</span>, (<span class="built_in">int</span>)colorWriteMask);</span><br><span class="line">    newEnt.customMat.SetInt(<span class="string">&quot;_UseUIAlphaClip&quot;</span>, newEnt.useAlphaClip ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newEnt.useAlphaClip)</span><br><span class="line">        newEnt.customMat.EnableKeyword(<span class="string">&quot;UNITY_UI_ALPHACLIP&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newEnt.customMat.DisableKeyword(<span class="string">&quot;UNITY_UI_ALPHACLIP&quot;</span>);</span><br><span class="line"></span><br><span class="line">    m_List.Add(newEnt);</span><br><span class="line">    <span class="keyword">return</span> newEnt.customMat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<strong>Mask在IMaterialModifies.GetModifiedMaterial()接口里是对UI的原始材质进行复制后，对Stencil(模板缓存)进行修改实现的遮罩效果。</strong></p>
<p>结合首层Mask逻辑，我们来理一下遮罩原理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if we are at the first level...</span></span><br><span class="line"><span class="comment">// we want to destroy what is there</span></span><br><span class="line"><span class="keyword">if</span> (desiredStencilBit == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> maskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Replace, CompareFunction.Always, m_ShowMaskGraphic ? ColorWriteMask.All : <span class="number">0</span>);</span><br><span class="line">    StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">    m_MaskMaterial = maskMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> unmaskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Zero, CompareFunction.Always, <span class="number">0</span>);</span><br><span class="line">    StencilMaterial.Remove(m_UnmaskMaterial);</span><br><span class="line">    m_UnmaskMaterial = unmaskMaterial;</span><br><span class="line">    graphic.canvasRenderer.popMaterialCount = <span class="number">1</span>;</span><br><span class="line">    graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_MaskMaterial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是第一层，stencilDepth值为0，目标模版缓存值(desiredStencilBit)为1。</p>
<ol>
<li><p>Unity Mask先添加了基于baseMaterial(原始配置的材质球)新裁剪材质球maskMaterial，将新材质球的<strong>Stencile(模版参考比较值)值改为1</strong>，将<strong>StencilOp的模板操作设置成Replace(模版缓存比较通过则替换成新的模板参考比较值)</strong>，<strong>CompareFunction(模版比较方式)设置成Always(模板测试总是通过)</strong>，根据是否显示Mask图形将<strong>ColorWriteMask(颜色写入FrameBuffer的Mask值)设置成255(所有颜色值都写入)或0(所有颜色值都不写入)</strong>，至于<strong>Stencile的ReadMask和WriteMask(第一层默认传255)</strong></p>
</li>
<li><p>通过第1步的新增裁剪材质球maskMaterial处理，当我们渲染Mask图形的时候，ColorWriteMask会决定将Mask图形颜色写入，反之不写入(这一步决定了mask图形是否显示)。</p>
</li>
<li><p>通过第1步的新材裁剪质球maskMaterial处理，因为模板比较是Always(总是通过)，结合模版参考值1和模板操作方式Replace，此时<strong>渲染完Mask图形后Stencil Ref值应该为1</strong></p>
<p><img src="/img/Unity/RenderOrder/AfterMaskGraphRenderStatus.PNG" alt="AfterMaskGraphRenderStatus"></p>
</li>
<li><p>接着创建<strong>unmaskMaterial材质球，并将其设置成遮罩Graphic.canvasRendererd的SetPopMaterial(个人理解是后续用于渲染完所有子对象后的额外材质球处理)用于取消Mask的相关设置，这一步发生在Mask图形所有子对象渲染完成时(从结果额外绘制了一个Mesh触发了unmaskMaterial逻辑来猜测的)</strong>，后续详细介绍</p>
</li>
<li><p>接下来渲染遮罩图形的子对象tickImg</p>
<p><img src="/img/Unity/RenderOrder/MaskChildGraphicStencilSetting.PNG" alt="MaskChildGraphicStencilSetting"></p>
<p><img src="/img/Unity/RenderOrder/RenderMaskChildGraphicStatus.PNG" alt="RenderMaskChildGraphicStatus"></p>
<p>可以看到遮罩图形的子对象tickImg的模板相关设置是<strong>Stencil Ref(模版参考比较值)为1</strong>，<strong>StencilOp的模板操作是Keep(保持原模板缓存值)，StencilComp的模板比较操作是Equal(模版值和模板参考值相同才通过模板测试)</strong>，<strong>Stencil Write Mask(模版缓存值写入时的Mask值)值为0(不允许写入模板缓存值)</strong>，<strong>Stencil Read Mask(模版缓存读取时的Mask值)值为1(只允许读取第一位的模板值)</strong>，<strong>ColorMask(颜色写入Mask值，8bit标识，15为所有颜色值写入)值为15</strong>。</p>
<p><strong>我这里使用的是Unity自带的UI&#x2F;Default Shader，这些模板值设置是发生在我给UI挂载对象时或者增删Mask组件时</strong>。</p>
<p><strong>因此子对象渲染时发现模版缓存值为1，且自身设置模板参考比较值也为1，同时模板比较方法是Equal，从而实现只有在Mask图形区域类模板缓存值为1的部分满足显示，从而只有Mask图形区域内的子对象显示部分通过了模板缓存测试，同时通过后因为StencilOp的模板操作是Keep所以模板缓存值不变依然是1</strong></p>
</li>
<li><p>子对象渲染完成后，我们接着看第4步里unmaskMaterial的后续逻辑，<strong>unmaskMaterial的Stencil Ref(模版参考比较值)为1，StencilOp的模板操作是Zero(设置模板值到0)，StencilComp的模板比较操作是Always(总是通过模板缓存测试)，ColorMask为0(不写入任何颜色)</strong></p>
<p><img src="/img/Unity/RenderOrder/UnmaskMaterialStatus.PNG" alt="UnmaskMaterialStatus"></p>
<p>因为maskMaterial和子对象渲染完成后，模版缓存里的值为1，此时<strong>unmaskMaterial的StencilComp是Always，StencilOp的模板操作是Zero</strong>，所以会<strong>将模板缓存里的值更新到0</strong>，同时因为ColorMask为0所以这一次unmaskMaterial的额外Mesh渲染绘制不会显示任何东西。</p>
</li>
</ol>
<p>Note:</p>
<ol>
<li><strong>Mask实现遮罩效果底层原理是通过Stencil(模板缓存)</strong></li>
</ol>
<h4 id="Mask挖洞-UI组件"><a href="#Mask挖洞-UI组件" class="headerlink" title="Mask挖洞+UI组件"></a>Mask挖洞+UI组件</h4><p>在了解了Mask的底层原理后，让我们来看看游戏开发过程中还有一种最常见的需求，Mask挖洞。<strong>Mask和Mask挖洞字面意思，前者是在范围内的才显示，后者是不在范围内的才显示。</strong></p>
<p><strong>新手引导里需要挖洞显示下层按钮，需求上需要支持不同形状的挖洞，同时挖出来的洞要支持点击响应。</strong></p>
<p><strong>考虑到为了支持原生Mask组件流程，所以不继承去修改Mask的流程，既然Mask已经通过maskMaterial修改了stencil值，那么我们要做的就是将子对象Graph渲染时实现反向Stencil比较的方式实现反向显示，而Mask组件只作为挖洞形状的Image。</strong></p>
<p><strong>Graphic实现遮罩(不管是Mask还是RectMask2D)原理的核心逻辑是继承MaskableGraphic.cs(Image继承至MaskableGraphic)，而针对Mask模版缓存实现遮罩的核心逻辑是接口IMaterialModifier的GetModifiedMaterial()方法</strong></p>
<p>MaskableGraphi.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A Graphic that is capable of being masked out.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MaskableGraphic</span> : <span class="title">Graphic</span>, <span class="title">IClippable</span>, <span class="title">IMaskable</span>, <span class="title">IMaterialModifier</span></span><br><span class="line">&#123;</span><br><span class="line">    ******</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> See IMaterialModifier.GetModifiedMaterial</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> toUse = baseMaterial;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_ShouldRecalculateStencil)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rootCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">            m_StencilValue = maskable ? MaskUtilities.GetStencilDepth(transform, rootCanvas) : <span class="number">0</span>;</span><br><span class="line">            m_ShouldRecalculateStencil = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we have a enabled Mask component then it will</span></span><br><span class="line">        <span class="comment">// generate the mask material. This is an optimisation</span></span><br><span class="line">        <span class="comment">// it adds some coupling between components though :(</span></span><br><span class="line">        Mask maskComponent = GetComponent&lt;Mask&gt;();</span><br><span class="line">        <span class="keyword">if</span> (m_StencilValue &gt; <span class="number">0</span> &amp;&amp; (maskComponent == <span class="literal">null</span> || !maskComponent.IsActive()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> maskMat = StencilMaterial.Add(toUse, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, StencilOp.Keep, CompareFunction.Equal, ColorWriteMask.All, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">            m_MaskMaterial = maskMat;</span><br><span class="line">            toUse = m_MaskMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toUse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMaterialModifier.GetModifiedMaterial()这个接口方法会在Graphic渲染之前允许对材质球进行计算操作。</strong></p>
<p>可以看MaskableGraphic.cs的GetModifiedMaterial()方法对没有Mask组件的Image进行了Stencil相关的Shader参数设置，这里最重要的就是<strong>StencilID设置成(1 &lt;&lt; m_StencilValue) - 1，Stencil的CompareFunction设置成Equal(模版缓存比较采取相等才通过)和Stencil的Operation设置成Keep(保持原始Stencil值)</strong></p>
<p>因为如果上层有Mask组件，mask的字Graphic渲染时Stencil Value已经为1了，这里StencilID最终计算就会是1&lt;&lt;1 - 1&#x3D;1</p>
<p>也就是说子Graphic要满足Stencil ID&#x3D;1的时候才通过模板缓存且不改变Stencil Value值。</p>
<p><strong>那么这个时候如果我们的Mask子Graphic要想实现反向遮罩，我们只需要将子Graphic的材质Stencil的CompareFunction设置成NotEqual即能实现挖洞反向显示的效果。</strong></p>
<p><strong>接下来我们通过继承Image，实现一个CustomImage.cs，然后通过重写IMaterialModifier的GetModifiedMaterial()方法来实现反向遮罩的Image组件。</strong></p>
<p>CustomImage.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomImage.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自定义Image用于支持反向遮罩和透明点击穿透设置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomImage</span> : <span class="title">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;是否开启反向遮罩&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> EnableInvertMask = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> See IMaterialModifier.GetModifiedMaterial</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!EnableInvertMask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.GetModifiedMaterial(baseMaterial);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetInvertMaskModifiedMaterial(baseMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取反向遮罩修改材质球</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;baseMaterial&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">GetInvertMaskModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> toUse = baseMaterial;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_ShouldRecalculateStencil)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rootCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">            m_StencilValue = maskable ? MaskUtilities.GetStencilDepth(transform, rootCanvas) : <span class="number">0</span>;</span><br><span class="line">            m_ShouldRecalculateStencil = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Mask maskComponent = GetComponent&lt;Mask&gt;();</span><br><span class="line">        <span class="keyword">if</span> (m_StencilValue &gt; <span class="number">0</span> &amp;&amp; (maskComponent == <span class="literal">null</span> || !maskComponent.IsActive()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> maskMat = StencilMaterial.Add(toUse, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, StencilOp.Keep, CompareFunction.NotEqual, ColorWriteMask.All, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">            m_MaskMaterial = maskMat;</span><br><span class="line">            toUse = m_MaskMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toUse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomImageEditor.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomImageEditor.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomImage的Inspector扩展</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">CustomEditor(typeof(CustomImage))</span>]</span><br><span class="line">[<span class="meta">CanEditMultipleObjects</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomImageEditor</span> : <span class="title">ImageEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩属性</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> SerializedProperty mEnableInvertMask;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnable();</span><br><span class="line">        mEnableInvertMask = serializedObject.FindProperty(<span class="string">&quot;EnableInvertMask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        serializedObject.Update();</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.PropertyField(mEnableInvertMask);</span><br><span class="line"></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心代码是开启反向遮罩后我将CompareFunction.Equal修改成了CompareFunction.NotEqual</strong></p>
<p>为了测试被遮挡按钮同步遮罩效果以及被遮挡按钮模拟遮挡点击效果，编写了MainUIInvertMask.cs脚本。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> MainUIInvertMask.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主UI反向遮罩</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainUIInvertMask</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 被遮挡的真正UI组件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;被遮挡的真正UI组件&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Button BtnMasked;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 反向遮罩按钮组件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;反向遮罩按钮组件&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Button BtnInvertMask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        AddAllListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 添加所有监听器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddAllListeners</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        BtnMasked.onClick.AddListener(OnBtnMaskedClick);</span><br><span class="line">        BtnInvertMask.onClick.AddListener(OnBtnInvertMaskClick);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SyncInvertMaskImagePos();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 同步反向遮罩Image的遮挡按钮的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SyncInvertMaskImagePos</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(BtnMasked == <span class="literal">null</span> || BtnInvertMask == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BtnInvertMask.transform.position = BtnMasked.transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 响应被遮挡按钮点击</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBtnMaskedClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;响应被遮挡按钮点击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 响应遮罩按钮点击</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBtnInvertMaskClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;响应遮挡按钮点击&quot;</span>);</span><br><span class="line">        BtnMasked?.onClick.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里带Mask组件的是遮罩挖洞按钮，背景遮罩是全屏很大的Image(Mask的子对象)，被遮挡的按钮在最底层。</p>
<p>效果如下:</p>
<p><img src="/img/Unity/RenderOrder/MainUIInvertMaskInspector.PNG" alt="MainUIInvertMaskInspector"></p>
<p><img src="/img/Unity/RenderOrder/InvertMaskInspector.PNG" alt="InvertMaskInspector"></p>
<p><img src="/img/Unity/RenderOrder/InvertMaskFinalResult.PNG" alt="InvertMaskFinalResult"></p>
<p><img src="/img/Unity/RenderOrder/BtnMaskClickLog.PNG" alt="BtnMaskClickLog"></p>
<p><strong>可以看到我们拖动被遮罩的按钮时会发现遮挡按钮同步位置后实时实现了挖洞效果。</strong></p>
<p>对于<strong>RawImage组件的挖洞原理相同(因为RawImage也继承了MaskableGraphic)</strong>，我们也通过定义开关和重写GetModifiedMaterial()方法即可实现挖洞效果。</p>
<p>CustomRawImage.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> TRawImage.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自定义RawImage用于支持反向遮罩和透明点击穿透设置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRawImage</span> : <span class="title">RawImage</span>, <span class="title">ICanvasRaycastFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;是否开启反向遮罩&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> EnableInvertMask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> See IMaterialModifier.GetModifiedMaterial</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!EnableInvertMask)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.GetModifiedMaterial(baseMaterial);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetInvertMaskModifiedMaterial(baseMaterial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取反向遮罩修改材质球</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;baseMaterial&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">GetInvertMaskModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> toUse = baseMaterial;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_ShouldRecalculateStencil)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rootCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">            m_StencilValue = maskable ? MaskUtilities.GetStencilDepth(transform, rootCanvas) : <span class="number">0</span>;</span><br><span class="line">            m_ShouldRecalculateStencil = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Mask maskComponent = GetComponent&lt;Mask&gt;();</span><br><span class="line">        <span class="keyword">if</span> (m_StencilValue &gt; <span class="number">0</span> &amp;&amp; (maskComponent == <span class="literal">null</span> || !maskComponent.IsActive()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> maskMat = StencilMaterial.Add(toUse, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, StencilOp.Keep, CompareFunction.NotEqual, ColorWriteMask.All, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">            m_MaskMaterial = maskMat;</span><br><span class="line">            toUse = m_MaskMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toUse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomRawImageEditor.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomRawImageEditor.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomRawImage組件的自定义编辑器界面</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">CustomEditor(typeof(CustomRawImage), true)</span>]</span><br><span class="line">[<span class="meta">CanEditMultipleObjects</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRawImageEditor</span> : <span class="title">RawImageEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩属性</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> SerializedProperty mEnableInvertMask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnable();</span><br><span class="line">        mEnableInvertMask = serializedObject.FindProperty(<span class="string">&quot;EnableInvertMask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        serializedObject.Update();</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.PropertyField(mEnableInvertMask);</span><br><span class="line">        </span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Unity/RenderOrder/InverMask2Inspector.PNG" alt="InverMask2Inspector"></p>
<p><img src="/img/Unity/RenderOrder/InvertMaskFinalResult2.PNG" alt="InvertMaskFinalResult2"></p>
<p>可以看到通过自定义CustomRawImage我们也成功实现了RawImage组件的反向挖洞显示。</p>
<p>Note:</p>
<ol>
<li><strong>此方案Unity升级需要跟着同步MaskableGraphic的GetModifiedMaterial()的相关代码</strong></li>
</ol>
<h4 id="Mask透明区域是否可点击-UI组件"><a href="#Mask透明区域是否可点击-UI组件" class="headerlink" title="Mask透明区域是否可点击+UI组件"></a>Mask透明区域是否可点击+UI组件</h4><p>前面的Mask挖洞点击圆形周边透明区域时会发现点击依然生效了，但这种情况我们只希望挖洞的区域响应点击，此时我们需要自定义CustomImage.cs用于支持透明区域穿透设置，<strong>Image的透明度穿透核心是通过修改alphaHitTestMinimumThreshold值(&lt;&#x3D;0表示全部可点击，&gt;&#x3D;1表示全不可点击，其他值表示小于该值不可点击)实现的</strong>。</p>
<p>CustomImage.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomImage.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自定义Image用于支持反向遮罩和透明点击穿透设置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomImage</span> : <span class="title">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;是否开启反向遮罩&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> EnableInvertMask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否激活透明Alpha透明可点击阈值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;是否激活透明Alpha透明可点击阈值&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> EnableAlphaHitTestMinimusThreshold = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 透明Alpha可点击阈值(<span class="doctag">&lt;=0表示全部可点击，&gt;</span>1表示全不可点击，其他值表示小于该值不可点击)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Note：</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 仅当EnableAlphaHitTestMinimusThreshold=true时有效</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;透明Alpha可点击阈值&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> AlphaHitTestMinimumThreshold = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        UpdateAlphaHitTestMinimumThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 更新透明Alpha可点击阈值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Note:</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 外部修改EnableAlphaHitTestMinimusThreshold或AlphaHitTestMinimumThreshold值后请调用此方法确保更新成功</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> alphaHitTestMinimumThreshold值需要EnableAlphaHitTestMinimusThreshold为true的情况下设置才有效</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateAlphaHitTestMinimumThreshold</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(EnableAlphaHitTestMinimusThreshold)</span><br><span class="line">        &#123;</span><br><span class="line">            alphaHitTestMinimumThreshold = AlphaHitTestMinimumThreshold;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomImageEditor.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomImageEditor.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CustomImage的Inspector扩展</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">CustomEditor(typeof(CustomImage))</span>]</span><br><span class="line">[<span class="meta">CanEditMultipleObjects</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomImageEditor</span> : <span class="title">ImageEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩属性</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> SerializedProperty mEnableInvertMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否激活透明Alpha透明可点击阈值属性</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> SerializedProperty mEnableAlphaHitTestMinimusThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 透明Alpha可点击阈值属性</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> SerializedProperty mAlphaHitTestMinimumThreshold;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnable();</span><br><span class="line">        mEnableInvertMask = serializedObject.FindProperty(<span class="string">&quot;EnableInvertMask&quot;</span>);</span><br><span class="line">        mEnableAlphaHitTestMinimusThreshold = serializedObject.FindProperty(<span class="string">&quot;EnableAlphaHitTestMinimusThreshold&quot;</span>);</span><br><span class="line">        mAlphaHitTestMinimumThreshold = serializedObject.FindProperty(<span class="string">&quot;AlphaHitTestMinimumThreshold&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        serializedObject.Update();</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.PropertyField(mEnableInvertMask);</span><br><span class="line"></span><br><span class="line">        EditorGUI.BeginChangeCheck();</span><br><span class="line">        EditorGUILayout.PropertyField(mEnableAlphaHitTestMinimusThreshold);</span><br><span class="line">        <span class="built_in">bool</span> enableChanged = EditorGUI.EndChangeCheck();</span><br><span class="line"></span><br><span class="line">        EditorGUI.BeginChangeCheck();</span><br><span class="line">        EditorGUILayout.PropertyField(mAlphaHitTestMinimumThreshold);</span><br><span class="line">        <span class="built_in">bool</span> thresholdChanged = EditorGUI.EndChangeCheck();</span><br><span class="line"></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableChanged || thresholdChanged)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateAllAlphaHitTextMinimusThresholdoTargets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 更新所有对象的透明Alpha穿透阈值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateAllAlphaHitTextMinimusThresholdoTargets</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(targets == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> targetObj <span class="keyword">in</span> targets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> penetrateImage = targetObj <span class="keyword">as</span> CustomImage;</span><br><span class="line">            <span class="keyword">if</span> (penetrateImage != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                penetrateImage.UpdateAlphaHitTestMinimumThreshold();</span><br><span class="line">                EditorUtility.SetDirty(targetObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Unity/RenderOrder/PenetrateImageInspector.PNG" alt="PenetrateImageInspector"></p>
<p><strong>此时再去点圆形周边透明区域就会发现不会触发btnMask的点击事件了。</strong></p>
<p>Note:</p>
<ol>
<li><strong>代码手动修改EnableAlphaHitTestMinimusThreshold或AlphaHitTestMinimumThreshold值时请手动调用UpdateAlphaHitTestMinimumThreshold()方法确保生效</strong></li>
<li><strong>修改透明可点击阈值时的Sprite必须勾选Read&#x2F;Write</strong></li>
</ol>
<p>设置alphaHitTestMinimumThreshold实现透明点击穿透在RawImage这里是行不通的，因为alphaHitTextMinimusThreshold是Image组件的属性，但穿透原理还是一样的，自定义RawImage想实现透明点击穿透控制，<strong>核心是实现ICanvasRaycastFilter的IsRaycastLocationValid()方法(告知Canvas射线检测时是否参与检测)，判定逻辑是通过将点击位置转换到自身Rectransform的相对位置后，基于显示Rect信息将点击相对位置转换成UV坐标去读取对应UV坐标的像素颜色信息比较Alpha值。</strong></p>
<p>CustomRawImage.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> TRawImage.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自定义RawImage用于支持反向遮罩和透明点击穿透设置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRawImage</span> : <span class="title">RawImage</span>, <span class="title">ICanvasRaycastFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启反向遮罩</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;是否开启反向遮罩&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> EnableInvertMask = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否激活透明Alpha透明可点击阈值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;是否激活透明Alpha透明可点击阈值&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> EnableAlphaHitTestMinimusThreshold = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 透明Alpha可点击阈值(<span class="doctag">&lt;=0表示全部可点击，&gt;</span>1表示全不可点击，其他值表示小于该值不可点击)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Note：</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 仅当EnableAlphaHitTestMinimusThreshold=true时有效</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;透明Alpha可点击阈值&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;&lt;=0表示全部可点击，&gt;1表示全不可点击，其他值表示小于该值不可点击&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> AlphaHitTestMinimumThreshold = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">    ******</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 重写射线检测，实现透明穿透功能</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 screenPoint, Camera eventCamera</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!EnableAlphaHitTestMinimusThreshold)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (AlphaHitTestMinimumThreshold &lt;= <span class="number">0f</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (AlphaHitTestMinimumThreshold &gt; <span class="number">1f</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Texture tex = texture;</span><br><span class="line">        <span class="keyword">if</span> (tex == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        Texture2D tex2D = tex <span class="keyword">as</span> Texture2D;</span><br><span class="line">        <span class="keyword">if</span> (tex2D == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tex2D.isReadable)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;TRawImage Alpha穿透检测需要纹理开启Read/Write Enabled: <span class="subst">&#123;tex2D.name&#125;</span>&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将屏幕坐标转换为RectTransform的本地坐标</span></span><br><span class="line">        <span class="keyword">if</span> (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint,</span><br><span class="line">                                                                     eventCamera, <span class="keyword">out</span> Vector2 localPoint))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Rect rect = GetPixelAdjustedRect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算UV坐标 (考虑uvRect偏移和缩放)</span></span><br><span class="line">        <span class="built_in">float</span> u = (localPoint.x - rect.x) / rect.width;</span><br><span class="line">        <span class="built_in">float</span> v = (localPoint.y - rect.y) / rect.height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用uvRect的偏移和缩放</span></span><br><span class="line">        Rect uv = uvRect;</span><br><span class="line">        u = uv.x + u * uv.width;</span><br><span class="line">        v = uv.y + v * uv.height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保UV在有效范围内</span></span><br><span class="line">        u = Mathf.Clamp01(u);</span><br><span class="line">        v = Mathf.Clamp01(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D.GetPixelBilinear(u, v).a &gt;= AlphaHitTestMinimumThreshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(</span><br><span class="line">                <span class="string">$&quot;TRawImage Alpha穿透检测读取纹理像素失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomRawImageEditor.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> CustomRawImageEditor.cs</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> CustomRawImage組件的自定义编辑器界面</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">CustomEditor(typeof(CustomRawImage), true)</span>]</span><br><span class="line">    [<span class="meta">CanEditMultipleObjects</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRawImageEditor</span> : <span class="title">RawImageEditor</span></span><br><span class="line">    &#123;</span><br><span class="line">        ******</span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否激活透明Alpha透明可点击阈值属性</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> SerializedProperty mEnableAlphaHitTestMinimusThreshold;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 透明Alpha可点击阈值属性</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> SerializedProperty mAlphaHitTestMinimumThreshold;</span><br><span class="line">        </span><br><span class="line">        ******</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">            serializedObject.Update();</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.PropertyField(mEnableInvertMask);</span><br><span class="line">            EditorGUILayout.PropertyField(mEnableAlphaHitTestMinimusThreshold);</span><br><span class="line">            EditorGUILayout.PropertyField(mAlphaHitTestMinimumThreshold);</span><br><span class="line"></span><br><span class="line">            DrawClearTextureButton();</span><br><span class="line"></span><br><span class="line">            serializedObject.ApplyModifiedProperties();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ******</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Unity/RenderOrder/PenetrateRawImageInspector.PNG" alt="PenetrateRawImageInspector"></p>
<p><strong>此时再去点圆形周边透明区域就会发现不会触发btnMask的点击事件了。</strong></p>
<p>Note:</p>
<ol>
<li><strong>参与CustomRawImage反向挖洞功能开启的Texture需要开启Read&#x2F;Write设置</strong></li>
</ol>
<h3 id="Mask-粒子特效"><a href="#Mask-粒子特效" class="headerlink" title="Mask+粒子特效"></a>Mask+粒子特效</h3><h4 id="Mask-自带ParticleAdditive-Shader"><a href="#Mask-自带ParticleAdditive-Shader" class="headerlink" title="Mask+自带ParticleAdditive Shader"></a>Mask+自带ParticleAdditive Shader</h4><p>在了解完Mask组件的常规UI遮罩原理后，接下来让我们尝试下UI上放入粒子特效</p>
<p><img src="/img/Unity/RenderOrder/ParticleAdditiveInspector.PNG" alt="ParticleAdditiveInspector"></p>
<p>可以看到我将<strong>Unity自带的Particle Additive的Shader</strong>导入工程并创建了一个材质球使用到了粒子系统身上，同时<strong>为了确保粒子特效显示层级在UI上，还专门设置了Sorting Layer ID为Default，Order in Layer为101(因为MainUI节点上挂了Canvas且设置的Sorting Layer为Default，Order in Layer为100)</strong>。</p>
<p>让我们看下Unity自带的Particle Additive的Shader代码:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Legacy Shaders/Particles/Additive&quot;</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">    _TintColor (<span class="string">&quot;Tint Color&quot;</span>, Color) = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)</span><br><span class="line">    _MainTex (<span class="string">&quot;Particle Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _InvFade (<span class="string">&quot;Soft Particles Factor&quot;</span>, Range(<span class="number">0.01</span>,<span class="number">3.0</span>)) = <span class="number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Category &#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;PreviewType&quot;</span>=<span class="string">&quot;Plane&quot;</span> &#125;</span><br><span class="line">    Blend SrcAlpha One</span><br><span class="line">    ColorMask RGB</span><br><span class="line">    Cull Off Lighting Off ZWrite Off</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            ******</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到默认的Particle Additive的Shader是没有带模板缓存相关的Shader代码支持的。渲染结果如下：</p>
<p><img src="/img/Unity/RenderOrder/ParticleAdditiveShowResult.PNG" alt="ParticleAdditiveShowResult"></p>
<p>不出意外Particle Additive的Shader的粒子特效超出了Mask显示范围。</p>
<h4 id="Mask-修改ParticleAdditive-Mask-Shader"><a href="#Mask-修改ParticleAdditive-Mask-Shader" class="headerlink" title="Mask+修改ParticleAdditive Mask Shader"></a>Mask+修改ParticleAdditive Mask Shader</h4><p>接下来我们尝试改造Particle Additive的Shader，复制一份改名Particle Additive Mask同时创建一个对应的材质球(ParticleAdditiveMaskMat)，赋值到particleSystem上。</p>
<p><img src="/img/Unity/RenderOrder/ParticleAdditiveMaskInspector.PNG" alt="ParticleAdditiveMaskInspector"></p>
<p>为了匹配Mask的模版缓存判定，我将<strong>Stencil ID设置成1(模版缓存参考比较值)，Stencil Comparison设置成3(Equal)，Stencil Operation设置成0(Keep)，ColorMask设置成15(所有颜色写入)，这些设置是为了在Mask下去比较模板缓存值1的才通过，从而实现超出Mask区域部分不通过不绘制</strong>。</p>
<p>让我们看看改造后的显示结果：</p>
<p><img src="/img/Unity/RenderOrder/ParticleAdditiveMaskShowResult.PNG" alt="ParticleAdditiveMaskShowResult"></p>
<p>结果发现粒子特效啥都没显示，让我们看看FrameDebugger是怎么回事。</p>
<p><img src="/img/Unity/RenderOrder/ParticleAdditiveMaskFrameDebugger.PNG" alt="ParticleAdditiveMaskFrameDebugger"></p>
<p><strong>从FrameDebugger可以看到粒子特效的渲染和常规UI的渲染流程不一样，因为粒子特效是当做3D物体渲染的，所以他的渲染顺序不想UI子节点图形没有在Canvas的渲染流程里，而是Canvas渲染完成后才通过Draw Dynamic的方式绘制的。</strong></p>
<p>还记得我们前面说的<strong>Mask组件在绘制完成后通过unmaskMaterial将模板缓存里的值已经修改成0了吗？</strong></p>
<p><strong>这个模版缓存值0也就是粒子特效不显示的原因，因为粒子特效Particle Additive Mask我们设置的Stencil ID(模版参考比较值)为1，Stencil Comparion为3(Equal)，也就意味着粒子特效通不过模板缓存测试所以什么都不显示了。</strong></p>
<h4 id="仅使用自带UI-Default-Shader"><a href="#仅使用自带UI-Default-Shader" class="headerlink" title="仅使用自带UI Default Shader"></a>仅使用自带UI Default Shader</h4><p><strong>unmaskMaterial这个流程是Mask流程里自带的，不修改源码是无法修改的，所以目前看来想通过粒子特效支持模板缓存功能从而通过Mask遮罩显示的方案是行不通的。</strong></p>
<p><strong>既然我们已经知道模板缓存是Mask实现遮罩的核心原理，那么我们如果不使用Mask组件，直接导入自带的UI Default Shader，通过直接创建一个非Mask的UI Default材质，一个负责Mask的UI Default Mask材质和一个支持被UI Default Mask遮罩后显示的UI Default Masked材质来实现模版遮罩功。</strong></p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMatInspector.PNG" alt="UIDefaultMatInspector"></p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskMatInspector.PNG" alt="UIDefaultMaskMatInspector"></p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskedMatInspector.PNG" alt="UIDefaultMaskedMatInspector"></p>
<p><strong>可以看到三份材质球都是使用功能的UI Default Shader，但为了Mask不同情况下正确显示，分别设置了不同的Stencil ID，Stencil Comparison，Stencil Operation值。UIDefaultMat用于不需要管遮罩时，UIDefaultMaskMat用在当做遮罩(相当于Mask挂载的情况)时，UIDefaultMaskedMat用在在遮罩里需要被遮罩时。</strong></p>
<p><strong>为了方便查看层级显示和遮罩效果，我创建了一个红色的使用UI Default Mat的最底层图和一个黄色的使用UI Default Mat的最顶层图(同时添加了Canvas设置了order高于特效显示order)</strong></p>
<p>来看看图片和特效相关的层级:</p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskSceneAndHierachy.PNG" alt="UIDefaultMaskSceneAndHierachy"></p>
<p>来看看运行时的效果:</p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskGame.PNG" alt="UIDefaultMaskGame"></p>
<p>可以看到无论是普通背景和前景图还是被遮罩的图还是粒子特效，通过赋予对应的UI Default Shader的材质球成功实现了Mask遮罩效果。</p>
<p>让我们来看看Frame Debugger是什么情况：</p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskFrameDebugger.PNG" alt="UIDefaultMaskFrameDebugger"></p>
<p><strong>可以看到带遮罩的相关图形显示在第一个Canvas.RenderSubBatch里，因为使用Mask组件，所以没有产生unmaskMaterial的流程，所以第一个Canvas.RenderSubBatch最后一个Draw Mesh是被遮罩的那个勾选图形，因为设置的是UI Default Masked Mat(Stencil ID为1，Stencil Comparison为3(Equal)，Stencil Operation为0(Keep))所以成功通过了模板缓存并遮罩显示。</strong></p>
<p>接着看看粒子特效显示是什么情况：</p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskParticleSystemFrameDebugger.PNG" alt="UIDefaultMaskParticleSystemFrameDebugger"></p>
<p><strong>粒子特效的显示和被遮罩的勾选图形原理和参数一致，紧接着第一个Canvas.RenderSubBatch之后渲染，所以也成功遮罩显示了。</strong></p>
<p>接着看看defaultFrontImg前景图是什么情况：</p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskSecondCanvasFrameDebugger.PNG" alt="UIDefaultMaskSecondCanvasFrameDebugger"></p>
<p><strong>可以看到因为我给defaultFrontImg添加了额外的Canvas并设置了比特效Order还高的Order，所以单独进行了一次Canvas.RenderSubBatch绘制，即第二个Canvas.RenderSubBatch绘制通过Stencil Ref值为0和Stencil Comparison为8(Always)成功将第二个Canvas渲染绘制的模板缓存值修改成0了。</strong></p>
<p><img src="/img/Unity/RenderOrder/UIDefaultMaskFrontImgFrameDebugger.PNG" alt="UIDefaultMaskFrontImgFrameDebugger"></p>
<p><strong>可以看到我给defaultFrontImg设置的UI Default Mat(Stencil ID为0，Stencile Comparison为8(Always)，Stencile Operation为0(Keep))完美符合了第二个Canvas.RenderSubBatch将模板值修改成0后的显示逻辑，所以成功绘制出来了。</strong></p>
<p>总结:</p>
<ol>
<li><strong>虽然通过制作不同的UI Default材质球可以实现遮罩不同的使用情况，但游戏开发过程中遮罩情况可能是动态变化，无法提前预知哪些是用于遮罩，哪些是在遮罩内，哪些是在遮罩外，所以这种方案虽然能实现遮罩效果但并没有实战使用价值。</strong></li>
</ol>
<h4 id="ParticleEffectForUGUI"><a href="#ParticleEffectForUGUI" class="headerlink" title="ParticleEffectForUGUI"></a>ParticleEffectForUGUI</h4><p>接下来让我们看看Github上最强特效和UI显示层级解决方案：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mob-sakai/ParticleEffectForUGUI">ParticleEffectForUGUI</a></p>
<p>特点介绍：</p>
<ul>
<li><strong>Sortable:</strong> Sort particle effects and other UI elements by sibling index.</li>
<li><strong>Maskable:</strong> Supports <code>Mask</code> or <code>RectMask2D</code>.</li>
<li><strong>No extra components required:</strong> No need for an additional <code>Camera</code>, <code>RenderTexture</code>, or <code>Canvas</code>.</li>
<li><strong>Trail module support:</strong> Fully supports the Trail module.</li>
<li><strong>CanvasGroup alpha support:</strong> Integrates with <code>CanvasGroup</code> alpha.</li>
<li><strong>No allocations:</strong> Efficiently renders particles without allocations.</li>
<li><strong>Any canvas render mode support:</strong> Works with overlay, camera space, and world space.</li>
<li><strong>Any Render pipeline support:</strong> Compatible with Universal Render Pipeline (URP) and High Definition Render Pipeline (HDRP).</li>
<li>省略</li>
</ul>
<p>从上面介绍可以看到<strong>ParticleEffectForUGUI能将特效在UI排序显示，无需任何Camera，RenderTexture或者Canvas。支持CanvasGroup的Alpha，支持Canvas的各种Render Mode。兼容URP，HDRP等。</strong></p>
<h5 id="ParticleEffectForUGUI导入"><a href="#ParticleEffectForUGUI导入" class="headerlink" title="ParticleEffectForUGUI导入"></a>ParticleEffectForUGUI导入</h5><p>我们通过Package Manager选择Git地址(<strong>注意#后面的数字是版本号</strong>)导入:</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/mob-sakai/ParticleEffectForUGUI.git<span class="params">#4</span>.11.4</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li><strong>导入完成后如果想直接使用源码版本，可以直接从Package下拷贝到Asset目录下使用，然后删除Package Manager里的导入库即可。</strong></li>
</ol>
<h5 id="扩展粒子特效Shader支持Stencil和Clip"><a href="#扩展粒子特效Shader支持Stencil和Clip" class="headerlink" title="扩展粒子特效Shader支持Stencil和Clip"></a>扩展粒子特效Shader支持Stencil和Clip</h5><p>粒子特效的Shader要像UI Default Shader一样支持UI的Mask和Clip功能。</p>
<p>Particle Add UI Mask.Shader</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Legacy Shaders/Particles/Additive UI Mask&quot;</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line"> 	******</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #### required for Mask ####</span></span><br><span class="line">    _StencilComp (<span class="string">&quot;Stencil Comparison&quot;</span>, Float) = <span class="number">8</span></span><br><span class="line">    _Stencil (<span class="string">&quot;Stencil ID&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">    _StencilOp (<span class="string">&quot;Stencil Operation&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">    _StencilWriteMask (<span class="string">&quot;Stencil Write Mask&quot;</span>, Float) = <span class="number">255</span></span><br><span class="line">    _StencilReadMask (<span class="string">&quot;Stencil Read Mask&quot;</span>, Float) = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    _ColorMask (<span class="string">&quot;Color Mask&quot;</span>, Float) = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Toggle(UNITY_UI_ALPHACLIP)</span>] _UseUIAlphaClip (<span class="string">&quot;Use Alpha Clip&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Category &#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;PreviewType&quot;</span>=<span class="string">&quot;Plane&quot;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #### required for Mask ####</span></span><br><span class="line">    Stencil</span><br><span class="line">    &#123;</span><br><span class="line">        Ref [_Stencil]</span><br><span class="line">        Comp [_StencilComp]</span><br><span class="line">        Pass [_StencilOp]</span><br><span class="line">        ReadMask [_StencilReadMask]</span><br><span class="line">        WriteMask [_StencilWriteMask]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Blend SrcAlpha One</span><br><span class="line">    <span class="comment">// #### required for Mask ####</span></span><br><span class="line">    ColorMask [_ColorMask]</span><br><span class="line">    Cull Off Lighting Off ZWrite Off</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line"></span><br><span class="line">            ******</span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">            <span class="meta">#include &quot;UnityUI.cginc&quot;</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile __ UNITY_UI_CLIP_RECT</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile __ UNITY_UI_ALPHACLIP</span></span><br><span class="line"></span><br><span class="line">            ******</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">struct</span> v2f &#123;</span><br><span class="line">				******</span><br><span class="line"></span><br><span class="line">                <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line"></span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">2</span>)</span><br><span class="line">                <span class="meta">#ifdef SOFTPARTICLES_ON</span></span><br><span class="line">                float4 projPos : TEXCOORD3;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">            float4 _ClipRect;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata_t v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                ******</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">                o.worldPosition = v.vertex;</span><br><span class="line"></span><br><span class="line">				******</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);</span><br><span class="line">            <span class="built_in">float</span> _InvFade;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                ******</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">                <span class="meta">#ifdef UNITY_UI_CLIP_RECT</span></span><br><span class="line">                    col.a *= UnityGet2DClipping(i.worldPosition.xy, _ClipRect);</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="meta">#ifdef UNITY_UI_ALPHACLIP</span></span><br><span class="line">                    clip(col.a - <span class="number">0.001</span>);</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                col.rgb *= col.a;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>核心是像UI Default Shader里加入了UNITY_UI_CLIP_RECT和UNITY_UI_ALPHACLIP以及Stencil模板相关的定义。</strong></p>
<p>Note:</p>
<ol>
<li><strong>注意定义v2f的worldPosition : TEXCOORD1时会占用TEXCOORD1，后续UNITY_FOG_COORDs(2)和projPos:TEXCOORD3都得顺势往后延</strong></li>
</ol>
<h5 id="制作粒子特效GameObject"><a href="#制作粒子特效GameObject" class="headerlink" title="制作粒子特效GameObject"></a>制作粒子特效GameObject</h5><p>第1种情况，从0制作粒子特效：</p>
<ol>
<li><p><strong>创建UIParticle GameObject</strong></p>
<p><img src="/img/Unity/RenderOrder/CreateEmptyUIParticleGameObject.PNG" alt="CreateEmptyUIParticleGameObject"></p>
</li>
<li><p>在UIParticle GameObject节点下只做粒子特效</p>
</li>
<li><p><strong>做完粒子特效后点击UIParticle面板上的Refresh按钮</strong></p>
<p><img src="/img/Unity/RenderOrder/UIParticleRefreshButton.PNG" alt="UIParticleRefreshButton"></p>
</li>
<li><p>保存UIParticle GameObject当做特效使用</p>
</li>
</ol>
<p>第二种情况，在已有的特效GameObject上制作粒子特效：</p>
<ol>
<li><p><strong>对已有粒子特效GameObject右键创建UIParticle</strong></p>
<p><img src="/img/Unity/RenderOrder/CreateUIParticleFromGameObject.PNG" alt="CreateUIParticleFromGameObject"></p>
</li>
<li><p>保存UIParticle GameObject当做特效使用</p>
</li>
</ol>
<p>Note:</p>
<ol>
<li><strong>通过ParticleEffectForUGUI制作的粒子特效我们不再需要手动调整Order，我们可以像调整UI节点一样放到对应位置即可</strong></li>
<li><strong>要想UIParticle制作的特效支持Mask需要勾选UIParticle的Maskable</strong></li>
</ol>
<h5 id="UIParticle缩放"><a href="#UIParticle缩放" class="headerlink" title="UIParticle缩放"></a>UIParticle缩放</h5><p><strong>UIParticle的显示大小根据UIParticle的AutoScalingMode设置不同而决定因素不同。UIParticle.scale是UIParticle提供控制粒子特效显示大小的一个参数。</strong></p>
<p>粒子最终渲染尺寸的计算公式如下：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289"><strong>最终尺寸 &#x3D; Scale3D值 × Canvas缩放因子 × 粒子系统自身缩放 × 父级UI元素缩放</strong></a></p>
<p><strong>UIParticle.AutoScalingMode是解决Canvas分辨率适配的核心参数</strong>，有三种模式:</p>
<ul>
<li><p><strong>None</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">行为：完全禁用自动缩放适配</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">适用场景：固定分辨率的应用（如某些嵌入式设备）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">缩放公式：最终尺寸 &#x3D; Scale3D值 × 粒子系统自身缩放</a></p>
</li>
<li><p><strong>Transform</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">行为：通过调整Transform.localScale适配Canvas缩放</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">适用场景：需要与其他UI元素保持一致缩放比例的情况</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">缩放公式：最终尺寸 &#x3D; Scale3D值 × Transform.localScale × 粒子系统自身缩放</a></p>
</li>
<li><p><strong>UIParticle</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">行为：通过调整UIParticle.scale3DForCalc的计算公式适配Canvas缩放</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">适用场景：大多数UI粒子效果，尤其是需要保持相对大小的元素</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">缩放公式：最终尺寸 &#x3D; Scale3D值 × Canvas缩放因子 × 粒子系统自身缩放</a></p>
</li>
</ul>
<p><strong>看网上的说法Position Mode是Absolute或者Relative对于AutoScalingMode.Transform还是AutoScalingMode.UIParticle选择有影响，目前未做测试。</strong></p>
<p>个人目前想法结论如下：</p>
<p><strong>AutoScalingMode推荐UIParticle，制作粒子特效的Simulation Space推荐Local，UIParticle.scale创建时默认是10所有特效制作时基于scale修改成1的标准来做，这样我们设置UIParticle.scale缩放时就是相对1的比例来考虑(这样更符合类似Transform Scale缩放理念的设置)，同时这种方式也支持我们去修改UIParticle自身Transform的localScale</strong></p>
<p>Note:</p>
<ol>
<li><strong>UIParticle.scale无论在任何模式下都会对粒子特效的最终显示大小都有影响</strong></li>
</ol>
<h5 id="UIParticle遮罩"><a href="#UIParticle遮罩" class="headerlink" title="UIParticle遮罩"></a>UIParticle遮罩</h5><p><strong>Mask遮罩，就像常规Mask遮罩UI对象一样，将制作的UIParticle GameObject放到对应节点位置即可。</strong></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUIMaskInspector.PNG" alt="ParticleEffectForUGUIMaskInspector"></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUIMaskShowResult.PNG" alt="ParticleEffectForUGUIMaskShowResult"></p>
<p>我们结合Mask遮罩来看看UIParticle是如何实现粒子特效支持Mask显示的。</p>
<p>首先看看粒子特效在FrameDebugger里是如何绘制的：</p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUIMaskFrameDebugger.PNG" alt="ParticleEffectForUGUIMaskFrameDebugger"></p>
<p><strong>可以看到粒子特效这一次没有在被当做3D对象单独绘制而是在Canvas.RenderSubBatch流程里绘制且绘制时机是在unmaskMaterial清除模板缓存值之前，我想这就就是为什么UIParticle绘制的粒子特效为什么能支持UI Mask和RectMask2D的原因。</strong></p>
<p>那么UIParticle是如何实现将UI粒子特效当做UI对象在Canvas里绘制的了？</p>
<p><strong>首先UIParticle是取消了ParticleSystem的Renderer组件激活(避免3D粒子特效的渲染)</strong></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUICancelPSRenderer.PNG" alt="ParticleEffectForUGUICancelPSRenderer"></p>
<p>然后我们来看看UIParticle.cs的代码定义:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Render maskable and sortable particle effect ,without Camera, RenderTexture or Canvas.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Icon(<span class="string">&quot;Packages/com.coffee.ui-particle/Editor/UIParticleIcon.png&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ExecuteAlways</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(RectTransform))</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(CanvasRenderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIParticle</span> : <span class="title">MaskableGraphic</span>, <span class="title">ISerializationCallbackReceiver</span></span><br><span class="line">&#123;</span><br><span class="line">    ******</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;UIParticleRenderer&gt; _renderers = <span class="keyword">new</span> List&lt;UIParticleRenderer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Camera _bakeCamera;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UpdateMaterial</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Call to update the geometry of the Graphic onto the CanvasRenderer.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UpdateGeometry</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到UIParticle组件添加时强制添加了<strong>CanvasRenderer</strong>组件的，同时UIParticle继承了<strong>MaskGraphic</strong>。</p>
<p><strong>CanvasRenderer组件是UIParticle融入到Canvas渲染流程里的必要组件</strong></p>
<p><strong>MaskGraphic是UIParticle获取Canvas UI渲染能力和遮罩支持的关键</strong></p>
<p>UIParticle通过重写MaskGraphic.UpdateMaterial和MaskGraphic.UpdateGeometry方法避免任何渲染和材质相关的逻辑。UIParticle真正的渲染逻辑是通过**UIParticleRenderer(也继承至MaskableGraphic)**类完成的，也就是UIParticle._renders这个成员对象。</p>
<p><strong>核心渲染流程方法是UIParticle.UpdateRenderers()，UIParticle.UpdateRenderers()方法是在UIParticleUpdater.cs里通过注入Canvas.onAfterCanvasRebuild(在Canvas渲染前调用)流程调用的</strong></p>
<p><strong>UIParticle.UpdateRenderers()会先收集之前通过UIParticle面板Refresh按钮搜集到的所有粒子特效，创建相关UIParticleRenderer对象(这里就是UIParticle._renders构建的地方)</strong></p>
<p><strong>然后UIParticle通过GetBakeCamera()方法获取到当前绘制Canvas的UICamera，然后UICamera传递调用UIParticleRenderer.UpdateMesh(BakeCamera)方法</strong></p>
<p><strong>UIParticleRenderer.UpdateMesh()方法里，通过调用ParticleSystemRenderer.BakeMesh()方法传入指定摄像机，将通过该UICamera渲染的Mesh保存到CombineInstance类数据里</strong></p>
<p><strong>然后将所有烘焙得到的CombineInstance的Mesh数据合并到一个mesh里(workerMesh.CombineMeshes())</strong></p>
<p><strong>最后将烘焙的bakeMesh数据设置到UIParticleRenderer.canvasRenderer.SetMesh()的Mesh里，然后UIParticleRenderer通过canvasRenderer参与到Canvas的绘制流程里，从而实现了粒子特效转换成UI Mesh参与到Canvas绘制流程里的过程。</strong></p>
<p>那么UIParticleRenderer是如何实现支持UGUI的Mask和RectMask2D遮罩功能的了？</p>
<p><strong>UIParticleRenderer.GetModifiedMaterial()里调用了base.GetModifiedMaterial()，接下来让我们看看内部的代码实现:</strong></p>
<p>MaskableGraphic.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> See IMaterialModifier.GetModifiedMaterial</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Material <span class="title">GetModifiedMaterial</span>(<span class="params">Material baseMaterial</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> toUse = baseMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_ShouldRecalculateStencil)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rootCanvas = MaskUtilities.FindRootSortOverrideCanvas(transform);</span><br><span class="line">        m_StencilValue = maskable ? MaskUtilities.GetStencilDepth(transform, rootCanvas) : <span class="number">0</span>;</span><br><span class="line">        m_ShouldRecalculateStencil = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we have a enabled Mask component then it will</span></span><br><span class="line">    <span class="comment">// generate the mask material. This is an optimisation</span></span><br><span class="line">    <span class="comment">// it adds some coupling between components though :(</span></span><br><span class="line">    Mask maskComponent = GetComponent&lt;Mask&gt;();</span><br><span class="line">    <span class="keyword">if</span> (m_StencilValue &gt; <span class="number">0</span> &amp;&amp; (maskComponent == <span class="literal">null</span> || !maskComponent.IsActive()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> maskMat = StencilMaterial.Add(toUse, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, StencilOp.Keep, CompareFunction.Equal, ColorWriteMask.All, (<span class="number">1</span> &lt;&lt; m_StencilValue) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        StencilMaterial.Remove(m_MaskMaterial);</span><br><span class="line">        m_MaskMaterial = maskMat;</span><br><span class="line">        toUse = m_MaskMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toUse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>通过获取当前节点的最上层Canvas获取到最近的m_StencilValue值，然后通过判定是否有Mask组件决定是否要触发StencilMaterial的材质球效果(Stencil ID值为(1&lt;&lt; m_StencilValue) - 1)，StencilOp值为0(Keep)，StencilComparison值为3(Equal)，Stencil ReadMask值为(1 &lt;&lt; m_StencilValue) - 1)，Stencil WriteMask值为0)。也就是与模板Stencil缓存值相比一致就通过模板测试的maskMat。个人认为这也就是UIParticleRenderer支持Mask的原因。</strong></p>
<p>那么UIParticle又是如何实现RectMask2D的遮罩支持的了？</p>
<p>核心是RectMask2D会在RectMask2D.PerformClipping()里遍历访问MaskableGraphic，并调用MaskableGraphic.SetClipRect()，让我们来看看MaskableGraphic.SetClipRect()的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> See IClippable.SetClipRect</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetClipRect</span>(<span class="params">Rect clipRect, <span class="built_in">bool</span> validRect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (validRect)</span><br><span class="line">        canvasRenderer.EnableRectClipping(clipRect);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        canvasRenderer.DisableRectClipping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到这里应该是通过canvasRenderer.EnableRectClipping()成功将Shader里的</strong>UNITY_UI_CLIP_RECT<strong>的Shader关键词激活了，后续应该是设置并传入了Shader里_ClipRect变量的裁剪区域值。</strong></p>
<p><strong>RectMask2D遮罩，就像常规RectMask2D遮罩UI对象一样，将制作的UIParticle GameObject放到对应节点位置即可。</strong></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUIRectMask2DInspector.PNG" alt="ParticleEffectForUGUIRectMask2DInspector"></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUIRectMask2DShowResult.PNG" alt="ParticleEffectForUGUIRectMask2DShowResult"></p>
<p>至此我们成功通关ParticleEffectForUGUI插件实现了特效在UI里的Mask和RectMask2D遮罩显示。</p>
<h5 id="UIParticle层级"><a href="#UIParticle层级" class="headerlink" title="UIParticle层级"></a>UIParticle层级</h5><p><strong>通过ParticleEffectForUGUI制作的特效，在处理UI层级问题时可以直接向处理UI节点一样，只要保证节点顺序就能保证显示层级。</strong></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUILayerInspector.PNG" alt="ParticleEffectForUGUILayerInspector"></p>
<p><img src="/img/Unity/RenderOrder/ParticleEffectForUGUILayerShowResult.PNG" alt="ParticleEffectForUGUILayerShowResult"></p>
<p><strong>可以看到我制作的白色粒子特效夹在UI中间显示，绿色粒子特效在最顶层显示正确显示了</strong></p>
<h5 id="UIParticleAttractor"><a href="#UIParticleAttractor" class="headerlink" title="UIParticleAttractor"></a>UIParticleAttractor</h5><p><strong>UIParticleAttractor脚本是ParticleEffectForUGUI提供的一个队粒子做额外动画的组件。</strong></p>
<p>比如指定粒子按半径的方式移动到目标UIParticleAttrctor所在为止。</p>
<p><img src="/img/Unity/RenderOrder/UIParticleAttractorInspector.PNG" alt="UIParticleAttractorInspector"></p>
<p><img src="/img/Unity/RenderOrder/UIParticleAttractorShowResult.PNG" alt="UIParticleAttractorShowResult"></p>
<p><strong>可以看到粒子在运行指定延迟时间后按目标终点以指定路线方式(e.g. 直线，曲线等)移动。</strong></p>
<p>效果挺神奇的，可以看出ParticleEffectForUGUI对粒子的控制做到了单个粒子级别。</p>
<h2 id="RectMask2D组件"><a href="#RectMask2D组件" class="headerlink" title="RectMask2D组件"></a>RectMask2D组件</h2><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33060405/article/details/143782999?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-143782999-blog-135170296.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-143782999-blog-135170296.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=4">RectMask2D是通过CanvasRenderer的裁剪矩形（ClipRect）实现，底层是CPU裁剪顶点。</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33060405/article/details/143782999?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-143782999-blog-135170296.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-143782999-blog-135170296.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=4">标准ParticleSystem渲染在Camera空间，走的是Renderer，不是UGUI的CanvasRenderer。</a></strong></p>
<p>从上面的介绍可以看到正常流程粒子特效没走CanvasRenderer，是无法被RectMask2D裁剪的，如果想支持粒子被RectMask2D裁剪，有两种方案：</p>
<ol>
<li><strong>将粒子特效重定向到CanvasRenderer里去渲染</strong></li>
<li><strong>手动写代码将RectMask2D的裁剪区域传递到粒子特效Shader里去，然后写Shader代码去判定裁剪显示</strong></li>
</ol>
<h3 id="将粒子特效重定向到CanvasRenderer里去渲染"><a href="#将粒子特效重定向到CanvasRenderer里去渲染" class="headerlink" title="将粒子特效重定向到CanvasRenderer里去渲染"></a>将粒子特效重定向到CanvasRenderer里去渲染</h3><p>此方案直接学习<a target="_blank" rel="noopener" href="https://github.com/mob-sakai/ParticleEffectForUGUI">ParticleEffectForUGUI</a>组件，参考前面的ParticleEffectForUGUI学习</p>
<h3 id="手动传递RectMask2D裁剪区域到粒子Shader"><a href="#手动传递RectMask2D裁剪区域到粒子Shader" class="headerlink" title="手动传递RectMask2D裁剪区域到粒子Shader"></a>手动传递RectMask2D裁剪区域到粒子Shader</h3><p>第二个方案参考:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41995872/article/details/103905945">Rect Mask2D遮住特效</a></p>
<p>Particle Add Mask.shader</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Legacy Shaders/Particles/Additive Mask&quot;</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">    ******</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">    _ClipRect (<span class="string">&quot;ClipRect&quot;</span>, Vector) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    _UNITY_UI_CLIP_RECT(<span class="string">&quot;UNITY_UI_CLIP_RECT&quot;</span>, <span class="built_in">float</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Category &#123;</span><br><span class="line">    ******</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line"></span><br><span class="line">            ******</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">            <span class="meta">#include &quot;UnityUI.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">            float4 _ClipRect;</span><br><span class="line">            <span class="built_in">float</span> _UNITY_UI_CLIP_RECT;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            fixed4 _TintColor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata_t &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                fixed4 color : COLOR;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f &#123;</span><br><span class="line">                ******</span><br><span class="line"></span><br><span class="line">                <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">                float4 worldPosition : TEXCOORD1;</span><br><span class="line"></span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">2</span>)</span><br><span class="line">                <span class="meta">#ifdef SOFTPARTICLES_ON</span></span><br><span class="line">                float4 projPos : TEXCOORD3;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata_t v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                ******</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">                o.worldPosition = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="meta">#ifdef SOFTPARTICLES_ON</span></span><br><span class="line">                o.projPos = ComputeScreenPos (o.vertex);</span><br><span class="line">                COMPUTE_EYEDEPTH(o.projPos.z);</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                o.color = v.color;</span><br><span class="line">                o.texcoord = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);</span><br><span class="line">            <span class="built_in">float</span> _InvFade;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                ******</span><br><span class="line"></span><br><span class="line">                <span class="comment">// #### required for RectMask2D ####</span></span><br><span class="line">                <span class="comment">//等效于 if(_UNITY_UI_CLIP_RECT == 1) col.a *= UnityGet2DClipping(i.worldPosition.xy, _ClipRect);</span></span><br><span class="line">                col.a *= pow(UnityGet2DClipping(i.worldPosition.xy, _ClipRect) + <span class="number">1</span>, _UNITY_UI_CLIP_RECT) - _UNITY_UI_CLIP_RECT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li><strong>注意定义v2f的worldPosition : TEXCOORD1时会占用TEXCOORD1，后续UNITY_FOG_COORDs(2)和projPos:TEXCOORD3都得顺势往后延</strong></li>
<li><strong>因为粒子特效默认不是在UI的CanvasRenderer模式下渲染的，所以__ UNITY_UI_CLIP_RECT和__ UNITY_UI_ALPHACLIP宏默认是不是起作用的</strong></li>
</ol>
<p>ParticleClip.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ParticleClip.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 用于粒子系统遮罩裁剪</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParticleClip</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> RectMask2D裁剪区域</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;RectMask2D裁剪区域&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Vector4 ClipRect;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子Renderer组件列表</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> Renderer[] mChildRenderers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> mask = GetComponentInParent&lt;UnityEngine.UI.RectMask2D&gt;();</span><br><span class="line">        <span class="keyword">if</span> (mask == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mChildRenderers = GetComponentsInChildren&lt;Renderer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(mChildRenderers == <span class="literal">null</span> || mChildRenderers.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector3[] vector3s = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">        mask.rectTransform.GetWorldCorners(vector3s);</span><br><span class="line">        ClipRect = <span class="keyword">new</span> Vector4(vector3s[<span class="number">0</span>].x, vector3s[<span class="number">0</span>].y, vector3s[<span class="number">2</span>].x, vector3s[<span class="number">2</span>].y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> renderer <span class="keyword">in</span> mChildRenderers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rendererMaterial = renderer.material;</span><br><span class="line">            <span class="keyword">if</span>(rendererMaterial == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rendererMaterial.HasVector(<span class="string">&quot;_ClipRect&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                rendererMaterial.SetVector(<span class="string">&quot;_ClipRect&quot;</span>, ClipRect);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rendererMaterial.HasFloat(<span class="string">&quot;_UNITY_UI_CLIP_RECT&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                rendererMaterial.SetFloat(<span class="string">&quot;_UNITY_UI_CLIP_RECT&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/Unity/RenderOrder/RectMask2DAndParticleClipInspector.PNG" alt="RectMask2DAndParticleClipInspector"></p>
<p><img src="/img/Unity/RenderOrder/ParticleClipAdditiveMaskShaderInspector.PNG" alt="ParticleClipAdditiveMaskShaderInspector"></p>
<p>可以看到通过ParticleClip.cs脚本，我成功将RectMask2D的裁剪区域数据和是否启用UNITY_UI_CLIP_RECT的数据传递到了Particle Add Mask.shader，让我们看看最终效果：</p>
<p><img src="/img/Unity/RenderOrder/RectMask2DAndParticleClipShowResult.PNG" alt="RectMask2DAndParticleClipShowResult"></p>
<p><strong>可以看到通过传递自定义RectMask2D裁剪区域以及粒子特效Shader支持裁剪区域显示判定，我们成功实现了支持RectMask2D的粒子特效遮罩显示</strong></p>
<p>总结:</p>
<ol>
<li><strong>此方案虽然能实现粒子特效的RectMask2D的遮罩效果，但节点挂载情况无时无刻都在变化，此方案不适合放到实战里去运用，只做为学习理解RectMask2D的裁剪原理</strong></li>
</ol>
<h1 id="3D和2D混合显示及决方案"><a href="#3D和2D混合显示及决方案" class="headerlink" title="3D和2D混合显示及决方案"></a>3D和2D混合显示及决方案</h1><p>有了前面的渲染顺序基础知识以及Mask相关知识，现在让我们再来看看游戏开发过程中遇到的3D物体和2D UI需要混合显示的问题该如何解决了？</p>
<p>通过前面的学习，特效和UI混合显示已经有了很好的方案:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mob-sakai/ParticleEffectForUGUI">ParticleEffectForUGUI</a></p>
<p>但ParticleEffectForUGUI并不支持模型的显示。</p>
<p>结合前面渲染顺序的学习，目前个人想到两种方案:</p>
<ol>
<li><strong>Extra 3D Model Camera</strong></li>
<li><strong>Extra Camera+Render Texture</strong></li>
</ol>
<p>Note:</p>
<ol>
<li><strong>3D在UI混合显示需要在Transparent Renderer Queue</strong></li>
</ol>
<h2 id="Extra-3D-Model-Camera"><a href="#Extra-3D-Model-Camera" class="headerlink" title="Extra 3D Model Camera"></a>Extra 3D Model Camera</h2><p><strong>额外3D模型摄像机照射模型，然后通过预设3D场景摄像机，UI摄像机，3D模型摄像机的Depth值来排序显示。</strong></p>
<p>好处:</p>
<ol>
<li><strong>3D模型只需要计算2D映射到3D摄像机的坐标位置显示即可，然后再处理一下不同分辨率的模型大小动态计算解决分辨率显示大小不同意问题即可</strong></li>
</ol>
<p>坏处：</p>
<ol>
<li><strong>3D模型摄像机只能固定在UI摄像机上或者下显示，如果在UI摄像机下方还会被背景图遮挡，所以理论上3D模型摄像机选择设置在UI摄像机上方显示(会导致UI没法盖住3D模型)</strong></li>
<li><strong>跨UI显示时，老的3D模型需要额外处理，不然会穿透显示</strong></li>
</ol>
<p>坏处1解决方案如下：</p>
<p>将做成<strong>显示3D模型的界面全都做成全屏，背景做成和模型一起显示而UI不要背景的方式也能将UI显示在模型上</strong>，但这样的话模型显示的界面限制多(<strong>显示3D模型是不能有UI背景图显示且需要窗口全屏显示</strong>)不太方便。</p>
<p>针对坏处2的解决方案如下：</p>
<p><strong>通过编写一个UIModelManager来统一管理UI 3D模型的创建和显示管理，将3D模型的显示和UI窗口绑定关联，在打开新UI时，只要绑定的UI不在最顶层，3D模型就统一隐藏不显示(比如把对应3D摄像机直接隐藏)，反之显示，此方案要注意如果支持同名窗口多开，3D模型和UI事例对象窗口的绑定唯一性问题要注意处理。</strong></p>
<p><strong>实战TODO</strong></p>
<h2 id="3D-Camera-Render-Texture"><a href="#3D-Camera-Render-Texture" class="headerlink" title="3D Camera + Render Texture"></a>3D Camera + Render Texture</h2><p><strong>此方案思路是将3D摄像机单独照射后渲染到Render Texture上，然后通过UI上显示Render Texture的内容来实现模型在UI上的显示。</strong></p>
<p>好处：</p>
<ol>
<li><strong>3D模型显示的层级问题很好解决，可以像UI一般夹层显示，不用担心任何夹层和跨UI打开问题</strong></li>
</ol>
<p>坏处：</p>
<ol>
<li><strong>Camera+Render Texture会需要额外的纹理贴图开销，其次显示效果经过额外Shader处理不如直接照射效果好</strong></li>
</ol>
<p>这个以前实现过就不再实战了。</p>
<h1 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h1><ol>
<li><strong>Mask的底层遮罩原理是使用了模板缓存机制</strong></li>
<li><strong>RectMask2D的底层遮罩原理是利用C#层计算裁剪区域，然后传递给Shader开启UNITY_UI_CLIP_RECT进行裁剪区域显示判定</strong></li>
<li><strong>粒子特效默认是当做3D物体渲染，不参与Canvas Renderer流程，ParticleEffectForUGUI是通过将粒子特效自定义绘制到MaskableGraphic的UIParticleRenderer组件从而实现的粒子特效参与到Canvas Renderer以及支持Mask和RectMask2D遮罩的</strong></li>
</ol>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><a target="_blank" rel="noopener" href="https://github.com/mob-sakai/ParticleEffectForUGUI">ParticleEffectForUGUI</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://indienova.com/indie-game-development/stencil-buffer-and-stencil-test/">走进 Stencil Buffer 系列 0 : 模板缓冲和模板测试是什么?</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/592341267">模板测试（Stencil Test）基本概念</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f79f0da90103">ShaderLab: Stencil Buffer 的理解和应用</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_14402/10670234">Unity 粒子特效在模型前面显示 unity ui粒子特效</a></p>
<p><a target="_blank" rel="noopener" href="https://duanyiliang.com/2020/11/05/unity_particlesystem_mask/">UI上的特效的裁剪问题</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00936/article/details/151919289">解决Unity UI粒子缩放异常：ParticleEffectForUGUI的Scale参数完全指南</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Rendering/">Rendering</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Rendering/">Rendering</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://tonytang1990.github.io/2026/01/29/UGUI%E9%81%AE%E7%BD%A9%E5%8E%9F%E7%90%86/" data-title="UGUI遮罩原理 | 走停人生路" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2026/01/29/渲染顺序/"  title="渲染顺序">
 <strong>下一篇：</strong><br/> 
 <span>渲染顺序
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mask"><span class="toc-number">2.</span> <span class="toc-text">Mask</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mask%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Mask组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stencil-Buffer"><span class="toc-number">2.1.1.</span> <span class="toc-text">Stencil Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mask-UI%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">Mask+UI组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask%E6%8C%96%E6%B4%9E-UI%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Mask挖洞+UI组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E7%82%B9%E5%87%BB-UI%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">Mask透明区域是否可点击+UI组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mask-%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">Mask+粒子特效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask-%E8%87%AA%E5%B8%A6ParticleAdditive-Shader"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">Mask+自带ParticleAdditive Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask-%E4%BF%AE%E6%94%B9ParticleAdditive-Mask-Shader"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">Mask+修改ParticleAdditive Mask Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6UI-Default-Shader"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">仅使用自带UI Default Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParticleEffectForUGUI"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">ParticleEffectForUGUI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ParticleEffectForUGUI%E5%AF%BC%E5%85%A5"><span class="toc-number">2.1.3.4.1.</span> <span class="toc-text">ParticleEffectForUGUI导入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88Shader%E6%94%AF%E6%8C%81Stencil%E5%92%8CClip"><span class="toc-number">2.1.3.4.2.</span> <span class="toc-text">扩展粒子特效Shader支持Stencil和Clip</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88GameObject"><span class="toc-number">2.1.3.4.3.</span> <span class="toc-text">制作粒子特效GameObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticle%E7%BC%A9%E6%94%BE"><span class="toc-number">2.1.3.4.4.</span> <span class="toc-text">UIParticle缩放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticle%E9%81%AE%E7%BD%A9"><span class="toc-number">2.1.3.4.5.</span> <span class="toc-text">UIParticle遮罩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticle%E5%B1%82%E7%BA%A7"><span class="toc-number">2.1.3.4.6.</span> <span class="toc-text">UIParticle层级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIParticleAttractor"><span class="toc-number">2.1.3.4.7.</span> <span class="toc-text">UIParticleAttractor</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RectMask2D%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">RectMask2D组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0CanvasRenderer%E9%87%8C%E5%8E%BB%E6%B8%B2%E6%9F%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">将粒子特效重定向到CanvasRenderer里去渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%BC%A0%E9%80%92RectMask2D%E8%A3%81%E5%89%AA%E5%8C%BA%E5%9F%9F%E5%88%B0%E7%B2%92%E5%AD%90Shader"><span class="toc-number">2.2.2.</span> <span class="toc-text">手动传递RectMask2D裁剪区域到粒子Shader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3D%E5%92%8C2D%E6%B7%B7%E5%90%88%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">3D和2D混合显示及决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Extra-3D-Model-Camera"><span class="toc-number">3.1.</span> <span class="toc-text">Extra 3D Model Camera</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D-Camera-Render-Texture"><span class="toc-number">3.2.</span> <span class="toc-text">3D Camera + Render Texture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">学习总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Github"><span class="toc-number">5.</span> <span class="toc-text">Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">6.</span> <span class="toc-text">Reference</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/AI/" title="AI">AI<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Art/" title="Art">Art<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Automation/" title="Automation">Automation<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Collision/" title="Collision">Collision<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Database/" title="Database">Database<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Editor/" title="Editor">Editor<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Excel/" title="Excel">Excel<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Game/" title="Game">Game<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/HotUpdate/" title="HotUpdate">HotUpdate<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Lua/" title="Lua">Lua<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Math/" title="Math">Math<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Native/" title="Native">Native<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Network/" title="Network">Network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Optimization/" title="Optimization">Optimization<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Other/" title="Other">Other<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Plugin/" title="Plugin">Plugin<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming/" title="Programming">Programming<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Programming-Language/" title="Programming Language">Programming Language<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Rendering/" title="Rendering">Rendering<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Resource/" title="Resource">Resource<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Unity/" title="Unity">Unity<sup>7</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Editor/" title="Editor">Editor<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Other/" title="Other">Other<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Rendering/" title="Rendering">Rendering<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Resource/" title="Resource">Resource<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Art/" title="Art">Art<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UI/" title="UI">UI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C#">C#<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Database/" title="Database">Database<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shader/" title="Shader">Shader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SubmlineText3/" title="SubmlineText3">SubmlineText3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Native/" title="Native">Native<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Prefab/" title="Prefab">Prefab<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Plugin/" title="Plugin">Plugin<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2026 
		
		<a href="/about" target="_blank" title="Tony Tang">Tony Tang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
